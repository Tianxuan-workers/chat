import { MaybeAccessor } from '@solidjs-use/shared';
import { Accessor } from 'solid-js';

interface UseStepperReturn<StepName, Steps, Step> {
    /** List of steps. */
    steps: Accessor<Steps>;
    /** List of step names. */
    stepNames: Accessor<StepName[]>;
    /** Index of the current step. */
    index: Accessor<number>;
    /** Current step. */
    current: Accessor<Step>;
    /** Next step, or undefined if the current step is the last one. */
    next: Accessor<StepName | undefined>;
    /** Previous step, or undefined if the current step is the first one. */
    previous: Accessor<StepName | undefined>;
    /** Whether the current step is the first one. */
    isFirst: Accessor<boolean>;
    /** Whether the current step is the last one. */
    isLast: Accessor<boolean>;
    /** Get the step at the specified index. */
    at: (index: number) => Step | undefined;
    /** Get a step by the specified name. */
    get: (step: StepName) => Step | undefined;
    /** Go to the specified step. */
    goTo: (step: StepName) => void;
    /** Go to the next step. Does nothing if the current step is the last one. */
    goToNext: () => void;
    /** Go to the previous step. Does nothing if the current step is the previous one. */
    goToPrevious: () => void;
    /** Go back to the given step, only if the current step is after. */
    goBackTo: (step: StepName) => void;
    /** Checks whether the given step is the next step. */
    isNext: (step: StepName) => boolean;
    /** Checks whether the given step is the previous step. */
    isPrevious: (step: StepName) => boolean;
    /** Checks whether the given step is the current step. */
    isCurrent: (step: StepName) => boolean;
    /** Checks if the current step is before the given step. */
    isBefore: (step: StepName) => boolean;
    /** Checks if the current step is after the given step. */
    isAfter: (step: StepName) => boolean;
}
declare function useStepper<T extends string | number>(steps: MaybeAccessor<T[]>, initialStep?: T): UseStepperReturn<T, T[], T>;
declare function useStepper<T extends Record<string, any>>(steps: MaybeAccessor<T>, initialStep?: keyof T): UseStepperReturn<Exclude<keyof T, symbol>, T, T[keyof T]>;

export { UseStepperReturn, useStepper };
