type CacheKey = any;
/**
 * Custom memoize cache handler
 */
interface UseMemoizeCache<Key, Value> {
    /**
     * Get value for key
     */
    get: (key: Key) => Value | undefined;
    /**
     * Set value for key
     */
    set: (key: Key, value: Value) => void;
    /**
     * Return flag if key exists
     */
    has: (key: Key) => boolean;
    /**
     * Delete value for key
     */
    delete: (key: Key) => void;
    /**
     * Clear cache
     */
    clear: () => void;
}
/**
 * Memoized function
 */
interface UseMemoizeReturn<Result, Args extends unknown[]> {
    /**
     * Get result from cache or call memoized function
     */
    (...args: Args): Result;
    /**
     * Call memoized function and update cache
     */
    load: (...args: Args) => Result;
    /**
     * Delete cache of given arguments
     */
    delete: (...args: Args) => void;
    /**
     * Clear cache
     */
    clear: () => void;
    /**
     * Generate cache key for given arguments
     */
    generateKey: (...args: Args) => CacheKey;
    /**
     * Cache container
     */
    cache: UseMemoizeCache<CacheKey, Result>;
}
interface UseMemoizeOptions<Result, Args extends unknown[]> {
    getKey?: (...args: Args) => string | number;
    cache?: UseMemoizeCache<CacheKey, Result>;
}
/**
 * Reactive function result cache based on arguments
 */
declare function useMemoize<Result, Args extends unknown[]>(resolver: (...args: Args) => Result, options?: UseMemoizeOptions<Result, Args>): UseMemoizeReturn<Result, Args>;

export { UseMemoizeCache, UseMemoizeOptions, UseMemoizeReturn, useMemoize };
