import { isFunction, noop, unAccessor, isClient, isString, watch, tryOnCleanup, isIOS, resolveAccessor, promiseTimeout, tryOnMount, increaseWithUnit, useTimeoutFn, pausableWatch, createEventHook, identity, isNumber, clamp, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, until, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, isObject, useIntervalFn, syncSignal, toAccessors, objectPick, watchWithFilter } from "@solidjs-use/shared";
export * from "@solidjs-use/shared";
import { createEffect, createSignal, on, getOwner, runWithOwner, createMemo, onCleanup, onMount } from "solid-js";
import { isAccessor, toSignal, nextTick, isFunction as isFunction$1, writableComputed, isSignal, set, del, toAccessor, getSetterValue, reactive } from "@solidjs-use/shared/solid-to-vue";
import { createMutable } from "solid-js/store";
function watchEffect(callback) {
  let preCleanupFn = () => {
  };
  const onCleanup2 = (cleanupFn) => {
    preCleanupFn();
    preCleanupFn = cleanupFn;
  };
  createEffect(() => {
    callback(onCleanup2);
  });
}
function createAsyncMemo(evaluationCallback, initialState, optionsOrSetter) {
  let options;
  if (isFunction(optionsOrSetter)) {
    options = {
      setEvaluating: optionsOrSetter
    };
  } else {
    options = optionsOrSetter ?? {};
  }
  const { setEvaluating = void 0, onError = noop } = options;
  const [current, setCurrent] = createSignal(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (setEvaluating) {
      setEvaluating(true);
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (setEvaluating) {
            setEvaluating(false);
          }
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        setCurrent(() => result);
    } catch (e) {
      onError(e);
    } finally {
      if (setEvaluating && counterAtBeginning === counter)
        setEvaluating(false);
      hasFinished = true;
    }
  });
  return current;
}
const createUnAccessorFn = (fn) => {
  return function(...args) {
    return fn.apply(
      this,
      args.map((i) => unAccessor(i))
    );
  };
};
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
const defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events2;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events2, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unAccessor(target), unAccessor(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        })
      );
    }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnCleanup(stop);
  return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
  if (!window2)
    return;
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some(
          (el2) => el2 === event.target || event.composedPath().includes(el2)
        );
      }
      const el = unAccessor(target2);
      return el && (event.target === el || event.composedPath().includes(el));
    });
  };
  const listener = (event) => {
    const el = unAccessor(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(
      window2,
      "pointerdown",
      (e) => {
        const el = unAccessor(target);
        if (el)
          shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
      },
      { passive: true }
    ),
    detectIframe && useEventListener(window2, "blur", (event) => {
      var _a;
      const el = unAccessor(target);
      if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
        handler(event);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
const createKeyPredicate = (keyFilter) => {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
};
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const { target = defaultWindow, eventName = "keydown", passive = false } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keydown" });
}
function onKeyPressed(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keypress" });
}
function onKeyUp(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keyup" });
}
const DEFAULT_DELAY = 500;
function onLongPress(target, handler, options) {
  var _a, _b;
  const elementRef = resolveAccessor(target);
  let timeout;
  function clear() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  }
  function onDown(ev) {
    var _a2, _b2, _c;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef())
      return;
    clear();
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    timeout = setTimeout(() => handler(ev), (options == null ? void 0 : options.delay) ?? DEFAULT_DELAY);
  }
  const listenerOptions = {
    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once
  };
  useEventListener(elementRef, "pointerdown", onDown, listenerOptions);
  useEventListener(elementRef, "pointerup", clear, listenerOptions);
  useEventListener(elementRef, "pointerleave", clear, listenerOptions);
}
const isFocusedElementEditable = () => {
  const { activeElement, body } = document;
  if (!activeElement)
    return false;
  if (activeElement === body)
    return false;
  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return activeElement.hasAttribute("contenteditable");
};
const isTypedCharValid = ({ keyCode, metaKey, ctrlKey, altKey }) => {
  if (metaKey || ctrlKey || altKey)
    return false;
  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)
    return true;
  if (keyCode >= 65 && keyCode <= 90)
    return true;
  return false;
};
function onStartTyping(callback, options = {}) {
  const { document: document2 = defaultDocument } = options;
  const keydown = (event) => {
    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);
  };
  if (document2)
    useEventListener(document2, "keydown", keydown, { passive: true });
}
function useActiveElement(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const document2 = options.document ?? (window2 == null ? void 0 : window2.document);
  const [activeElement, setActiveElement] = createSignal(
    document2 == null ? void 0 : document2.activeElement
  );
  if (window2) {
    useEventListener(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        setActiveElement(() => document2 == null ? void 0 : document2.activeElement);
      },
      true
    );
    useEventListener(
      window2,
      "focus",
      () => {
        setActiveElement(() => document2 == null ? void 0 : document2.activeElement);
      },
      true
    );
  }
  return activeElement;
}
function useAsyncState(promise, initialState, options) {
  const {
    immediate = true,
    delay = 0,
    onError = noop,
    onSuccess = noop,
    resetOnExecute = true,
    throwError
  } = options ?? {};
  const [state, setState] = createSignal(initialState);
  const [isReady, setReady] = createSignal(false);
  const [isLoading, setLoading] = createSignal(false);
  const [error, setError] = createSignal(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      setState(() => initialState);
    setError(void 0);
    setReady(false);
    setLoading(true);
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      setState(() => data);
      setReady(true);
      onSuccess(data);
    } catch (e) {
      setError(e);
      onError(e);
      if (throwError)
        throw e;
    } finally {
      setLoading(false);
    }
    return state();
  }
  if (immediate)
    execute(delay);
  return {
    state,
    isReady,
    isLoading,
    error,
    execute
  };
}
const defaults = {
  array: (v) => JSON.stringify(v),
  object: (v) => JSON.stringify(v),
  set: (v) => JSON.stringify(Array.from(v)),
  map: (v) => JSON.stringify(Object.fromEntries(v)),
  null: () => ""
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults.null;
  if (target instanceof Map)
    return defaults.map;
  else if (target instanceof Set)
    return defaults.set;
  else if (Array.isArray(target))
    return defaults.array;
  return defaults.object;
}
function useBase64(target, options) {
  const [base64, setBase64] = createSignal("");
  const [promise, setPromise] = createSignal();
  function execute() {
    if (!isClient)
      return;
    const promiseVal = new Promise((resolve, reject) => {
      try {
        const _target = unAccessor(target);
        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) ?? getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    setPromise(() => promiseVal);
    promiseVal.then((res) => setBase64(res));
    return promiseVal;
  }
  if (isAccessor(target)) {
    createEffect(on(target, execute));
  } else {
    execute();
  }
  return {
    base64,
    promise,
    execute
  };
}
function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      resolve(e.target.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function useSupported(callback, sync = false) {
  const [isSupported, setIsSupport] = createSignal(Boolean(callback()));
  const update = () => setIsSupport(Boolean(callback()));
  tryOnMount(update, sync);
  return isSupported;
}
function useBattery({ navigator = defaultNavigator } = {}) {
  const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported = useSupported(() => navigator && "getBattery" in navigator);
  const [charging, setCharging] = createSignal(false);
  const [chargingTime, setChargingTime] = createSignal(0);
  const [dischargingTime, setDischargingTime] = createSignal(0);
  const [level, setLevel] = createSignal(1);
  let battery;
  function updateBatteryInfo() {
    setCharging(this.charging);
    setChargingTime(this.chargingTime || 0);
    setDischargingTime(this.dischargingTime || 0);
    setLevel(this.level);
  }
  const owner = getOwner();
  if (isSupported()) {
    navigator.getBattery().then((_battery) => {
      battery = _battery;
      updateBatteryInfo.call(battery);
      for (const event of events2) {
        runWithOwner(owner, () => {
          useEventListener(battery, event, updateBatteryInfo, { passive: true });
        });
      }
    });
  }
  return {
    isSupported,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}
function useBluetooth(options) {
  let { acceptAllDevices = false } = options ?? {};
  const { filters = void 0, optionalServices = void 0, navigator = defaultNavigator } = options ?? {};
  const isSupported = useSupported(() => navigator && "bluetooth" in navigator);
  const [device, setDevice] = createSignal(void 0);
  const [error, setError] = createSignal(null);
  const [server, setServer] = createSignal();
  createEffect(
    on(
      device,
      () => {
        connectToBluetoothGATTServer();
      },
      { defer: true }
    )
  );
  async function requestDevice() {
    if (!isSupported())
      return;
    setError(null);
    if (filters && filters.length > 0)
      acceptAllDevices = false;
    try {
      const deviceVal = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
      setDevice(deviceVal);
    } catch (err) {
      setError(err);
    }
  }
  const isConnected = createMemo(() => {
    var _a;
    return ((_a = server()) == null ? void 0 : _a.connected) ?? false;
  });
  async function connectToBluetoothGATTServer() {
    setError(null);
    const deviceVal = device();
    if (deviceVal == null ? void 0 : deviceVal.gatt) {
      deviceVal == null ? void 0 : deviceVal.addEventListener("gattserverdisconnected", () => {
      });
      try {
        setServer(await deviceVal.gatt.connect());
      } catch (err) {
        setError(err);
      }
    }
  }
  tryOnMount(() => {
    var _a;
    const deviceVal = device();
    if (deviceVal)
      (_a = deviceVal.gatt) == null ? void 0 : _a.connect();
  });
  tryOnCleanup(() => {
    var _a;
    const deviceVal = device();
    if (deviceVal)
      (_a = deviceVal.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported,
    isConnected,
    // Device:
    device,
    requestDevice,
    // Server:
    server,
    // Errors:
    error
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const [matches, setMatches] = createSignal(false);
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", update);
    else
      mediaQuery.removeListener(update);
  };
  const update = () => {
    if (!isSupported())
      return;
    cleanup();
    mediaQuery = window2.matchMedia(resolveAccessor(query)());
    setMatches(mediaQuery.matches);
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update);
    else
      mediaQuery.addListener(update);
  };
  createEffect(update);
  tryOnCleanup(() => cleanup());
  return matches;
}
const breakpointsTailwind = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetify = {
  xs: 600,
  sm: 960,
  md: 1264,
  lg: 1904
};
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 600,
  sm: 1024,
  md: 1440,
  lg: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
const breakpointsMasterCss = {
  "3xs": 360,
  "2xs": 480,
  xs: 600,
  sm: 768,
  md: 1024,
  lg: 1280,
  xl: 1440,
  "2xl": 1600,
  "3xl": 1920,
  "4xl": 2560
};
function useBreakpoints(breakpoints, options = {}) {
  function getValue2(k, delta) {
    let v = breakpoints[k];
    if (delta != null)
      v = increaseWithUnit(v, delta);
    if (typeof v === "number")
      v = `${v}px`;
    return v;
  }
  const { window: window2 = defaultWindow } = options;
  function match(query) {
    if (!window2)
      return false;
    return window2.matchMedia(query).matches;
  }
  const greaterOrEqual = (k) => {
    return useMediaQuery(`(min-width: ${getValue2(k)})`, options);
  };
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      value: greaterOrEqual(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  return {
    greater(k) {
      return useMediaQuery(`(min-width: ${getValue2(k, 0.1)})`, options);
    },
    greaterOrEqual,
    smaller(k) {
      return useMediaQuery(`(max-width: ${getValue2(k, -0.1)})`, options);
    },
    smallerOrEqual(k) {
      return useMediaQuery(`(max-width: ${getValue2(k)})`, options);
    },
    between(a, b) {
      return useMediaQuery(`(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`, options);
    },
    isGreater(k) {
      return match(`(min-width: ${getValue2(k, 0.1)})`);
    },
    isGreaterOrEqual(k) {
      return match(`(min-width: ${getValue2(k)})`);
    },
    isSmaller(k) {
      return match(`(max-width: ${getValue2(k, -0.1)})`);
    },
    isSmallerOrEqual(k) {
      return match(`(max-width: ${getValue2(k)})`);
    },
    isInBetween(a, b) {
      return match(`(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`);
    },
    ...shortcutMethods
  };
}
const useBroadcastChannel = (options) => {
  const { name, window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "BroadcastChannel" in window2);
  const [isClosed, setClosed] = createSignal(false);
  const [channel, setChannel] = createSignal();
  const [data, setData] = createSignal();
  const [error, setError] = createSignal();
  const post = (data2) => {
    const channelVal = channel();
    if (channelVal)
      channelVal.postMessage(data2);
  };
  const close = () => {
    const channelVal = channel();
    if (channelVal)
      channelVal.close();
    setClosed(true);
  };
  if (isSupported()) {
    tryOnMount(() => {
      setError(null);
      const channelVal = new BroadcastChannel(name);
      setChannel(() => channelVal);
      channelVal.addEventListener(
        "message",
        (e) => {
          setData(e.data);
        },
        { passive: true }
      );
      channelVal.addEventListener(
        "messageerror",
        (e) => {
          setError(e);
        },
        { passive: true }
      );
      channelVal.addEventListener("close", () => {
        setClosed(true);
      });
    });
  }
  tryOnCleanup(() => {
    close();
  });
  return {
    isSupported,
    channel,
    data,
    post,
    close,
    error,
    isClosed
  };
};
function useBrowserLocation({ window: window2 = defaultWindow } = {}) {
  const buildState = (trigger) => {
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) ?? {};
    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window2 == null ? void 0 : window2.location) ?? {};
    return {
      trigger,
      state: state2,
      length,
      hash,
      host,
      hostname,
      href,
      origin,
      pathname,
      port,
      protocol,
      search
    };
  };
  const [state, setState] = createSignal(buildState("load"));
  if (window2) {
    useEventListener(window2, "popstate", () => setState(buildState("popstate")), { passive: true });
    useEventListener(window2, "hashchange", () => setState(buildState("hashchange")), { passive: true });
  }
  return state;
}
function useClipboard(options = {}) {
  const { navigator = defaultNavigator, read = false, source, copiedDuring = 1500, legacy = false } = options;
  const events2 = ["copy", "cut"];
  const isClipboardApiSupported = useSupported(() => navigator && "clipboard" in navigator);
  const isSupported = createMemo(() => isClipboardApiSupported() || legacy);
  const [text, setText] = createSignal("");
  const [copied, setCopied] = createSignal(false);
  const timeout = useTimeoutFn(() => setCopied(false), copiedDuring);
  function updateText() {
    if (isClipboardApiSupported()) {
      navigator.clipboard.readText().then((value) => {
        setText(value);
      });
    } else {
      setText(legacyRead());
    }
  }
  if (isSupported() && read) {
    for (const event of events2)
      useEventListener(event, updateText);
  }
  async function copy(value = unAccessor(source)) {
    if (isSupported() && value != null) {
      if (isClipboardApiSupported())
        await navigator.clipboard.writeText(value);
      else
        legacyCopy(value);
      setText(value);
      setCopied(true);
      timeout.start();
    }
  }
  function legacyCopy(value) {
    const ta = document.createElement("textarea");
    ta.value = value ?? "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacyRead() {
    var _a, _b;
    return ((_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) ?? "";
  }
  return {
    isSupported,
    text,
    copied,
    copy
  };
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
  const [cloned, setCloned] = createSignal({});
  const { manual, clone = cloneFnJSON, defer = false } = options;
  function sync() {
    setCloned(clone(unAccessor(source)));
  }
  if (!manual && isAccessor(source)) {
    createEffect(on(source, sync, { defer }));
  } else {
    sync();
  }
  return { cloned, setCloned, sync };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__solidjs-use_ssr_handlers__";
_global[globalKey] = _global[globalKey] ?? {};
const handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] ?? fallback;
}
function setSSRHandler(key, fn) {
  handlers[key] = fn;
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  const {
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const [data, setData] = toSignal(defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => defaultWindow == null ? void 0 : defaultWindow.localStorage)();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return isAccessor(defaults2) ? data : [data, setData];
  const rawInit = unAccessor(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = options.serializer ?? StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, () => write(data()), {
    eventFilter,
    defer: false
  });
  if (window2 && listenToStorageChanges) {
    useEventListener(window2, "storage", update);
    useEventListener(window2, customStorageEventName, updateFromCustomEvent);
  }
  update();
  return isAccessor(defaults2) ? data : [data, setData];
  function write(v) {
    try {
      if (v == null) {
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v);
        const oldValue = storage.getItem(key);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          if (window2) {
            window2.dispatchEvent(
              new CustomEvent(customStorageEventName, {
                detail: {
                  key,
                  oldValue,
                  newValue: serialized,
                  storageArea: storage
                }
              })
            );
          }
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit !== null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (isFunction$1(mergeDefaults))
        return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    }
    return serializer.read(rawValue);
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      setData(() => rawInit);
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      setData(read(event));
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
}
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "solidjs-use-color-scheme",
    listenToStorageChanges = true,
    storageSignal,
    emitAuto
  } = options;
  const modes = {
    auto: "",
    light: "light",
    dark: "dark",
    ...options.modes ?? {}
  };
  const preferredDark = usePreferredDark({ window: window2 });
  const preferredMode = createMemo(() => preferredDark() ? "dark" : "light");
  const [store, setStore] = storageSignal ?? (storageKey == null ? createSignal(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const [state, setState] = writableComputed({
    get() {
      return store() === "auto" && !emitAuto ? preferredMode() : store();
    },
    set(v) {
      setStore(v);
    }
  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value) => {
    const el = window2 == null ? void 0 : window2.document.querySelector(selector2);
    if (!el)
      return;
    if (attribute2 === "class") {
      const current = value.split(/\s/g);
      Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v) => {
        if (current.includes(v))
          el.classList.add(v);
        else
          el.classList.remove(v);
      });
    } else {
      el.setAttribute(attribute2, value);
    }
  });
  function defaultOnChanged(mode) {
    const resolvedMode = mode === "auto" ? preferredMode() : mode;
    updateHTMLAttrs(selector, attribute, modes[resolvedMode] ?? resolvedMode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  createEffect(on(state, onChanged));
  if (emitAuto) {
    createEffect(on(preferredMode, () => onChanged(state())));
  }
  tryOnCleanup(() => onChanged(state()));
  return [state, setState];
}
function useConfirmDialog(setRevealed) {
  const confirmHook = createEventHook();
  const cancelHook = createEventHook();
  const revealHook = createEventHook();
  let revealed;
  if (setRevealed === void 0) {
    [revealed, setRevealed] = createSignal(false);
  }
  let _resolve = noop;
  const reveal = (data) => {
    revealHook.trigger(data);
    setRevealed == null ? void 0 : setRevealed(true);
    return new Promise((resolve) => {
      _resolve = resolve;
    });
  };
  const confirm = (data) => {
    setRevealed == null ? void 0 : setRevealed(false);
    confirmHook.trigger(data);
    _resolve({ data, isCanceled: false });
  };
  const cancel = (data) => {
    setRevealed == null ? void 0 : setRevealed(false);
    cancelHook.trigger(data);
    _resolve({ data, isCanceled: true });
  };
  const res = {
    reveal,
    confirm,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
  if (revealed) {
    return {
      isRevealed: reveal,
      ...res
    };
  }
  return res;
}
function useRafFn(fn, options = {}) {
  const { immediate = true, window: window2 = defaultWindow } = options;
  const [isActive, setIsActive] = createSignal(false);
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive() || !window2)
      return;
    const delta = timestamp2 - previousFrameTimestamp;
    fn({ delta, timestamp: timestamp2 });
    previousFrameTimestamp = timestamp2;
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive() && window2) {
      setIsActive(true);
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    setIsActive(false);
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnCleanup(pause);
  return {
    isActive,
    pause,
    resume
  };
}
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
const TransitionPresets = {
  linear: identity,
  ..._TransitionPresets
};
function createEasingFunction([p0, p1, p2, p3]) {
  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
  const b = (a1, a2) => 3 * a2 - 6 * a1;
  const c = (a1) => 3 * a1;
  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
  const getTforX = (x) => {
    let aGuessT = x;
    for (let i = 0; i < 4; ++i) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}
function useCssTransition(source, options = {}) {
  const {
    delay = 0,
    disabled = false,
    duration = 1e3,
    onFinished = noop,
    onStarted = noop,
    transition = identity
  } = options;
  const currentTransition = createMemo(() => {
    const t = transition.length ? transition : unAccessor(transition);
    return isFunction(t) ? t : createEasingFunction(t);
  });
  const sourceValue = createMemo(() => {
    const s = unAccessor(source);
    return isNumber(s) ? s : s.map(unAccessor);
  });
  const sourceVector = createMemo(
    () => isNumber(sourceValue()) ? [sourceValue()] : sourceValue()
  );
  const [outputVector, setOutputVector] = createSignal(sourceVector().slice(0));
  let currentDuration;
  let diffVector;
  let endAt;
  let startAt;
  let startVector;
  const { resume, pause } = useRafFn(
    () => {
      const now = Date.now();
      const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);
      setOutputVector(
        startVector.map((val, i) => {
          return val + (diffVector[i] ?? 0) * currentTransition()(progress);
        })
      );
      if (progress >= 1) {
        pause();
        onFinished();
      }
    },
    { immediate: false }
  );
  const start = () => {
    pause();
    currentDuration = unAccessor(duration);
    diffVector = outputVector().map((n, i) => (sourceVector()[i] ?? 0) - (outputVector()[i] ?? 0));
    startVector = outputVector().slice(0);
    startAt = Date.now();
    endAt = startAt + currentDuration;
    resume();
    onStarted();
  };
  const timeout = useTimeoutFn(start, delay, { immediate: false });
  createEffect(
    on(
      sourceVector,
      () => {
        if (unAccessor(disabled))
          return;
        if (unAccessor(delay) <= 0)
          start();
        else
          timeout.start();
      },
      { defer: true }
    )
  );
  createEffect(
    on(
      resolveAccessor(disabled),
      (v) => {
        if (v) {
          setOutputVector(sourceVector().slice(0));
          pause();
        }
      },
      { defer: true }
    )
  );
  return createMemo(() => {
    const targetVector = unAccessor(disabled) ? sourceVector : outputVector;
    return isNumber(sourceValue()) ? targetVector()[0] : targetVector();
  });
}
function useCssVar(prop, target, { window: window2 = defaultWindow, initialValue = "" } = {}) {
  const variableSignal = createSignal(initialValue);
  const [variable, setVariable] = variableSignal;
  const elAccessor = createMemo(() => {
    var _a;
    return unAccessor(target) ?? ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  createEffect(
    on([elAccessor, resolveAccessor(prop)], ([el, prop2]) => {
      var _a;
      if (el && window2) {
        const value = (_a = window2.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();
        setVariable(value || initialValue);
      }
    })
  );
  createEffect(
    on(
      variable,
      (val) => {
        var _a, _b;
        if ((_a = elAccessor()) == null ? void 0 : _a.style) {
          (_b = elAccessor()) == null ? void 0 : _b.style.setProperty(unAccessor(prop), val);
        }
      },
      { defer: true }
    )
  );
  return variableSignal;
}
function useCycleList(list, options) {
  const [state, setState] = toSignal((options == null ? void 0 : options.initialValue) ?? list[0]);
  const index = createMemo(() => {
    let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state(), list) : list.indexOf(state());
    if (index2 < 0)
      index2 = (options == null ? void 0 : options.fallbackIndex) ?? 0;
    return index2;
  });
  function set2(i) {
    const length = list.length;
    const index2 = (i % length + length) % length;
    const value = list[index2];
    setState(() => value);
    return value;
  }
  function shift(delta = 1) {
    return set2(index() + delta);
  }
  function next(n = 1) {
    return shift(n);
  }
  function prev(n = 1) {
    return shift(-n);
  }
  return {
    state,
    setState,
    index,
    next,
    prev
  };
}
function useDark(options = {}) {
  const { valueDark = "dark", valueLight = "", window: window2 = defaultWindow } = options;
  const [mode, setMode] = useColorMode({
    ...options,
    onChanged: (mode2, defaultHandler) => {
      var _a;
      if (options.onChanged)
        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === "dark");
      else
        defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  });
  const preferredDark = usePreferredDark({ window: window2 });
  const isDark = writableComputed({
    get() {
      return mode() === "dark";
    },
    set(v) {
      if (v === preferredDark())
        setMode("auto");
      else
        setMode(v ? "dark" : "light");
    }
  });
  return isDark;
}
const fnBypass = (v) => v;
const fnSetSource = (setSource, value) => setSource(value);
function defaultDump(clone) {
  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;
}
function defaultParse(clone) {
  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;
}
function useManualHistoryTravel(source, options = {}) {
  const [getSourceVal, setSourceVal] = toSignal(source);
  const {
    clone = false,
    dump = defaultDump(clone),
    parse = defaultParse(clone),
    setSource = fnSetSource
  } = options;
  function _createHistoryRecord() {
    return {
      snapshot: dump(getSourceVal()),
      timestamp: timestamp()
    };
  }
  const [last, setLast] = createSignal(_createHistoryRecord());
  const [undoStack, setUndoStack] = createSignal([]);
  const [redoStack, setRedoStack] = createSignal([]);
  const _setSource = (record) => {
    setSource(setSourceVal, parse(record.snapshot));
    setLast(record);
  };
  const commit = () => {
    setUndoStack((stacks) => {
      return [last(), ...stacks];
    });
    setLast(_createHistoryRecord());
    if (options.capacity && undoStack().length > options.capacity) {
      setUndoStack(([...stacks]) => {
        stacks.splice(options.capacity, Infinity);
        return stacks;
      });
    }
    if (redoStack().length) {
      setRedoStack(([...stacks]) => {
        stacks.splice(0, redoStack().length);
        return stacks;
      });
    }
  };
  const clear = () => {
    setUndoStack([]);
    setRedoStack([]);
  };
  const undo = () => {
    const state = undoStack()[0];
    setUndoStack(([...stacks]) => {
      stacks.shift();
      return stacks;
    });
    if (state) {
      setRedoStack((stacks) => {
        return [last(), ...stacks];
      });
      _setSource(state);
    }
  };
  const redo = () => {
    const state = redoStack()[0];
    setRedoStack(([...stacks]) => {
      stacks.shift();
      return stacks;
    });
    if (state) {
      setUndoStack((stacks) => {
        return [last(), ...stacks];
      });
      _setSource(state);
    }
  };
  const reset = () => {
    _setSource(last());
  };
  const history = createMemo(() => [last(), ...undoStack()]);
  const canUndo = createMemo(() => undoStack().length > 0);
  const canRedo = createMemo(() => redoStack().length > 0);
  if (isSignal(source)) {
    return {
      source: getSourceVal,
      undoStack,
      redoStack,
      last,
      history,
      canUndo,
      canRedo,
      clear,
      commit,
      reset,
      undo,
      redo
    };
  }
  return {
    source: getSourceVal,
    undoStack,
    redoStack,
    last,
    history,
    canUndo,
    canRedo,
    clear,
    commit
  };
}
function useHistoryTravel(source, options = {}) {
  const { eventFilter } = options;
  const [sourceAccessor] = toSignal(source);
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  const { ignoreUpdates, stop } = watchIgnorable(sourceAccessor, commit, { eventFilter: composedFilter, defer: true });
  function setSource(setSource2, value) {
    ignoreUpdates(() => {
      setSource2(value);
    });
  }
  const manualHistory = useManualHistoryTravel(source, { ...options, clone: options.clone, setSource });
  const { clear, commit: manualCommit } = manualHistory;
  function commit() {
    manualCommit();
  }
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  function batch(fn) {
    let canceled = false;
    const cancel = () => canceled = true;
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  function dispose() {
    stop();
    clear();
  }
  return {
    ...manualHistory,
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  };
}
function useDebouncedHistoryTravel(source, options = {}) {
  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;
  const history = useHistoryTravel(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
function useDeviceMotion(options = {}) {
  const { window: window2 = defaultWindow, eventFilter = bypassFilter } = options;
  const [acceleration, setAcceleration] = createSignal({ x: null, y: null, z: null });
  const [rotationRate, setRotationRate] = createSignal({
    alpha: null,
    beta: null,
    gamma: null
  });
  const [interval, setInterval] = createSignal(0);
  const [accelerationIncludingGravity, setAccelerationIncludingGravity] = createSignal({
    x: null,
    y: null,
    z: null
  });
  if (window2) {
    const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {
      setAcceleration(event.acceleration);
      setRotationRate(event.rotationRate);
      setInterval(event.interval);
      setAccelerationIncludingGravity(event.accelerationIncludingGravity);
    });
    useEventListener(window2, "devicemotion", onDeviceMotion);
  }
  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval
  };
}
function useDeviceOrientation(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "DeviceOrientationEvent" in window2);
  const [isAbsolute, setIsAbsolute] = createSignal(false);
  const [alpha, setAlpha] = createSignal(null);
  const [beta, setBeta] = createSignal(null);
  const [gamma, setGamma] = createSignal(null);
  if (window2 && isSupported()) {
    useEventListener(window2, "deviceorientation", (event) => {
      setIsAbsolute(event.absolute);
      setAlpha(event.alpha);
      setBeta(event.beta);
      setGamma(event.gamma);
    });
  }
  return {
    isSupported,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}
function useDevicePixelRatio({ window: window2 = defaultWindow } = {}) {
  const [pixelRatio, setPixelRatio] = createSignal(1);
  const owner = getOwner();
  if (window2) {
    let observe = function() {
      setPixelRatio(window2.devicePixelRatio);
      cleanup();
      media = window2.matchMedia(`(resolution: ${pixelRatio()}dppx)`);
      media.addEventListener("change", observe, { once: true });
    }, cleanup = function() {
      media == null ? void 0 : media.removeEventListener("change", observe);
    };
    let media;
    observe();
    runWithOwner(owner, () => {
      tryOnCleanup(cleanup);
    });
  }
  return { pixelRatio };
}
function usePermission(permissionDesc, options = {}) {
  const { controls = false, navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => navigator && "permissions" in navigator);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const [state, setState] = createSignal();
  const onChange = () => {
    if (permissionStatus)
      setState(permissionStatus.state);
  };
  const owner = getOwner();
  const query = createSingletonPromise(async () => {
    if (!isSupported())
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator.permissions.query(desc);
        runWithOwner(owner, () => {
          useEventListener(permissionStatus, "change", onChange);
        });
        onChange();
      } catch {
        setState("prompt");
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  }
  return state;
}
function useDevicesList(options = {}) {
  const {
    navigator = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated
  } = options;
  const [devices, setDevices] = createSignal([]);
  const [permissionGranted, setPermissionGranted] = createSignal(false);
  const videoInputs = createMemo(() => devices().filter((i) => i.kind === "videoinput"));
  const audioInputs = createMemo(() => devices().filter((i) => i.kind === "audioinput"));
  const audioOutputs = createMemo(() => devices().filter((i) => i.kind === "audiooutput"));
  const isSupported = useSupported(() => {
    var _a;
    return (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.enumerateDevices;
  });
  async function update() {
    if (!isSupported())
      return;
    const devicesValue = await navigator.mediaDevices.enumerateDevices();
    setDevices(devicesValue);
    onUpdated == null ? void 0 : onUpdated(devicesValue);
  }
  async function ensurePermissions() {
    if (!isSupported())
      return false;
    if (permissionGranted())
      return true;
    const { state, query } = usePermission("camera", { controls: true });
    await query();
    if (state() !== "granted") {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      stream.getTracks().forEach((t) => t.stop());
      update();
      setPermissionGranted(true);
    } else {
      setPermissionGranted(true);
    }
    return permissionGranted();
  }
  if (isSupported()) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator.mediaDevices, "devicechange", update);
    update();
  }
  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}
function useDisplayMedia(options = {}) {
  const [enabled, setEnabled] = toSignal(options.enabled ?? false);
  const video = options.video;
  const audio = options.audio;
  const { navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a;
    return (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.getDisplayMedia;
  });
  const constraint = { audio, video };
  const [stream, setStream] = createSignal();
  async function _start() {
    if (!isSupported() || stream())
      return;
    const streamVal = await navigator.mediaDevices.getDisplayMedia(constraint);
    setStream(streamVal);
    return streamVal;
  }
  async function _stop() {
    var _a;
    (_a = stream()) == null ? void 0 : _a.getTracks().forEach((t) => t.stop());
    setStream(void 0);
  }
  function stop() {
    _stop();
    setEnabled(false);
  }
  async function start() {
    await _start();
    if (stream())
      setEnabled(true);
    return stream();
  }
  createEffect(
    on(enabled, (v) => {
      if (v)
        _start();
      else
        _stop();
    })
  );
  return {
    isSupported,
    stream,
    start,
    stop,
    enabled,
    setEnabled
  };
}
function useDocumentVisibility({
  document: document2 = defaultDocument
} = {}) {
  if (!document2) {
    const [visibility2] = createSignal("visible");
    return visibility2;
  }
  const [visibility, setVisibility] = createSignal(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    setVisibility(document2.visibilityState);
  });
  return visibility;
}
function useDraggable(target, options = {}) {
  const draggingElement = options.draggingElement ?? defaultWindow;
  const draggingHandle = options.handle ?? target;
  const position = createMutable({ value: unAccessor(options.initialValue) ?? { x: 0, y: 0 } });
  const pressedDelta = createMutable({ value: void 0 });
  const filterEvent = (e) => {
    if (options.pointerTypes)
      return options.pointerTypes.includes(e.pointerType);
    return true;
  };
  const handleEvent = (e) => {
    if (unAccessor(options.preventDefault))
      e.preventDefault();
    if (unAccessor(options.stopPropagation))
      e.stopPropagation();
  };
  const start = (e) => {
    var _a;
    if (!filterEvent(e))
      return;
    if (unAccessor(options.exact) && e.target !== unAccessor(target))
      return;
    const rect = unAccessor(target).getBoundingClientRect();
    const pos = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
    if (((_a = options.onStart) == null ? void 0 : _a.call(options, pos, e)) === false)
      return;
    pressedDelta.value = pos;
    handleEvent(e);
  };
  const move = (e) => {
    var _a;
    if (!filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    position.value = {
      x: e.clientX - pressedDelta.value.x,
      y: e.clientY - pressedDelta.value.y
    };
    (_a = options.onMove) == null ? void 0 : _a.call(options, position.value, e);
    handleEvent(e);
  };
  const end = (e) => {
    var _a;
    if (!filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    pressedDelta.value = void 0;
    (_a = options.onEnd) == null ? void 0 : _a.call(options, position.value, e);
    handleEvent(e);
  };
  if (isClient) {
    useEventListener(draggingHandle, "pointerdown", start, true);
    useEventListener(draggingElement, "pointermove", move, true);
    useEventListener(draggingElement, "pointerup", end, true);
  }
  return {
    x: () => position.value.x,
    y: () => position.value.x,
    position,
    isDragging: createMemo(() => !!pressedDelta.value),
    style: createMemo(() => ({ left: `${position.value.x}px`, top: `${position.value.y}px` }))
  };
}
function useDropZone(target, onDrop) {
  const [isOverDropZone, setOverDropZone] = createSignal(false);
  let counter = 0;
  if (isClient) {
    useEventListener(target, "dragenter", (event) => {
      event.preventDefault();
      counter += 1;
      setOverDropZone(true);
    });
    useEventListener(target, "dragover", (event) => {
      event.preventDefault();
    });
    useEventListener(target, "dragleave", (event) => {
      event.preventDefault();
      counter -= 1;
      if (counter === 0)
        setOverDropZone(false);
    });
    useEventListener(target, "drop", (event) => {
      var _a;
      event.preventDefault();
      counter = 0;
      setOverDropZone(false);
      const files = Array.from(((_a = event.dataTransfer) == null ? void 0 : _a.files) ?? []);
      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);
    });
  }
  return {
    isOverDropZone
  };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(resolveAccessor(target), (el) => {
    cleanup();
    if (isSupported() && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnCleanup(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const { reset = true, windowResize = true, windowScroll = true, immediate = true } = options;
  const [height, setHeight] = createSignal(0);
  const [bottom, setBottom] = createSignal(0);
  const [left, setLeft] = createSignal(0);
  const [right, setRight] = createSignal(0);
  const [top, setTop] = createSignal(0);
  const [width, setWidth] = createSignal(0);
  const [x, setX] = createSignal(0);
  const [y, setY] = createSignal(0);
  function update() {
    const el = unAccessor(target);
    if (!el) {
      if (reset) {
        setHeight(0);
        setBottom(0);
        setLeft(0);
        setRight(0);
        setTop(0);
        setWidth(0);
        setX(0);
        setY(0);
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    setHeight(rect.height);
    setBottom(rect.bottom);
    setLeft(rect.left);
    setRight(rect.right);
    setTop(rect.top);
    setWidth(rect.width);
    setX(rect.x);
    setY(rect.y);
  }
  useResizeObserver(target, update);
  createEffect(
    on(
      resolveAccessor(target),
      (ele) => {
        !ele && update();
      },
      { defer: true }
    )
  );
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMount(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementByPoint(options) {
  const [element, setElement] = createSignal(null);
  const { x, y, document: document2 = defaultDocument } = options;
  const controls = useRafFn(() => {
    setElement(() => (document2 == null ? void 0 : document2.elementFromPoint(unAccessor(x), unAccessor(y))) ?? null);
  });
  return {
    element,
    ...controls
  };
}
function useElementHover(el, options = {}) {
  const delayEnter = options ? options.delayEnter : 0;
  const delayLeave = options ? options.delayLeave : 0;
  const [isHovered, setIsHovered] = createSignal(false);
  let timer;
  const toggle = (entering) => {
    const delay = entering ? delayEnter : delayLeave;
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
    if (delay)
      timer = setTimeout(() => setIsHovered(entering), delay);
    else
      setIsHovered(entering);
  };
  if (!window)
    return isHovered;
  useEventListener(el, "mouseenter", () => toggle(true), { passive: true });
  useEventListener(el, "mouseleave", () => toggle(false), { passive: true });
  return isHovered;
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = createMemo(() => {
    var _a, _b;
    return (_b = (_a = unAccessor(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const [width, setWidth] = createSignal(initialSize.width);
  const [height, setHeight] = createSignal(initialSize.height);
  useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG()) {
        const $elem = unAccessor(target);
        if ($elem) {
          const styles = window2.getComputedStyle($elem);
          setWidth(parseFloat(styles.width));
          setHeight(parseFloat(styles.height));
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          setWidth(formatBoxSize.reduce((acc, { inlineSize }) => acc + Number(inlineSize), 0));
          setHeight(formatBoxSize.reduce((acc, { blockSize }) => acc + Number(blockSize), 0));
        } else {
          setWidth(entry.contentRect.width);
          setHeight(entry.contentRect.height);
        }
      }
    },
    options
  );
  createEffect(
    on(
      resolveAccessor(target),
      (ele) => {
        setWidth(ele ? initialSize.width : 0);
        setHeight(ele ? initialSize.height : 0);
      },
      { defer: true }
    )
  );
  return {
    width,
    height
  };
}
function useElementVisibility(element, { window: window2 = defaultWindow, scrollTarget } = {}) {
  const [elementIsVisible, setElementIsVisible] = createSignal(false);
  const testBounding = () => {
    if (!window2)
      return;
    const document2 = window2.document;
    const el = unAccessor(element);
    if (!el) {
      setElementIsVisible(false);
    } else {
      const rect = el.getBoundingClientRect();
      setElementIsVisible(
        rect.top <= (window2.innerHeight || document2.documentElement.clientHeight) && rect.left <= (window2.innerWidth || document2.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0
      );
    }
  };
  createEffect(
    on(resolveAccessor(element), () => {
      testBounding();
    })
  );
  if (window2) {
    useEventListener(scrollTarget ?? window2, "scroll", testBounding, {
      capture: false,
      passive: true
    });
  }
  return elementIsVisible;
}
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
  const owner = getOwner();
  function on2(listener) {
    const listeners = events.get(key) ?? [];
    listeners.push(listener);
    events.set(key, listeners);
    const _off = () => off(listener);
    runWithOwner(owner, () => {
      onCleanup(_off);
    });
    return _off;
  }
  function once(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    return on2(_listener);
  }
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners)
      return;
    const index = listeners.indexOf(listener);
    if (index > -1)
      listeners.splice(index, 1);
    if (!listeners.length)
      events.delete(key);
  }
  function reset() {
    events.delete(key);
  }
  function emit(event, payload) {
    var _a;
    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));
  }
  return { on: on2, once, off, emit, reset };
}
function useEventSource(url, events2 = [], options = {}) {
  const [event, setEvent] = createSignal(null);
  const [data, setData] = createSignal(null);
  const [status, setState] = createSignal("CONNECTING");
  const [eventSource, setEventSource] = createSignal(null);
  const [error, setError] = createSignal(null);
  const { withCredentials = false } = options;
  const close = () => {
    const eventSourceValue = eventSource();
    if (eventSourceValue) {
      eventSourceValue.close();
      setEventSource(null);
      setState("CLOSED");
    }
  };
  const es = new EventSource(url, { withCredentials });
  setEventSource(es);
  es.onopen = () => {
    setState("OPEN");
    setError(null);
  };
  es.onerror = (e) => {
    setState("CLOSED");
    setError(e);
  };
  es.onmessage = (e) => {
    setEvent(null);
    setData(e.data);
  };
  for (const eventName of events2) {
    useEventListener(es, eventName, (e) => {
      setEvent(eventName);
      setData(e.data ?? null);
    });
  }
  tryOnCleanup(() => {
    close();
  });
  return {
    eventSource,
    event,
    data,
    status,
    error,
    close
  };
}
function useEyeDropper(options = {}) {
  const { initialValue = "" } = options;
  const isSupported = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
  const [sRGBHex, setSRGBHex] = createSignal(initialValue);
  async function open(openOptions) {
    if (!isSupported())
      return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    setSRGBHex(result.sRGBHex);
    return result;
  }
  return { isSupported, sRGBHex, open };
}
function useFavicon(newIcon = null, options = {}) {
  const { baseUrl = "", rel = "icon", document: document2 = defaultDocument } = options;
  const [favicon, setFavicon] = toSignal(newIcon);
  const applyIcon = (icon) => {
    document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`).forEach((el) => el.href = `${baseUrl}${icon}`);
  };
  createEffect(
    on(favicon, (i, o) => {
      if (isString(i) && i !== o)
        applyIcon(i);
    })
  );
  if (isAccessor(newIcon)) {
    return favicon;
  }
  return [favicon, setFavicon];
}
const payloadMapping = {
  json: "application/json",
  text: "text/plain",
  formData: "multipart/form-data"
};
function isFetchOptions(obj) {
  return obj && containsProp(
    obj,
    "immediate",
    "refetch",
    "initialData",
    "timeout",
    "beforeFetch",
    "afterFetch",
    "onFetchError",
    "fetch"
  );
}
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers)
    return Object.fromEntries([...headers.entries()]);
  return headers;
}
function combineCallbacks(combination, ...callbacks) {
  if (combination === "overwrite") {
    return async (ctx) => {
      const callback = callbacks[callbacks.length - 1];
      if (callback !== void 0)
        await callback(ctx);
      return ctx;
    };
  }
  return async (ctx) => {
    await callbacks.reduce(
      (prevCallback, callback) => prevCallback.then(async () => {
        if (callback)
          ctx = { ...ctx, ...await callback(ctx) };
      }),
      Promise.resolve()
    );
    return ctx;
  };
}
function createFetch(config = {}) {
  const _combination = config.combination ?? "chain";
  const _options = config.options ?? {};
  const _fetchOptions = config.fetchOptions ?? {};
  function useFactoryFetch(url, ...args) {
    const computedUrl = createMemo(() => {
      const baseUrl = unAccessor(config.baseUrl);
      const targetUrl = unAccessor(url);
      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
    });
    let options = _options;
    let fetchOptions = _fetchOptions;
    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options = {
          ...options,
          ...args[0],
          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
        };
      } else {
        fetchOptions = {
          ...fetchOptions,
          ...args[0],
          headers: {
            ...headersToObject(fetchOptions.headers) ?? {},
            ...headersToObject(args[0].headers) ?? {}
          }
        };
      }
    }
    if (args.length > 1 && isFetchOptions(args[1])) {
      options = {
        ...options,
        ...args[1],
        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
      };
    }
    return useFetch(computedUrl, fetchOptions, options);
  }
  return useFactoryFetch;
}
function useFetch(url, ...args) {
  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options = { immediate: true, refetch: false, timeout: 0 };
  const config = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  if (args.length > 0) {
    if (isFetchOptions(args[0]))
      options = { ...options, ...args[0] };
    else
      fetchOptions = args[0];
  }
  if (args.length > 1) {
    if (isFetchOptions(args[1]))
      options = { ...options, ...args[1] };
  }
  const { fetch = defaultWindow == null ? void 0 : defaultWindow.fetch, initialData, timeout } = options;
  const responseEvent = createEventHook();
  const errorEvent = createEventHook();
  const finallyEvent = createEventHook();
  const [isFinished, setIsFinished] = createSignal(false);
  const [isFetching, setIsFetching] = createSignal(false);
  const [aborted, setAborted] = createSignal(false);
  const [statusCode, setStatusCode] = createSignal(null);
  const [response, setResponse] = createSignal(null);
  const [error, setError] = createSignal(null);
  const [data, setData] = createSignal(initialData);
  const canAbort = createMemo(() => supportsAbort && isFetching());
  let controller;
  let timer;
  const abort = () => {
    if (supportsAbort && controller) {
      controller.abort();
      controller = void 0;
    }
  };
  const loading = (isLoading) => {
    setIsFetching(isLoading);
    setIsFinished(!isLoading);
  };
  if (timeout)
    timer = useTimeoutFn(abort, timeout, { immediate: false });
  const execute = async (throwOnFailed = false) => {
    loading(true);
    setError(null);
    setStatusCode(null);
    setAborted(false);
    controller = void 0;
    if (supportsAbort) {
      controller = new AbortController();
      controller.signal.onabort = () => setAborted(true);
      fetchOptions = {
        ...fetchOptions,
        signal: controller.signal
      };
    }
    const defaultFetchOptions = {
      method: config.method,
      headers: {}
    };
    if (config.payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      if (config.payloadType)
        headers["Content-Type"] = payloadMapping[config.payloadType] ?? config.payloadType;
      const payload = unAccessor(config.payload);
      defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
    }
    let isCanceled = false;
    const context = {
      url: unAccessor(url),
      options: { ...defaultFetchOptions, ...fetchOptions },
      cancel: () => {
        isCanceled = true;
      }
    };
    if (options.beforeFetch)
      Object.assign(context, await options.beforeFetch(context));
    if (isCanceled || !fetch) {
      loading(false);
      return Promise.resolve(null);
    }
    let responseData = null;
    if (timer)
      timer.start();
    return new Promise((resolve, reject) => {
      var _a;
      fetch(context.url, {
        ...defaultFetchOptions,
        ...context.options,
        headers: {
          ...headersToObject(defaultFetchOptions.headers),
          ...headersToObject((_a = context.options) == null ? void 0 : _a.headers)
        }
      }).then(async (fetchResponse) => {
        setResponse(fetchResponse);
        const statusCodeVal = fetchResponse.status;
        setStatusCode(statusCodeVal);
        responseData = await fetchResponse[config.type]();
        if (options.afterFetch && statusCodeVal >= 200 && statusCodeVal < 300)
          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));
        setData(responseData);
        if (!fetchResponse.ok)
          throw new Error(fetchResponse.statusText);
        responseEvent.trigger(fetchResponse);
        return resolve(fetchResponse);
      }).catch(async (fetchError) => {
        let errorData = fetchError.message || fetchError.name;
        if (options.onFetchError)
          ({ data: responseData, error: errorData } = await options.onFetchError({
            data: responseData,
            error: fetchError,
            response: response()
          }));
        setData(responseData);
        setError(errorData);
        errorEvent.trigger(fetchError);
        if (throwOnFailed)
          return reject(fetchError);
        return resolve(null);
      }).finally(() => {
        loading(false);
        if (timer)
          timer.stop();
        finallyEvent.trigger(null);
      });
    });
  };
  const refetch = resolveAccessor(options.refetch);
  createEffect(
    on(
      [refetch, resolveAccessor(url)],
      ([refetch2]) => {
        refetch2 && execute();
      },
      { defer: true }
    )
  );
  const shell = {
    isFinished,
    statusCode,
    response,
    error,
    data,
    isFetching,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    // method
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    // type
    json: setType("json"),
    text: setType("text"),
    blob: setType("blob"),
    arrayBuffer: setType("arrayBuffer"),
    formData: setType("formData")
  };
  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching()) {
        config.method = method;
        config.payload = payload;
        config.payloadType = payloadType;
        if (isAccessor(config.payload)) {
          createEffect(
            on(
              [refetch, resolveAccessor(config.payload)],
              ([refetch2]) => {
                refetch2 && execute();
              },
              { defer: true }
            )
          );
        }
        const rawPayload = unAccessor(config.payload);
        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))
          config.payloadType = "json";
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  function waitUntilFinished() {
    return new Promise((resolve, reject) => {
      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));
    });
  }
  function setType(type) {
    return () => {
      if (!isFetching()) {
        config.type = type;
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  if (options.immediate)
    setTimeout(execute, 0);
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
function joinPaths(start, end) {
  if (!start.endsWith("/") && !end.startsWith("/"))
    return `${start}/${end}`;
  return `${start}${end}`;
}
const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*"
};
function useFileDialog(options = {}) {
  const { document: document2 = defaultDocument } = options;
  const [files, setFiles] = createSignal(null);
  let input;
  if (document2) {
    input = document2.createElement("input");
    input.type = "file";
    input.onchange = (event) => {
      const result = event.target;
      setFiles(result.files);
    };
  }
  const open = (localOptions) => {
    if (!input)
      return;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options,
      ...localOptions
    };
    input.multiple = _options.multiple;
    input.accept = _options.accept;
    if (hasOwn(_options, "capture"))
      input.capture = _options.capture;
    input.click();
  };
  const reset = () => {
    setFiles(null);
    if (input)
      input.value = "";
  };
  return {
    files,
    open,
    reset
  };
}
function useFileSystemAccess(options = {}) {
  const { window: _window = defaultWindow, dataType = "Text" } = options;
  const window2 = _window;
  const isSupported = useSupported(() => window2 && "showSaveFilePicker" in window2 && "showOpenFilePicker" in window2);
  const [fileHandle, setFileHandle] = createSignal();
  const [data, setData] = createSignal();
  const [file, setFile] = createSignal();
  const fileName = createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.name) ?? "";
  });
  const fileMIME = createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.type) ?? "";
  });
  const fileSize = createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.size) ?? 0;
  });
  const fileLastModified = createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.lastModified) ?? 0;
  });
  async function open(_options = {}) {
    if (!isSupported())
      return;
    const [handle] = await window2.showOpenFilePicker({ ...unAccessor(options), ..._options });
    setFileHandle(handle);
    await updateFile();
    await updateData();
  }
  async function create(_options = {}) {
    if (!isSupported())
      return;
    const fileHandleValue = await window2.showSaveFilePicker({
      ...unAccessor(options),
      ..._options
    });
    setFileHandle(fileHandleValue);
    setData(void 0);
    await updateFile();
    await updateData();
  }
  async function save(_options = {}) {
    if (!isSupported())
      return;
    const fileHandleValue = fileHandle();
    if (!fileHandleValue)
      return saveAs(_options);
    if (data()) {
      const writableStream = await fileHandleValue.createWritable();
      await writableStream.write(data());
      await writableStream.close();
    }
    await updateFile();
  }
  async function saveAs(_options = {}) {
    if (!isSupported())
      return;
    const fileHandleValue = await window2.showSaveFilePicker({
      ...unAccessor(options),
      ..._options
    });
    setFileHandle(fileHandleValue);
    if (data()) {
      const writableStream = await fileHandleValue.createWritable();
      await writableStream.write(data());
      await writableStream.close();
    }
    await updateFile();
  }
  async function updateFile() {
    var _a;
    const f = await ((_a = fileHandle()) == null ? void 0 : _a.getFile());
    setFile(() => f);
  }
  async function updateData() {
    var _a, _b;
    if (unAccessor(dataType) === "Text")
      setData(await ((_a = file()) == null ? void 0 : _a.text()));
    if (unAccessor(dataType) === "ArrayBuffer")
      setData(await ((_b = file()) == null ? void 0 : _b.arrayBuffer()));
    if (unAccessor(dataType) === "Blob") {
      setData(() => file());
    }
  }
  createEffect(on(resolveAccessor(dataType), updateData, { defer: true }));
  return {
    isSupported,
    data,
    setData,
    file,
    setFile,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open,
    create,
    save,
    saveAs,
    updateData
  };
}
function useFocus(target, options = {}) {
  const { initialValue = false } = options;
  const [innerFocused, setInnerFocused] = createSignal(false);
  const targetElement = resolveAccessor(target);
  useEventListener(targetElement, "focus", () => setInnerFocused(true));
  useEventListener(targetElement, "blur", () => setInnerFocused(false));
  const [focused, setFocused] = writableComputed({
    get() {
      return innerFocused();
    },
    set(value) {
      var _a, _b;
      if (!value && innerFocused())
        (_a = targetElement()) == null ? void 0 : _a.blur();
      if (value && !innerFocused())
        (_b = targetElement()) == null ? void 0 : _b.focus();
    }
  });
  createEffect(
    on(targetElement, () => {
      setFocused(initialValue);
    })
  );
  return [focused, setFocused];
}
function useFocusWithin(target, options = {}) {
  const activeElement = useActiveElement(options);
  const targetElement = createMemo(() => unAccessor(target));
  const focused = createMemo(
    () => targetElement() && activeElement() ? targetElement().contains(activeElement()) : false
  );
  return focused;
}
function useFps(options) {
  const [fps, setFps] = createSignal(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (options == null ? void 0 : options.every) ?? 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      setFps(Math.round(1e3 / (diff / ticks)));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
const functionsMap = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
function useFullscreen(target, options = {}) {
  const { document: document2 = defaultDocument, autoExit = false } = options;
  const targetRef = target ?? (document2 == null ? void 0 : document2.querySelector("html"));
  const [isFullscreen, setIsFullscreen] = createSignal(false);
  let map = functionsMap[0];
  const isSupported = useSupported(() => {
    if (!document2) {
      return false;
    }
    for (const m of functionsMap) {
      if (m[1] in document2) {
        map = m;
        return true;
      }
    }
    return false;
  });
  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;
  async function exit() {
    if (!isSupported())
      return;
    if (document2 == null ? void 0 : document2[ELEMENT])
      await document2[EXIT]();
    setIsFullscreen(false);
  }
  async function enter() {
    if (!isSupported())
      return;
    await exit();
    const target2 = unAccessor(targetRef);
    if (target2) {
      await target2[REQUEST]();
      setIsFullscreen(true);
    }
  }
  async function toggle() {
    if (isFullscreen())
      await exit();
    else
      await enter();
  }
  if (document2) {
    useEventListener(
      document2,
      EVENT,
      () => {
        setIsFullscreen(!!(document2 == null ? void 0 : document2[ELEMENT]));
      },
      false
    );
  }
  if (autoExit)
    tryOnCleanup(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}
function mapGamepadToXbox360Controller(gamepad) {
  return createMemo(() => {
    const gamepadVal = gamepad();
    if (gamepadVal) {
      return {
        buttons: {
          a: gamepadVal.buttons[0],
          b: gamepadVal.buttons[1],
          x: gamepadVal.buttons[2],
          y: gamepadVal.buttons[3]
        },
        bumper: {
          left: gamepadVal.buttons[4],
          right: gamepadVal.buttons[5]
        },
        triggers: {
          left: gamepadVal.buttons[6],
          right: gamepadVal.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepadVal.axes[0],
            vertical: gamepadVal.axes[1],
            button: gamepadVal.buttons[10]
          },
          right: {
            horizontal: gamepadVal.axes[2],
            vertical: gamepadVal.axes[3],
            button: gamepadVal.buttons[11]
          }
        },
        dpad: {
          up: gamepadVal.buttons[12],
          down: gamepadVal.buttons[13],
          left: gamepadVal.buttons[14],
          right: gamepadVal.buttons[15]
        },
        back: gamepadVal.buttons[8],
        start: gamepadVal.buttons[9]
      };
    }
    return null;
  });
}
function useGamepad(options = {}) {
  const { navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => navigator && "getGamepads" in navigator);
  const [gamepads, setGamepads] = createSignal([]);
  const onConnectedHook = createEventHook();
  const onDisconnectedHook = createEventHook();
  const stateFromGamepad = (gamepad) => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator)
      hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators)
      hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      hapticActuators,
      index: gamepad.index,
      mapping: gamepad.mapping,
      connected: gamepad.connected,
      timestamp: gamepad.timestamp,
      axes: gamepad.axes.map((axes) => axes),
      buttons: gamepad.buttons.map((button) => ({
        pressed: button.pressed,
        touched: button.touched,
        value: button.value
      }))
    };
  };
  const updateGamepadState = () => {
    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) ?? [];
    for (let i = 0; i < _gamepads.length; ++i) {
      const gamepad = _gamepads[i];
      if (gamepad) {
        const index = gamepads().findIndex(({ index: index2 }) => index2 === gamepad.index);
        if (index > -1)
          gamepads()[index] = stateFromGamepad(gamepad);
      }
    }
  };
  const { isActive, pause, resume } = useRafFn(updateGamepadState);
  const onGamepadConnected = (gamepad) => {
    if (!gamepads().some(({ index }) => index === gamepad.index)) {
      setGamepads((gamepads2) => [...gamepads2, stateFromGamepad(gamepad)]);
      onConnectedHook.trigger(gamepad.index);
    }
    resume();
  };
  const onGamepadDisconnected = (gamepad) => {
    setGamepads(gamepads().filter((x) => x.index !== gamepad.index));
    onDisconnectedHook.trigger(gamepad.index);
  };
  useEventListener("gamepadconnected", (e) => onGamepadConnected(e.gamepad));
  useEventListener("gamepaddisconnected", (e) => onGamepadDisconnected(e.gamepad));
  tryOnMount(() => {
    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) ?? [];
    if (_gamepads) {
      for (let i = 0; i < _gamepads.length; ++i) {
        const gamepad = _gamepads[i];
        if (gamepad)
          onGamepadConnected(gamepad);
      }
    }
  });
  pause();
  return {
    isSupported,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}
function useGeolocation(options = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator = defaultNavigator,
    immediate = true
  } = options;
  const isSupported = useSupported(() => navigator && "geolocation" in navigator);
  const [locatedAt, setLocatedAt] = createSignal(null);
  const [error, setError] = createSignal(null);
  const [coords, setCoords] = createSignal({
    accuracy: 0,
    latitude: Infinity,
    longitude: Infinity,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function updatePosition(position) {
    setLocatedAt(position.timestamp);
    setCoords(position.coords);
    setError(null);
  }
  let watcher;
  function resume() {
    if (isSupported()) {
      watcher = navigator.geolocation.watchPosition(updatePosition, (err) => setError(err), {
        enableHighAccuracy,
        maximumAge,
        timeout
      });
    }
  }
  if (immediate)
    resume();
  function pause() {
    if (watcher && navigator)
      navigator.geolocation.clearWatch(watcher);
  }
  tryOnCleanup(() => {
    pause();
  });
  return {
    isSupported,
    coords,
    locatedAt,
    error,
    resume,
    pause
  };
}
const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events: events2 = defaultEvents$1,
    window: window2 = defaultWindow,
    eventFilter = throttleFilter(50)
  } = options;
  const [idle, setIdle] = createSignal(initialState);
  const [lastActive, setLastActive] = createSignal(timestamp());
  let timer;
  const onEvent = createFilterWrapper(eventFilter, () => {
    setIdle(false);
    setLastActive(timestamp());
    clearTimeout(timer);
    timer = setTimeout(() => setIdle(true), timeout);
  });
  if (window2) {
    const document2 = window2.document;
    for (const event of events2)
      useEventListener(window2, event, onEvent, { passive: true });
    if (listenForVisibilityChange) {
      useEventListener(document2, "visibilitychange", () => {
        if (!document2.hidden)
          onEvent();
      });
    }
  }
  timer = setTimeout(() => setIdle(true), timeout);
  return { idle, lastActive };
}
async function loadImage(options) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const { src, srcset, sizes } = options;
    img.src = src;
    if (srcset)
      img.srcset = srcset;
    if (sizes)
      img.sizes = sizes;
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}
const useImage = (options, asyncStateOptions = {}) => {
  const state = useAsyncState(() => loadImage(unAccessor(options)), void 0, {
    resetOnExecute: true,
    ...asyncStateOptions
  });
  createEffect(
    on(
      () => unAccessor(options),
      () => {
        state.execute(asyncStateOptions.delay);
      },
      { defer: true }
    )
  );
  return state;
};
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options = {}) {
  const {
    throttle = 0,
    idle = 200,
    onStop = noop,
    onScroll = noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto"
  } = options;
  const [internalX, setInternalX] = createSignal(0);
  const [internalY, setInternalY] = createSignal(0);
  const [x, setX] = writableComputed({
    get() {
      return internalX();
    },
    set(x2) {
      scrollTo(x2, void 0);
    }
  });
  const [y, setY] = writableComputed({
    get() {
      return internalY();
    },
    set(y2) {
      scrollTo(void 0, y2);
    }
  });
  function scrollTo(_x, _y) {
    var _a;
    const _element = unAccessor(element);
    if (!_element)
      return;
    (_a = _element instanceof Document ? document.body : _element) == null ? void 0 : _a.scrollTo({
      top: unAccessor(_y) ?? y(),
      left: unAccessor(_x) ?? x(),
      behavior: unAccessor(behavior)
    });
  }
  const [isScrolling, setIsScrolling] = createSignal(false);
  const arrivedState = createMutable({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = createMutable({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = (e) => {
    if (!isScrolling())
      return;
    setIsScrolling(false);
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e);
  };
  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);
  const onScrollHandler = (e) => {
    const eventTarget = e.target === document ? e.target.documentElement : e.target;
    const scrollLeft = eventTarget.scrollLeft;
    directions.left = scrollLeft < internalX();
    directions.right = scrollLeft > internalY();
    arrivedState.left = scrollLeft <= 0 + (offset.left ?? 0);
    arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    setInternalX(scrollLeft);
    let scrollTop = eventTarget.scrollTop;
    if (e.target === document && !scrollTop)
      scrollTop = document.body.scrollTop;
    directions.top = scrollTop < internalY();
    directions.bottom = scrollTop > internalY();
    arrivedState.top = scrollTop <= 0 + (offset.top ?? 0);
    arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    setInternalY(scrollTop);
    setIsScrolling(true);
    onScrollEndDebounced(e);
    onScroll(e);
  };
  useEventListener(
    element,
    "scroll",
    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,
    eventListenerOptions
  );
  useEventListener(element, "scrollend", onScrollEnd, eventListenerOptions);
  return {
    x,
    setX,
    y,
    setY,
    isScrolling,
    arrivedState,
    directions
  };
}
function useInfiniteScroll(element, onLoadMore, options = {}) {
  const direction = options.direction ?? "bottom";
  const state = useScroll(element, {
    ...options,
    offset: {
      [direction]: options.distance ?? 0,
      ...options.offset
    }
  });
  createEffect(
    on(
      () => state.arrivedState[direction],
      async (v) => {
        if (v) {
          const elem = unAccessor(element);
          const previous = {
            height: (elem == null ? void 0 : elem.scrollHeight) ?? 0,
            width: (elem == null ? void 0 : elem.scrollWidth) ?? 0
          };
          await onLoadMore(state);
          if (options.preserveScrollPosition && elem) {
            nextTick(() => {
              elem.scrollTo({
                top: elem.scrollHeight - previous.height,
                left: elem.scrollWidth - previous.width
              });
            });
          }
        }
      }
    )
  );
}
function useIntersectionObserver(target, callback, options = {}) {
  const { root, rootMargin = "0", threshold = 0.1, window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
  let cleanup = noop;
  const stopWatch = isSupported() ? watch(
    () => ({
      el: unAccessor(target),
      root: unAccessor(root)
    }),
    ({ el, root: root2 }) => {
      cleanup();
      if (!el)
        return;
      const observer = new IntersectionObserver(callback, {
        root: root2,
        rootMargin,
        threshold
      });
      observer.observe(el);
      cleanup = () => {
        observer.disconnect();
        cleanup = noop;
      };
    }
  ) : noop;
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnCleanup(stop);
  return {
    isSupported,
    stop
  };
}
const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
function useKeyModifier(modifier, options = {}) {
  const { events: events2 = defaultEvents, document: document2 = defaultDocument, initial = null } = options;
  const [state, setState] = createSignal(initial);
  if (document2) {
    events2.forEach((listenerEvent) => {
      useEventListener(document2, listenerEvent, (evt) => {
        if (typeof evt.getModifierState === "function")
          setState(evt.getModifierState(modifier));
      });
    });
  }
  return state;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
const getSetCompat = () => {
  const data = createMutable([]);
  return {
    value() {
      return data;
    },
    add: (val) => {
      if (!data.includes(val)) {
        data.push(val);
      }
      return void 0;
    },
    has: (val) => data.includes(val),
    delete: (val) => {
      const index = data.findIndex((item) => item === val);
      if (index > -1) {
        data.splice(index, 1);
      }
      return true;
    },
    clear: () => {
      data.length = 0;
    }
  };
};
function useMagicKeys(options = {}) {
  const { target = defaultWindow, aliasMap = DefaultMagicKeysAliasMap, passive = true, onEventFired = noop } = options;
  const current = getSetCompat();
  const obj = {
    toJSON() {
      return {};
    },
    current
  };
  const refs = obj;
  const metaDeps = /* @__PURE__ */ new Set();
  const usedKeys = /* @__PURE__ */ new Set();
  function setRefs(key, value) {
    if (key in refs) {
      refs[key][1](value);
    }
  }
  function reset() {
    current.clear();
    for (const key of usedKeys)
      setRefs(key, false);
  }
  function updateRefs(e, value) {
    var _a, _b;
    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values = [code, key].filter(Boolean);
    if (key) {
      if (value)
        current.add(key);
      else
        current.delete(key);
    }
    for (const key2 of values) {
      usedKeys.add(key2);
      setRefs(key2, value);
    }
    if (key === "meta" && !value) {
      metaDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value) {
      [...current.value(), ...values].forEach((key2) => metaDeps.add(key2));
    }
  }
  useEventListener(
    target,
    "keydown",
    (e) => {
      updateRefs(e, true);
      return onEventFired(e);
    },
    { passive }
  );
  useEventListener(
    target,
    "keyup",
    (e) => {
      updateRefs(e, false);
      return onEventFired(e);
    },
    { passive }
  );
  useEventListener("blur", reset, { passive: true });
  useEventListener("focus", reset, { passive: true });
  const proxy = new Proxy(refs, {
    get(target2, prop, rec) {
      if (typeof prop !== "string")
        return Reflect.get(target2, prop, rec);
      prop = prop.toLowerCase();
      if (prop in aliasMap)
        prop = aliasMap[prop];
      if (!(prop in refs)) {
        if (/[+_-]/.test(prop)) {
          const keys2 = prop.split(/[+_-]/g).map((i) => i.trim());
          refs[prop] = createMemo(() => keys2.every((key) => unAccessor(proxy[key])));
        } else {
          refs[prop] = createSignal(false);
        }
      }
      const r = Reflect.get(target2, prop, rec);
      return isSignal(r) ? r[0] : r;
    }
  });
  return proxy;
}
function usingElRef(source, cb) {
  if (unAccessor(source))
    cb(unAccessor(source));
}
function timeRangeToArray(timeRanges) {
  let ranges = [];
  for (let i = 0; i < timeRanges.length; ++i)
    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];
  return ranges;
}
function tracksToArray(tracks) {
  return Array.from(tracks).map(
    ({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({
      id,
      label,
      kind,
      language,
      mode,
      activeCues,
      cues,
      inBandMetadataTrackDispatchType
    })
  );
}
const defaultOptions = {
  src: "",
  tracks: []
};
function useMediaControls(target, options = {}) {
  options = {
    ...defaultOptions,
    ...options
  };
  const { document: document2 = defaultDocument } = options;
  const [currentTime, setCurrentTime] = createSignal(0);
  const [duration, setDuration] = createSignal(0);
  const [seeking, setSeeking] = createSignal(false);
  const [volume, setVolume] = createSignal(1);
  const [waiting, setWaiting] = createSignal(false);
  const [ended, setEnded] = createSignal(false);
  const [playing, setPlaying] = createSignal(false);
  const [rate, setRate] = createSignal(1);
  const [stalled, setStalled] = createSignal(false);
  const [buffered, setBuffered] = createSignal([]);
  const [tracks, setTracks] = createSignal([]);
  const [selectedTrack, setSelectedTrack] = createSignal(-1);
  const [isPictureInPicture, setIsPictureInPicture] = createSignal(false);
  const [muted, setMuted] = createSignal(false);
  const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
  const sourceErrorEvent = createEventHook();
  const disableTrack = (track) => {
    usingElRef(target, (el) => {
      if (track) {
        const id = isNumber(track) ? track : track.id;
        el.textTracks[id].mode = "disabled";
      } else {
        for (let i = 0; i < el.textTracks.length; ++i)
          el.textTracks[i].mode = "disabled";
      }
      setSelectedTrack(-1);
    });
  };
  const enableTrack = (track, disableTracks = true) => {
    usingElRef(target, (el) => {
      const id = isNumber(track) ? track : track.id;
      if (disableTracks)
        disableTrack();
      el.textTracks[id].mode = "showing";
      setSelectedTrack(id);
    });
  };
  const togglePictureInPicture = () => {
    return new Promise((resolve, reject) => {
      usingElRef(target, async (el) => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture()) {
            el.requestPictureInPicture().then(resolve).catch(reject);
          } else {
            document2.exitPictureInPicture().then(resolve).catch(reject);
          }
        }
      });
    });
  };
  createEffect(() => {
    if (!document2)
      return;
    const el = unAccessor(target);
    if (!el)
      return;
    const src = unAccessor(options.src);
    let sources = [];
    if (!src)
      return;
    if (isString(src))
      sources = [{ src }];
    else if (Array.isArray(src))
      sources = src;
    else if (isObject(src))
      sources = [src];
    el.querySelectorAll("source").forEach((e) => {
      e.removeEventListener("error", sourceErrorEvent.trigger);
      e.remove();
    });
    sources.forEach(({ src: src2, type }) => {
      const source = document2.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type ?? "");
      source.addEventListener("error", sourceErrorEvent.trigger);
      el.appendChild(source);
    });
    el.load();
  });
  tryOnCleanup(() => {
    const el = unAccessor(target);
    if (!el)
      return;
    el.querySelectorAll("source").forEach((e) => e.removeEventListener("error", sourceErrorEvent.trigger));
  });
  createEffect(
    on(
      volume,
      (vol) => {
        const el = unAccessor(target);
        if (!el)
          return;
        el.volume = vol;
      },
      { defer: true }
    )
  );
  createEffect(
    on(
      muted,
      (mute) => {
        const el = unAccessor(target);
        if (!el)
          return;
        el.muted = mute;
      },
      { defer: true }
    )
  );
  createEffect(
    on(
      rate,
      (rate2) => {
        const el = unAccessor(target);
        if (!el)
          return;
        el.playbackRate = rate2;
      },
      { defer: true }
    )
  );
  createEffect(() => {
    if (!document2)
      return;
    const textTracks = unAccessor(options.tracks);
    const el = unAccessor(target);
    if (!(textTracks == null ? void 0 : textTracks.length) || !el)
      return;
    el.querySelectorAll("track").forEach((e) => e.remove());
    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {
      const track = document2.createElement("track");
      track.default = isDefault ?? false;
      track.kind = kind;
      track.label = label;
      track.src = src;
      track.srclang = srcLang;
      if (track.default)
        setSelectedTrack(i);
      el.appendChild(track);
    });
  });
  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {
    const el = unAccessor(target);
    if (!el)
      return;
    el.currentTime = time;
  });
  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {
    const el = unAccessor(target);
    if (!el)
      return;
    isPlaying ? el.play() : el.pause();
  });
  useEventListener(
    target,
    "timeupdate",
    () => ignoreCurrentTimeUpdates(() => setCurrentTime(() => unAccessor(target).currentTime))
  );
  useEventListener(target, "durationchange", () => setDuration(() => unAccessor(target).duration));
  useEventListener(target, "progress", () => setBuffered(() => timeRangeToArray(unAccessor(target).buffered)));
  useEventListener(target, "seeking", () => setSeeking(true));
  useEventListener(target, "seeked", () => setSeeking(false));
  useEventListener(target, "waiting", () => setWaiting(true));
  useEventListener(target, "playing", () => {
    setWaiting(false);
    setEnded(false);
  });
  useEventListener(target, "ratechange", () => setRate(() => unAccessor(target).playbackRate));
  useEventListener(target, "stalled", () => setStalled(true));
  useEventListener(target, "ended", () => setEnded(ended));
  useEventListener(target, "pause", () => ignorePlayingUpdates(() => setPlaying(false)));
  useEventListener(target, "play", () => ignorePlayingUpdates(() => setPlaying(true)));
  useEventListener(target, "enterpictureinpicture", () => setIsPictureInPicture(true));
  useEventListener(target, "leavepictureinpicture", () => setIsPictureInPicture(false));
  useEventListener(target, "volumechange", () => {
    const el = unAccessor(target);
    if (!el)
      return;
    setVolume(el.volume);
    setMuted(el.muted);
  });
  const listeners = [];
  const stop = watch(
    resolveAccessor(target),
    () => {
      const el = unAccessor(target);
      if (!el)
        return;
      stop();
      listeners[0] = useEventListener(el.textTracks, "addtrack", () => setTracks(tracksToArray(el.textTracks)));
      listeners[1] = useEventListener(el.textTracks, "removetrack", () => setTracks(tracksToArray(el.textTracks)));
      listeners[2] = useEventListener(el.textTracks, "change", () => setTracks(tracksToArray(el.textTracks)));
    },
    { defer: false }
  );
  tryOnCleanup(() => listeners.forEach((listener) => listener()));
  return {
    currentTime,
    setCurrentTime,
    duration,
    waiting,
    setWaiting,
    seeking,
    setSeeking,
    ended,
    setEnded,
    stalled,
    setStalled,
    buffered,
    setBuffered,
    playing,
    setPlaying,
    rate,
    setRate,
    // Volume
    volume,
    setVolume,
    muted,
    setMuted,
    // Tracks
    tracks,
    setTracks,
    selectedTrack,
    setSelectedTrack,
    enableTrack,
    disableTrack,
    // Picture in Picture
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    // Events
    onSourceError: sourceErrorEvent.on
  };
}
const getMapCompat = () => {
  const data = createMutable({});
  return {
    get: (key) => data[key],
    set: (key, value) => set(data, key, value),
    has: (key) => hasOwn(data, key),
    delete: (key) => del(data, key),
    clear: () => {
      Object.keys(data).forEach((key) => {
        del(data, key);
      });
    }
  };
};
function useMemoize(resolver, options) {
  const initCache = () => {
    if (options == null ? void 0 : options.cache)
      return createMutable(options.cache);
    return getMapCompat();
  };
  const cache = initCache();
  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : (
    // Default key: Serialize args
    JSON.stringify(args)
  );
  const _loadData = (key, ...args) => {
    cache.set(key, resolver(...args));
    return cache.get(key);
  };
  const loadData = (...args) => _loadData(generateKey(...args), ...args);
  const deleteData = (...args) => {
    cache.delete(generateKey(...args));
  };
  const clearData = () => {
    cache.clear();
  };
  const memoized = (...args) => {
    const key = generateKey(...args);
    if (cache.has(key))
      return cache.get(key);
    return _loadData(key, ...args);
  };
  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache;
  return memoized;
}
function useMemory(options = {}) {
  const [memory, setMemory] = createSignal();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported()) {
    const { interval = 1e3 } = options;
    useIntervalFn(
      () => {
        setMemory(performance.memory);
      },
      interval,
      { immediate: options.immediate, immediateCallback: options.immediateCallback }
    );
  }
  return { isSupported, memory };
}
function useMounted() {
  const [isMounted, setIsMounted] = createSignal(false);
  onMount(() => {
    setIsMounted(true);
  });
  return isMounted;
}
function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    eventFilter
  } = options;
  const [x, setX] = createSignal(initialValue.x);
  const [y, setY] = createSignal(initialValue.y);
  const [sourceType, setSourceType] = createSignal(null);
  const mouseHandler = (event) => {
    if (type === "page") {
      setX(event.pageX);
      setY(event.pageY);
    } else if (type === "client") {
      setX(event.clientX);
      setY(event.clientY);
    } else if (type === "movement") {
      setX(event.movementX);
      setY(event.movementY);
    }
    setSourceType("mouse");
  };
  const reset = () => {
    setX(initialValue.x);
    setY(initialValue.y);
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];
      if (type === "page") {
        setX(touch2.pageX);
        setY(touch2.pageY);
      } else if (type === "client") {
        setX(touch2.clientX);
        setY(touch2.clientY);
      }
      setSourceType("touch");
    }
  };
  const mouseHandlerWrapper = (event) => {
    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
  };
  const touchHandlerWrapper = (event) => {
    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
  };
  if (window2) {
    useEventListener(window2, "mousemove", mouseHandlerWrapper, { passive: true });
    useEventListener(window2, "dragover", mouseHandlerWrapper, { passive: true });
    if (touch && type !== "movement") {
      useEventListener(window2, "touchstart", touchHandlerWrapper, { passive: true });
      useEventListener(window2, "touchmove", touchHandlerWrapper, { passive: true });
      if (resetOnTouchEnds)
        useEventListener(window2, "touchend", reset, { passive: true });
    }
  }
  return {
    x,
    y,
    setX,
    setY,
    sourceType
  };
}
function useMouseInElement(target, options = {}) {
  const { handleOutside = true, window: window2 = defaultWindow } = options;
  const { x, y, sourceType } = useMouse(options);
  const targetRef = toAccessor(target ?? (window2 == null ? void 0 : window2.document.body));
  const [elementX, setElementX] = createSignal(0);
  const [elementY, setElementY] = createSignal(0);
  const [elementPositionX, setElementPositionX] = createSignal(0);
  const [elementPositionY, setElementPositionY] = createSignal(0);
  const [elementHeight, setElementHeight] = createSignal(0);
  const [elementWidth, setElementWidth] = createSignal(0);
  const [isOutside, setIsOutside] = createSignal(true);
  let stop = () => {
  };
  if (window2) {
    stop = watch([targetRef, x, y], () => {
      const el = targetRef();
      if (!el)
        return;
      const { left, top, width, height } = el.getBoundingClientRect();
      setElementPositionX(left + window2.pageXOffset);
      setElementPositionY(top + window2.pageYOffset);
      setElementHeight(height);
      setElementWidth(width);
      const elX = x() - elementPositionX();
      const elY = y() - elementPositionY();
      setIsOutside(width === 0 || height === 0 || elX <= 0 || elY <= 0 || elX > width || elY > height);
      if (handleOutside || !isOutside()) {
        setElementX(elX);
        setElementY(elY);
      }
    });
    useEventListener(document, "mouseleave", () => {
      setIsOutside(true);
    });
  }
  return {
    x,
    y,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options = {}) {
  const { touch = true, drag = true, initialValue = false, window: window2 = defaultWindow } = options;
  const [pressed, setPressed] = createSignal(initialValue);
  const [sourceType, setSourceType] = createSignal(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => () => {
    setPressed(true);
    setSourceType(srcType);
  };
  const onReleased = () => {
    setPressed(false);
    setSourceType(null);
  };
  const target = createMemo(() => unAccessor(options.target) ?? window2);
  useEventListener(target, "mousedown", onPressed("mouse"), { passive: true });
  useEventListener(window2, "mouseleave", onReleased, { passive: true });
  useEventListener(window2, "mouseup", onReleased, { passive: true });
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), { passive: true });
    useEventListener(window2, "drop", onReleased, { passive: true });
    useEventListener(window2, "dragend", onReleased, { passive: true });
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), { passive: true });
    useEventListener(window2, "touchend", onReleased, { passive: true });
    useEventListener(window2, "touchcancel", onReleased, { passive: true });
  }
  return {
    pressed,
    sourceType
  };
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(resolveAccessor(target), (el) => {
    cleanup();
    if (isSupported() && window2 && el) {
      observer = new MutationObserver(callback);
      observer.observe(el, mutationOptions);
    }
  });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnCleanup(stop);
  return {
    isSupported,
    stop
  };
}
const useNavigatorLanguage = (options = {}) => {
  const { window: window2 = defaultWindow } = options;
  const navigator = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator && "language" in navigator);
  const [language, setLanguage] = createSignal(navigator == null ? void 0 : navigator.language);
  useEventListener(window2, "languagechange", () => {
    if (navigator) {
      setLanguage(navigator.language);
    }
  });
  return {
    isSupported,
    language
  };
};
function useNetwork(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator && "connection" in navigator);
  const [isOnline, setIsOnline] = createSignal(true);
  const [saveData, setSaveData] = createSignal(false);
  const [offlineAt, setOfflineAt] = createSignal(void 0);
  const [onlineAt, setOnlineAt] = createSignal(void 0);
  const [downlink, setDownlink] = createSignal(void 0);
  const [downlinkMax, setDownlinkMax] = createSignal(void 0);
  const [rtt, setRtt] = createSignal(void 0);
  const [effectiveType, setEffectiveType] = createSignal(void 0);
  const [type, setType] = createSignal("unknown");
  const connection = isSupported() && navigator.connection;
  function updateNetworkInformation() {
    if (!navigator)
      return;
    setIsOnline(navigator.onLine);
    setOfflineAt(isOnline() ? void 0 : Date.now());
    setOnlineAt(isOnline() ? Date.now() : void 0);
    if (connection) {
      setDownlink(connection.downlink);
      setDownlinkMax(connection.downlinkMax);
      setEffectiveType(connection.effectiveType);
      setRtt(connection.rtt);
      setSaveData(connection.saveData);
      setType(connection.type);
    }
  }
  if (window2) {
    useEventListener(window2, "offline", () => {
      setIsOnline(false);
      setOfflineAt(Date.now());
    });
    useEventListener(window2, "online", () => {
      setIsOnline(true);
      setOnlineAt(Date.now());
    });
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline,
    saveData,
    offlineAt,
    onlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type
  };
}
function useNow(options = {}) {
  const { controls: exposeControls = false, interval = "requestAnimationFrame" } = options;
  const [now, setNow] = createSignal(new Date());
  const update = () => setNow(new Date());
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });
  if (exposeControls) {
    return {
      now,
      ...controls
    };
  }
  return now;
}
function useObjectUrl(object) {
  const [url, setUrl] = createSignal("");
  const release = () => {
    const urlVal = url();
    if (urlVal) {
      URL.revokeObjectURL(urlVal);
    }
    setUrl(void 0);
  };
  createEffect(
    on(resolveAccessor(object), (newObject) => {
      release();
      if (newObject) {
        setUrl(URL.createObjectURL(newObject));
      }
    })
  );
  return url;
}
function useClamp(value, min, max) {
  if (isAccessor(value)) {
    return createMemo(() => clamp(unAccessor(value), unAccessor(min), unAccessor(max)));
  }
  const [_value, _setValue] = toSignal(value);
  const getValue2 = createMemo(() => {
    return clamp(_value(), unAccessor(min), unAccessor(max));
  });
  const setValue = (value2) => {
    const res = clamp(getSetterValue(value2, _value()), unAccessor(min), unAccessor(max));
    _setValue(res);
    return res;
  };
  return [getValue2, setValue];
}
function useOffsetPagination(options) {
  const {
    total = Infinity,
    pageSize = 10,
    page = 1,
    setPage,
    setPageSize,
    onPageChange = noop,
    onPageSizeChange = noop,
    onPageCountChange = noop
  } = options;
  const [currentPageSize, setCurrentPageSize] = useClamp(
    setPageSize === void 0 || isNumber(pageSize) ? pageSize : [pageSize, setPageSize],
    1,
    Infinity
  );
  const pageCount = createMemo(() => Math.max(1, Math.ceil(unAccessor(total) / unAccessor(currentPageSize))));
  const [currentPage, setCurrentPage] = useClamp(
    setPage === void 0 || isNumber(page) ? page : [page, setPage],
    1,
    pageCount
  );
  const isFirstPage = createMemo(() => currentPage() === 1);
  const isLastPage = createMemo(() => currentPage() === pageCount());
  if (isAccessor(page))
    syncSignal([page, setPage], [currentPage, setCurrentPage], { defer: true });
  if (isAccessor(pageSize))
    syncSignal([pageSize, setPageSize], [currentPageSize, setCurrentPageSize], { defer: true });
  function prev() {
    setCurrentPage((state) => state - 1);
  }
  function next() {
    setCurrentPage((state) => state + 1);
  }
  const returnValue = {
    currentPage,
    setCurrentPage,
    currentPageSize,
    setCurrentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev,
    next
  };
  createEffect(
    on(
      currentPage,
      () => {
        onPageChange(reactive(returnValue));
      },
      { defer: true }
    )
  );
  createEffect(
    on(
      currentPageSize,
      () => {
        onPageSizeChange(reactive(returnValue));
      },
      { defer: true }
    )
  );
  createEffect(
    on(
      pageCount,
      () => {
        onPageCountChange(reactive(returnValue));
      },
      { defer: true }
    )
  );
  return returnValue;
}
function useOnline(options = {}) {
  const { isOnline } = useNetwork(options);
  return isOnline;
}
function usePageLeave(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const [isLeft, setIsLeft] = createSignal(false);
  const handler = (event) => {
    if (!window2)
      return;
    event = event || window2.event;
    const from = event.relatedTarget ?? event.toElement;
    setIsLeft(!from);
  };
  if (window2) {
    useEventListener(window2, "mouseout", handler, { passive: true });
    useEventListener(window2.document, "mouseleave", handler, { passive: true });
    useEventListener(window2.document, "mouseenter", handler, { passive: true });
  }
  return isLeft;
}
function useParallax(target, options = {}) {
  const {
    deviceOrientationTiltAdjust = (i) => i,
    deviceOrientationRollAdjust = (i) => i,
    mouseTiltAdjust = (i) => i,
    mouseRollAdjust = (i) => i,
    window: window2 = defaultWindow
  } = options;
  const orientation = useDeviceOrientation({ window: window2 });
  const {
    elementX: x,
    elementY: y,
    elementWidth: width,
    elementHeight: height
  } = useMouseInElement(target, { handleOutside: false, window: window2 });
  const source = createMemo(() => {
    if (orientation.isSupported() && (orientation.alpha() != null && orientation.alpha() !== 0 || orientation.gamma() != null && orientation.gamma() !== 0))
      return "deviceOrientation";
    return "mouse";
  });
  const roll = createMemo(() => {
    if (source() === "deviceOrientation") {
      const value2 = -orientation.beta / 90;
      return deviceOrientationRollAdjust(value2);
    }
    const value = -(y() - height() / 2) / height();
    return mouseRollAdjust(value);
  });
  const tilt = createMemo(() => {
    if (source() === "deviceOrientation") {
      const value2 = orientation.gamma() / 90;
      return deviceOrientationTiltAdjust(value2);
    }
    const value = (x() - width() / 2) / width();
    return mouseTiltAdjust(value);
  });
  return { roll, tilt, source };
}
const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options = {}) {
  const { target = defaultWindow } = options;
  const [isInside, setInside] = createSignal(false);
  const state = createMutable(options.initialValue ?? {});
  Object.assign(state, defaultState);
  const handler = (event) => {
    setInside(true);
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    Object.assign(state, objectPick(event, keys, false));
  };
  if (target) {
    useEventListener(target, "pointerdown", handler, { passive: true });
    useEventListener(target, "pointermove", handler, { passive: true });
    useEventListener(target, "pointerleave", () => setInside(false), { passive: true });
  }
  return {
    ...toAccessors(state),
    isInside
  };
}
function usePointerLock(target, options = {}) {
  const { document: document2 = defaultDocument, pointerLockOptions } = options;
  const isSupported = useSupported(() => document2 && "pointerLockElement" in document2);
  const [element, setElement] = createSignal();
  const [triggerElement, setTriggerElement] = createSignal();
  let targetElement;
  if (isSupported()) {
    useEventListener(document2, "pointerlockchange", () => {
      const currentElement = document2.pointerLockElement ?? element();
      if (targetElement && currentElement === targetElement) {
        const elementValue = document2.pointerLockElement;
        setElement(elementValue);
        if (!elementValue) {
          setTriggerElement(null);
          targetElement = null;
        }
      }
    });
    useEventListener(document2, "pointerlockerror", () => {
      const currentElement = document2.pointerLockElement ?? element();
      if (targetElement && currentElement === targetElement) {
        const action = document2.pointerLockElement ? "release" : "acquire";
        throw new Error(`Failed to ${action} pointer lock.`);
      }
    });
  }
  const owner = getOwner();
  function lock(e, options2) {
    if (!isSupported())
      throw new Error("Pointer Lock API is not supported by your browser.");
    const triggerElementValue = e instanceof Event ? e.currentTarget : null;
    setTriggerElement(triggerElementValue);
    targetElement = e instanceof Event ? unAccessor(target) ?? triggerElementValue : unAccessor(e);
    if (!targetElement)
      throw new Error("Target element undefined.");
    targetElement.requestPointerLock(options2 ?? pointerLockOptions);
    return until(element, owner).toBe(targetElement);
  }
  async function unlock() {
    if (!element())
      return false;
    document2.exitPointerLock();
    await until(element, owner).toBeNull();
    return true;
  }
  return {
    isSupported,
    element,
    triggerElement,
    lock,
    unlock
  };
}
var SwipeDirection = /* @__PURE__ */ ((SwipeDirection2) => {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
  return SwipeDirection2;
})(SwipeDirection || {});
function useSwipe(target, options = {}) {
  const { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart, passive = true, window: window2 = defaultWindow } = options;
  const coordsStart = createMutable({ x: 0, y: 0 });
  const coordsEnd = createMutable({ x: 0, y: 0 });
  const diffX = createMemo(() => coordsStart.x - coordsEnd.x);
  const diffY = createMemo(() => coordsStart.y - coordsEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = createMemo(() => max(abs(diffX()), abs(diffY())) >= threshold);
  const [isSwiping, setIsSwiping] = createSignal(false);
  const direction = createMemo(() => {
    if (!isThresholdExceeded())
      return "NONE";
    if (abs(diffX()) > abs(diffY())) {
      return diffX() > 0 ? "LEFT" : "RIGHT";
    }
    return diffY() > 0 ? "UP" : "DOWN";
  });
  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };
  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };
  let listenerOptions;
  const isPassiveEventSupported = checkPassiveEventSupport(window2 == null ? void 0 : window2.document);
  if (!passive)
    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };
  else
    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };
  const onTouchEnd = (e) => {
    if (isSwiping())
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction());
    setIsSwiping(false);
  };
  const stops = [
    useEventListener(
      target,
      "touchstart",
      (e) => {
        if (listenerOptions.capture && !listenerOptions.passive)
          e.preventDefault();
        const [x, y] = getTouchEventCoords(e);
        updateCoordsStart(x, y);
        updateCoordsEnd(x, y);
        onSwipeStart == null ? void 0 : onSwipeStart(e);
      },
      listenerOptions
    ),
    useEventListener(
      target,
      "touchmove",
      (e) => {
        const [x, y] = getTouchEventCoords(e);
        updateCoordsEnd(x, y);
        if (!isSwiping() && isThresholdExceeded())
          setIsSwiping(true);
        if (isSwiping())
          onSwipe == null ? void 0 : onSwipe(e);
      },
      listenerOptions
    ),
    useEventListener(target, "touchend", onTouchEnd, listenerOptions),
    useEventListener(target, "touchcancel", onTouchEnd, listenerOptions)
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isPassiveEventSupported,
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop
  };
}
function checkPassiveEventSupport(document2) {
  if (!document2)
    return false;
  let supportsPassive = false;
  const optionsBlock = {
    get passive() {
      supportsPassive = true;
      return false;
    }
  };
  document2.addEventListener("x", noop, optionsBlock);
  document2.removeEventListener("x", noop);
  return supportsPassive;
}
function usePointerSwipe(target, options = {}) {
  const targetRef = resolveAccessor(target);
  const { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart } = options;
  const posStart = createMutable({ x: 0, y: 0 });
  const updatePosStart = (x, y) => {
    posStart.x = x;
    posStart.y = y;
  };
  const posEnd = createMutable({ x: 0, y: 0 });
  const updatePosEnd = (x, y) => {
    posEnd.x = x;
    posEnd.y = y;
  };
  const distanceX = createMemo(() => posStart.x - posEnd.x);
  const distanceY = createMemo(() => posStart.y - posEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = createMemo(() => max(abs(distanceX()), abs(distanceY())) >= threshold);
  const [isSwiping, setIsSwiping] = createSignal(false);
  const [isPointerDown, setIsPointerDown] = createSignal(false);
  const direction = createMemo(() => {
    if (!isThresholdExceeded())
      return SwipeDirection.NONE;
    if (abs(distanceX()) > abs(distanceY())) {
      return distanceX() > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
    }
    return distanceY() > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
  });
  const eventIsAllowed = (e) => {
    var _a;
    const isReleasingButton = e.buttons === 0;
    const isPrimaryButton = e.buttons === 1;
    return ((_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) ?? (isReleasingButton || isPrimaryButton) ?? true;
  };
  const stops = [
    useEventListener(target, "pointerdown", (e) => {
      var _a, _b;
      if (!eventIsAllowed(e))
        return;
      setIsPointerDown(true);
      (_b = (_a = targetRef()) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "none");
      const eventTarget = e.target;
      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
      const { clientX: x, clientY: y } = e;
      updatePosStart(x, y);
      updatePosEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }),
    useEventListener(target, "pointermove", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (!isPointerDown())
        return;
      const { clientX: x, clientY: y } = e;
      updatePosEnd(x, y);
      if (!isSwiping() && isThresholdExceeded())
        setIsSwiping(true);
      if (isSwiping())
        onSwipe == null ? void 0 : onSwipe(e);
    }),
    useEventListener(target, "pointerup", (e) => {
      var _a, _b;
      if (!eventIsAllowed(e))
        return;
      if (isSwiping())
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction());
      setIsPointerDown(false);
      setIsSwiping(false);
      (_b = (_a = targetRef()) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "initial");
    })
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping,
    direction,
    posStart,
    posEnd,
    distanceX,
    distanceY,
    stop
  };
}
function usePreferredColorScheme(options) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
  return createMemo(() => {
    if (isDark())
      return "dark";
    if (isLight())
      return "light";
    return "no-preference";
  });
}
function usePreferredContrast(options) {
  const isMore = useMediaQuery("(prefers-contrast: more)", options);
  const isLess = useMediaQuery("(prefers-contrast: less)", options);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", options);
  return createMemo(() => {
    if (isMore())
      return "more";
    if (isLess())
      return "less";
    if (isCustom())
      return "custom";
    return "no-preference";
  });
}
function usePreferredLanguages(options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2) {
    const [en] = createSignal(["en"]);
    return en;
  }
  const navigator = window2.navigator;
  const [value, setValue] = createSignal(navigator.languages);
  useEventListener(window2, "languagechange", () => {
    setValue(navigator.languages);
  });
  return value;
}
function usePreferredReducedMotion(options) {
  const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options);
  return createMemo(() => {
    if (isReduced())
      return "reduce";
    return "no-preference";
  });
}
function usePrevious(value, initialValue) {
  const [previous, setPrevious] = createSignal();
  createEffect((v) => {
    setPrevious(() => v);
    return resolveAccessor(value)();
  }, initialValue);
  return previous;
}
const useScreenOrientation = (options = {}) => {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "screen" in window2 && "orientation" in window2.screen);
  const screenOrientation = isSupported() ? window2.screen.orientation : {};
  const [orientation, setOrientation] = createSignal(screenOrientation.type);
  const [angle, setAngle] = createSignal(screenOrientation.angle || 0);
  if (isSupported()) {
    useEventListener(window2, "orientationchange", () => {
      setOrientation(screenOrientation.type);
      setAngle(screenOrientation.angle);
    });
  }
  const lockOrientation = (type) => {
    if (!isSupported())
      return Promise.reject(new Error("Not supported"));
    return screenOrientation.lock(type);
  };
  const unlockOrientation = () => {
    if (isSupported())
      screenOrientation.unlock();
  };
  return {
    isSupported,
    orientation,
    angle,
    lockOrientation,
    unlockOrientation
  };
};
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
  const [top, setTop] = createSignal("");
  const [right, setRight] = createSignal("");
  const [bottom, setBottom] = createSignal("");
  const [left, setLeft] = createSignal("");
  if (isClient) {
    const [_topCssVar, setTopCssVar] = useCssVar(topVarName);
    const [_rightCssVar, setRightCssVar] = useCssVar(rightVarName);
    const [_bottomCssVar, setBottomCssVar] = useCssVar(bottomVarName);
    const [_leftCssVar, setLeftCssVar] = useCssVar(leftVarName);
    setTopCssVar("env(safe-area-inset-top, 0)");
    setRightCssVar("env(safe-area-inset-right, 0)");
    setBottomCssVar("env(safe-area-inset-bottom, 0)");
    setLeftCssVar("env(safe-area-inset-left, 0)");
    update();
    useEventListener("resize", useDebounceFn(update));
  }
  function update() {
    setTop(getValue(topVarName));
    setRight(getValue(rightVarName));
    setBottom(getValue(bottomVarName));
    setLeft(getValue(leftVarName));
  }
  return {
    top,
    right,
    bottom,
    left,
    update
  };
}
function getValue(position) {
  return getComputedStyle(document.documentElement).getPropertyValue(position);
}
function useScriptTag(src, onLoaded = noop, options = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs = {}
  } = options;
  const [scriptTag, setScriptTag] = createSignal(null);
  let _promise = null;
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      setScriptTag(el2);
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${unAccessor(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type;
      el.async = async;
      el.src = unAccessor(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    el.addEventListener("error", (event) => reject(event));
    el.addEventListener("abort", (event) => reject(event));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  };
  const unload = () => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag())
      setScriptTag(null);
    const el = document2.querySelector(`script[src="${unAccessor(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  };
  if (immediate && !manual)
    tryOnMount(load);
  if (!manual)
    tryOnCleanup(unload);
  return { scriptTag, load, unload };
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientHeight < ele.scrollHeight || style.overflowY === "auto" && ele.clientWidth < ele.scrollWidth) {
    return true;
  }
  const parent = ele.parentNode;
  if (!parent || parent.tagName === "BODY")
    return false;
  return checkOverflowScroll(parent);
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
function useScrollLock(element, initialState = false) {
  const [isLocked, setIsLocked] = createSignal(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow;
  createEffect(
    on(resolveAccessor(element), (el) => {
      if (el) {
        const ele = el;
        initialOverflow = ele.style.overflow;
        if (isLocked())
          ele.style.overflow = "hidden";
      }
    })
  );
  const lock = () => {
    const ele = unAccessor(element);
    if (!ele || isLocked())
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        ele,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    ele.style.overflow = "hidden";
    setIsLocked(true);
  };
  const unlock = () => {
    const ele = unAccessor(element);
    if (!ele || !isLocked())
      return;
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    ele.style.overflow = initialOverflow;
    setIsLocked(false);
  };
  tryOnCleanup(unlock);
  return [
    isLocked,
    (v) => {
      if (v)
        lock();
      else
        unlock();
    }
  ];
}
function useSessionStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options);
}
function useShare(shareOptions = {}, options = {}) {
  const { navigator = defaultNavigator } = options;
  const _navigator = navigator;
  const isSupported = useSupported(() => _navigator && "canShare" in _navigator);
  const share = async (overrideOptions = {}) => {
    if (isSupported()) {
      const data = {
        ...unAccessor(shareOptions),
        ...unAccessor(overrideOptions)
      };
      let granted = true;
      if (data.files && _navigator.canShare)
        granted = _navigator.canShare({ files: data.files });
      if (granted)
        return _navigator.share(data);
    }
  };
  return {
    isSupported,
    share
  };
}
function useSpeechRecognition(options = {}) {
  const { interimResults = true, continuous = true, window: window2 = defaultWindow } = options;
  const lang = resolveAccessor(options.lang ?? "en-US");
  const [isListening, setIsListening] = createSignal(false);
  const [isFinal, setIsFinal] = createSignal(false);
  const [result, setResult] = createSignal("");
  const [error, setError] = createSignal(void 0);
  const toggle = (value = !isListening()) => {
    setIsListening(value);
  };
  const start = () => {
    setIsListening(true);
  };
  const stop = () => {
    setIsListening(false);
  };
  const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
  const isSupported = useSupported(() => SpeechRecognition);
  let recognition;
  if (isSupported()) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = unAccessor(lang);
    recognition.onstart = () => {
      setIsFinal(false);
    };
    createEffect(
      on(
        lang,
        (lang2) => {
          if (recognition && !isListening())
            recognition.lang = lang2;
        },
        { defer: true }
      )
    );
    recognition.onresult = (event) => {
      const transcript = Array.from(event.results).map((result2) => {
        setIsFinal(result2.isFinal);
        return result2[0];
      }).map((result2) => result2.transcript).join("");
      setResult(transcript);
      setError(void 0);
    };
    recognition.onerror = (event) => {
      setError(event);
    };
    recognition.onend = () => {
      setIsListening(false);
      recognition.lang = unAccessor(lang);
    };
    createEffect(
      on(
        isListening,
        () => {
          if (isListening())
            recognition.start();
          else
            recognition.stop();
        },
        { defer: true }
      )
    );
  }
  tryOnCleanup(() => {
    setIsListening(false);
  });
  return {
    isSupported,
    isListening,
    isFinal,
    result,
    setResult,
    recognition,
    error,
    toggle,
    start,
    stop
  };
}
function useSpeechSynthesis(text, options = {}) {
  const { pitch = 1, rate = 1, volume = 1, window: window2 = defaultWindow } = options;
  const synth = window2 && window2.speechSynthesis;
  const isSupported = useSupported(() => synth);
  const [isPlaying, setIsPlaying] = createSignal(false);
  const [status, setStatus] = createSignal("init");
  const spokenText = resolveAccessor(text || "");
  const lang = resolveAccessor(options.lang ?? "en-US");
  const [error, setError] = createSignal(void 0);
  const toggle = (value = !isPlaying()) => {
    setIsPlaying(value);
  };
  const bindEventsForUtterance = (utterance2) => {
    utterance2.lang = unAccessor(lang);
    utterance2.voice = unAccessor(options.voice) ?? null;
    utterance2.pitch = pitch;
    utterance2.rate = rate;
    utterance2.volume = volume;
    utterance2.onstart = () => {
      setIsPlaying(true);
      setStatus("play");
    };
    utterance2.onpause = () => {
      setIsPlaying(false);
      setStatus("pause");
    };
    utterance2.onresume = () => {
      setIsPlaying(true);
      setStatus("play");
    };
    utterance2.onend = () => {
      setIsPlaying(false);
      setStatus("end");
    };
    utterance2.onerror = (event) => {
      setError(event);
    };
  };
  const utterance = createMemo(() => {
    setIsPlaying(false);
    setStatus("init");
    const newUtterance = new SpeechSynthesisUtterance(spokenText());
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });
  const speak = () => {
    synth.cancel();
    utterance && synth.speak(utterance());
  };
  const stop = () => {
    synth.cancel();
    setIsPlaying(false);
  };
  if (isSupported()) {
    bindEventsForUtterance(utterance());
    createEffect(
      on(
        lang,
        (lang2) => {
          if (utterance() && !isPlaying())
            utterance().lang = lang2;
        },
        { defer: true }
      )
    );
    if (options.voice) {
      createEffect(
        on(
          resolveAccessor(options.voice),
          () => {
            synth.cancel();
          },
          { defer: true }
        )
      );
    }
    createEffect(
      on(
        resolveAccessor(isPlaying),
        () => {
          if (isPlaying())
            synth.resume();
          else
            synth.pause();
        },
        { defer: true }
      )
    );
  }
  tryOnCleanup(() => {
    setIsPlaying(false);
  });
  return {
    isSupported,
    isPlaying,
    status,
    utterance,
    error,
    stop,
    toggle,
    speak
  };
}
function useStepper(steps, initialStep) {
  const stepsRef = resolveAccessor(steps);
  const stepNames = createMemo(() => Array.isArray(stepsRef()) ? stepsRef() : Object.keys(stepsRef()));
  const [index, setIndex] = createSignal(stepNames().indexOf(initialStep ?? stepNames()[0]));
  const current = createMemo(() => at(index()));
  const isFirst = createMemo(() => index() === 0);
  const isLast = createMemo(() => index() === stepNames().length - 1);
  const next = createMemo(() => stepNames()[index() + 1]);
  const previous = createMemo(() => stepNames()[index() - 1]);
  function at(index2) {
    if (Array.isArray(stepsRef()))
      return stepsRef()[index2];
    return stepsRef()[stepNames()[index2]];
  }
  function get(step) {
    if (!stepNames().includes(step))
      return;
    return at(stepNames().indexOf(step));
  }
  function goTo(step) {
    if (stepNames().includes(step))
      setIndex(stepNames().indexOf(step));
  }
  function goToNext() {
    if (isLast())
      return;
    setIndex((index2) => index2 + 1);
  }
  function goToPrevious() {
    if (isFirst())
      return;
    setIndex((index2) => index2 - 1);
  }
  function goBackTo(step) {
    if (isAfter(step))
      goTo(step);
  }
  function isNext(step) {
    return stepNames().indexOf(step) === index() + 1;
  }
  function isPrevious(step) {
    return stepNames().indexOf(step) === index() - 1;
  }
  function isCurrent(step) {
    return stepNames().indexOf(step) === index();
  }
  function isBefore(step) {
    return index() < stepNames().indexOf(step);
  }
  function isAfter(step) {
    return index() > stepNames().indexOf(step);
  }
  return {
    steps: stepsRef,
    stepNames,
    index,
    current,
    next,
    previous,
    isFirst,
    isLast,
    at,
    get,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}
function useStorageAsync(key, initialValue, storage, options = {}) {
  const {
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const rawInit = unAccessor(initialValue);
  const type = guessSerializerType(rawInit);
  const [data, setData] = toSignal(initialValue);
  const serializer = options.serializer ?? StorageSerializers[type];
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => defaultWindow == null ? void 0 : defaultWindow.localStorage)();
    } catch (e) {
      onError(e);
    }
  }
  async function read(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : await storage.getItem(key);
      if (rawValue == null) {
        setData(() => rawInit);
        if (writeDefaults && rawInit !== null)
          await storage.setItem(key, await serializer.write(rawInit));
      } else if (mergeDefaults) {
        const value = await serializer.read(rawValue);
        if (isFunction(mergeDefaults)) {
          setData(() => mergeDefaults(value, rawInit));
        } else if (type === "object" && !Array.isArray(value)) {
          setData({ ...rawInit, ...value });
        } else {
          setData(value);
        }
      } else {
        setData(await serializer.read(rawValue));
      }
    } catch (e) {
      onError(e);
    }
  }
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e) => setTimeout(() => read(e), 0));
  if (storage) {
    watchWithFilter(
      data,
      async () => {
        try {
          const dataVal = data();
          if (dataVal == null)
            await storage.removeItem(key);
          else
            await storage.setItem(key, await serializer.write(dataVal));
        } catch (e) {
          onError(e);
        }
      },
      { eventFilter, defer: false }
    );
  }
  return data;
}
let _id = 0;
function useStyleTag(css, options = {}) {
  const [isLoaded, setIsLoaded] = createSignal(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `solidjs-use_style_tag_${++_id}`
  } = options;
  const [cssAccessor, setCss] = toSignal(css);
  let stop = () => {
  };
  const load = () => {
    if (!document2)
      return;
    const el = document2.getElementById(id) ?? document2.createElement("style");
    if (!el.isConnected) {
      el.type = "text/css";
      el.id = id;
      if (options.media)
        el.media = options.media;
      document2.head.appendChild(el);
    }
    if (isLoaded())
      return;
    stop = watch(cssAccessor, (value) => {
      el.innerText = value;
    });
    setIsLoaded(true);
  };
  const unload = () => {
    if (!document2 || !isLoaded())
      return;
    stop();
    document2.head.removeChild(document2.getElementById(id));
    setIsLoaded(false);
  };
  if (immediate && !manual)
    tryOnMount(load);
  if (!manual)
    tryOnCleanup(unload);
  return {
    id,
    css: cssAccessor,
    setCss,
    unload,
    load,
    isLoaded
  };
}
function useTextDirection(options = {}) {
  const { document: document2 = defaultDocument, selector = "html", observe = false, initialValue = "ltr" } = options;
  function getValue2() {
    var _a;
    return ((_a = document2 == null ? void 0 : document2.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) ?? initialValue;
  }
  const [dir, setDir] = createSignal(getValue2());
  tryOnMount(() => setDir(getValue2()));
  if (observe && document2) {
    useMutationObserver(document2.querySelector(selector), () => setDir(getValue2()), {
      attributes: true
    });
  }
  return {
    dir,
    setDir: (v) => {
      var _a, _b;
      setDir(v);
      if (!document2)
        return;
      if (dir())
        (_a = document2.querySelector(selector)) == null ? void 0 : _a.setAttribute("dir", dir());
      else
        (_b = document2.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
  };
}
function getRangesFromSelection(selection) {
  const rangeCount = selection.rangeCount ?? 0;
  const ranges = new Array(rangeCount);
  for (let i = 0; i < rangeCount; i++) {
    const range = selection.getRangeAt(i);
    ranges[i] = range;
  }
  return ranges;
}
function useTextSelection(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const [selection, setSelection] = createSignal(null);
  const text = createMemo(() => {
    var _a;
    return ((_a = selection()) == null ? void 0 : _a.toString()) ?? "";
  });
  const ranges = createMemo(() => selection() ? getRangesFromSelection(selection()) : []);
  const rects = createMemo(() => ranges().map((range) => range.getBoundingClientRect()));
  function onSelectionChange() {
    setSelection(null);
    if (window2)
      setSelection(window2.getSelection());
  }
  if (window2)
    useEventListener(window2.document, "selectionchange", onSelectionChange);
  return {
    text,
    rects,
    ranges,
    selection
  };
}
function useTextareaAutoSize(options) {
  const [textareaRef, setTextareaRef] = createSignal(options == null ? void 0 : options.element);
  const [value, setValue] = createSignal(options == null ? void 0 : options.input);
  function triggerResize() {
    var _a, _b;
    if (!textareaRef())
      return;
    textareaRef().style.height = "1px";
    textareaRef().style.height = `${(_a = textareaRef()) == null ? void 0 : _a.scrollHeight}px`;
    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);
  }
  createEffect(on([value, textareaRef], triggerResize));
  useResizeObserver(textareaRef, () => triggerResize());
  if (options == null ? void 0 : options.deps)
    createEffect(on(options.deps, triggerResize));
  const onChange = (event) => {
    setValue(event.currentTarget.value);
  };
  return {
    setTextareaRef,
    value,
    onChange,
    triggerResize
  };
}
function useThrottledHistoryTravel(source, options = {}) {
  const { throttle = 200, trailing = true } = options;
  const filter = throttleFilter(throttle, trailing);
  const history = useHistoryTravel(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
const DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Infinity, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: (n) => /\d/.exec(n) ? `${n} ago` : n,
  future: (n) => /\d/.exec(n) ? `in ${n}` : n,
  month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
  year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
  day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
  week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
  hour: (n) => `${n} hour${n > 1 ? "s" : ""}`,
  minute: (n) => `${n} minute${n > 1 ? "s" : ""}`,
  second: (n) => `${n} second${n > 1 ? "s" : ""}`,
  invalid: ""
};
const DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);
function useTimeAgo(time, options = {}) {
  const { controls: exposeControls = false, updateInterval = 3e4 } = options;
  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });
  const timeAgo = createMemo(() => formatTimeAgo(new Date(unAccessor(time)), options, unAccessor(now())));
  if (exposeControls) {
    return {
      timeAgo,
      ...controls
    };
  }
  return timeAgo;
}
function formatTimeAgo(from, options = {}, now = Date.now()) {
  var _a;
  const {
    max,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER,
    units = DEFAULT_UNITS,
    showSecond = false,
    rounding = "round"
  } = options;
  const roundFn = typeof rounding === "number" ? (n) => +n.toFixed(rounding) : Math[rounding];
  const diff = +now - +from;
  const absDiff = Math.abs(diff);
  function getValue2(diff2, unit) {
    return roundFn(Math.abs(diff2) / unit.value);
  }
  function format(diff2, unit) {
    const val = getValue2(diff2, unit);
    const past = diff2 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  function applyFormat(name, val, isPast) {
    const formatter = messages[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  if (absDiff < 6e4 && !showSecond)
    return messages.justNow;
  if (typeof max === "number" && absDiff > max)
    return fullDateFormatter(new Date(from));
  if (typeof max === "string") {
    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;
    if (unitMax && absDiff > unitMax)
      return fullDateFormatter(new Date(from));
  }
  for (const [idx, unit] of units.entries()) {
    const val = getValue2(diff, unit);
    if (val <= 0 && units[idx - 1])
      return format(diff, units[idx - 1]);
    if (absDiff < unit.max)
      return format(diff, unit);
  }
  return messages.invalid;
}
function useTimestamp(options = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame",
    callback
  } = options;
  const tsSignal = createSignal(timestamp() + offset);
  const [ts, setTs] = tsSignal;
  const update = () => setTs(timestamp() + offset);
  const cb = callback ? () => {
    update();
    callback(ts());
  } : update;
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  if (exposeControls) {
    return {
      timestamp: ts,
      ...controls
    };
  }
  return tsSignal;
}
function useTitle(newTitle = null, options = {}) {
  var _a;
  const { document: document2 = defaultDocument } = options;
  const title = toSignal(newTitle ?? (document2 == null ? void 0 : document2.title) ?? null);
  const isReadonly = !!(newTitle && isAccessor(newTitle));
  function format(t) {
    if (!("titleTemplate" in options))
      return t;
    const template = options.titleTemplate ?? "%s";
    return isFunction(template) ? template(t) : unAccessor(template).replace(/%s/g, t);
  }
  createEffect(
    on(title[0], (t, o) => {
      if (t !== o && document2)
        document2.title = format(isString(t) ? t : "");
    })
  );
  if (options.observe && !options.titleTemplate && document2 && !isReadonly) {
    useMutationObserver(
      (_a = document2.head) == null ? void 0 : _a.querySelector("title"),
      () => {
        if (document2 && document2.title !== title[0]())
          title[1](format(document2.title));
      },
      { childList: true }
    );
  }
  if (isReadonly)
    return title[0];
  return title;
}
function useUrlSearchParams(mode = "history", options = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    write: enableWrite = true,
    window: window2 = defaultWindow
  } = options;
  if (!window2)
    return createMutable(initialValue);
  const state = createMutable({});
  function getRawParams() {
    if (mode === "history") {
      return window2.location.search || "";
    } else if (mode === "hash") {
      const hash = window2.location.hash || "";
      const index = hash.indexOf("?");
      return index > 0 ? hash.slice(index) : "";
    }
    return (window2.location.hash || "").replace(/^#/, "");
  }
  function constructQuery(params) {
    const stringified = params.toString();
    if (mode === "history")
      return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
    if (mode === "hash-params")
      return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window2.location.hash || "#";
    const index = hash.indexOf("?");
    if (index > 0)
      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
    return `${hash}${stringified ? `?${stringified}` : ""}`;
  }
  function read() {
    return new URLSearchParams(getRawParams());
  }
  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));
    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) ?? "";
      unusedKeys.delete(key);
    }
    Array.from(unusedKeys).forEach((key) => delete state[key]);
  }
  const { pause, resume } = pausableWatch(
    state,
    () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key) => {
        const mapEntry = state[key];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value) => params.append(key, value));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key);
        else
          params.set(key, mapEntry);
      });
      write(params);
    },
    { defer: false }
  );
  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate)
      updateState(params);
    window2.history.replaceState(
      window2.history.state,
      window2.document.title,
      window2.location.pathname + constructQuery(params)
    );
    resume();
  }
  function onChanged() {
    if (!enableWrite)
      return;
    write(read(), true);
  }
  useEventListener(window2, "popstate", onChanged, false);
  if (mode !== "history")
    useEventListener(window2, "hashchange", onChanged, false);
  const initial = read();
  if (initial.keys().next().value)
    updateState(initial);
  else
    Object.assign(state, initialValue);
  return state;
}
function useUserMedia(options = {}) {
  const [enabled, setEnabled] = createSignal(options.enabled ?? false);
  const [autoSwitch, setAutoSwitch] = createSignal(options.autoSwitch ?? true);
  const videoDeviceId = resolveAccessor(options.videoDeviceId);
  const audioDeviceId = resolveAccessor(options.audioDeviceId);
  const { navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a;
    return (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.getUserMedia;
  });
  const [stream, setStream] = createSignal();
  function getDeviceOptions(device) {
    if (device === "none" || device === false)
      return false;
    if (device == null)
      return true;
    return {
      deviceId: device
    };
  }
  async function _start() {
    if (!isSupported() || stream())
      return;
    const streamValue = await navigator.mediaDevices.getUserMedia({
      video: getDeviceOptions(videoDeviceId()),
      audio: getDeviceOptions(audioDeviceId())
    });
    setStream(streamValue);
    return streamValue;
  }
  async function _stop() {
    var _a;
    (_a = stream()) == null ? void 0 : _a.getTracks().forEach((t) => t.stop());
    setStream(void 0);
  }
  function stop() {
    _stop();
    setEnabled(false);
  }
  async function start() {
    await _start();
    if (stream())
      setEnabled(true);
    return stream();
  }
  async function restart() {
    _stop();
    return start();
  }
  createEffect(
    on(enabled, (v) => {
      if (v)
        _start();
      else
        _stop();
    })
  );
  createEffect(
    on([videoDeviceId, audioDeviceId], () => {
      if (autoSwitch() && stream())
        restart();
    })
  );
  return {
    isSupported,
    stream,
    start,
    stop,
    restart,
    videoDeviceId,
    audioDeviceId,
    enabled,
    setEnabled,
    autoSwitch,
    setAutoSwitch
  };
}
function useVibrate(options) {
  const { pattern = [], interval = 0, navigator = defaultNavigator } = options ?? {};
  const isSupported = useSupported(() => typeof navigator !== "undefined" && "vibrate" in navigator);
  const patternAccessor = resolveAccessor(pattern);
  let intervalControls;
  const vibrate = (pattern2 = patternAccessor()) => {
    if (isSupported())
      navigator.vibrate(pattern2);
  };
  const stop = () => {
    if (isSupported())
      navigator.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  };
  if (interval > 0) {
    intervalControls = useIntervalFn(vibrate, interval, {
      immediate: false,
      immediateCallback: false
    });
  }
  return {
    isSupported,
    pattern,
    intervalControls,
    vibrate,
    stop
  };
}
function useVirtualList(list, options) {
  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, setContainerRef } = "itemHeight" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);
  return {
    list: currentList,
    scrollTo,
    containerProps: {
      ref: (el) => setContainerRef(el),
      onScroll: () => {
        calculateRange();
      },
      style: containerStyle
    },
    wrapperProps
  };
}
function useVirtualListResourses(list) {
  const [containerRef, setContainerRef] = createSignal(null);
  const size = useElementSize(containerRef);
  const [currentList, setCurrentList] = createSignal([]);
  const [source, setSource] = toSignal(list);
  const [state, setState] = createSignal({ start: 0, end: 10 });
  return { state, setState, currentList, setCurrentList, source, setSource, setContainerRef, containerRef, size };
}
function createGetViewCapacity(state, source, itemSize) {
  return (containerSize) => {
    if (typeof itemSize === "number")
      return Math.ceil(containerSize / itemSize);
    const { start = 0 } = state();
    let sum = 0;
    let capacity = 0;
    for (let i = start; i < source().length; i++) {
      const size = itemSize(i);
      sum += size;
      capacity = i;
      if (sum > containerSize) {
        capacity = i;
        break;
      }
    }
    return capacity - start;
  };
}
function createGetOffset(source, itemSize) {
  return (scrollDirection) => {
    if (typeof itemSize === "number")
      return Math.floor(scrollDirection / itemSize) + 1;
    let sum = 0;
    let offset = 0;
    for (let i = 0; i < source().length; i++) {
      const size = itemSize(i);
      sum += size;
      if (sum >= scrollDirection) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
}
function createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, setState, source, setCurrentList }) {
  return () => {
    const element = containerRef();
    if (element) {
      const offset = getOffset(type === "vertical" ? element.scrollTop : element.scrollLeft);
      const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      setState({
        start: from < 0 ? 0 : from,
        end: to > source().length ? source().length : to
      });
      setCurrentList(
        source().slice(state().start, state().end).map((ele, index) => ({
          data: ele,
          index: index + state().start
        }))
      );
    }
  };
}
function createGetDistance(itemSize, source) {
  return (index) => {
    if (typeof itemSize === "number") {
      const size2 = index * itemSize;
      return size2;
    }
    const size = source().slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);
    return size;
  };
}
function useWatchForSizes(size, list, calculateRange) {
  watch(
    [size.width, size.height, resolveAccessor(list)],
    () => {
      calculateRange();
    },
    { defer: true }
  );
}
function createComputedTotalSize(itemSize, source) {
  return createMemo(() => {
    if (typeof itemSize === "number")
      return source().length * itemSize;
    return source().reduce((sum, _, index) => sum + itemSize(index), 0);
  });
}
const scrollToDictionaryForElementScrollKey = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef) {
  return (index) => {
    const el = containerRef();
    if (el) {
      el[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);
      calculateRange();
    }
  };
}
function useHorizontalVirtualList(options, list) {
  const resources = useVirtualListResourses(list);
  const { state, source, currentList, size, containerRef, setContainerRef } = resources;
  const containerStyle = { "overflow-x": "auto" };
  const { itemWidth, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
  const getOffset = createGetOffset(source, itemWidth);
  const calculateRange = createCalculateRange("horizontal", overscan, getOffset, getViewCapacity, resources);
  const getDistanceLeft = createGetDistance(itemWidth, source);
  const offsetLeft = createMemo(() => getDistanceLeft(state().start));
  const totalWidth = createComputedTotalSize(itemWidth, source);
  useWatchForSizes(size, list, calculateRange);
  const scrollTo = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef);
  const wrapperProps = createMemo(() => {
    return {
      style: {
        height: "100%",
        width: `${totalWidth() - offsetLeft()}px`,
        "margin-left": `${offsetLeft()}px`,
        display: "flex"
      }
    };
  });
  return {
    scrollTo,
    calculateRange,
    wrapperProps,
    containerStyle,
    setContainerRef,
    currentList,
    containerRef
  };
}
function useVerticalVirtualList(options, list) {
  const resources = useVirtualListResourses(list);
  const { state, source, currentList, size, containerRef, setContainerRef } = resources;
  const containerStyle = { "overflow-y": "auto" };
  const { itemHeight, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
  const getOffset = createGetOffset(source, itemHeight);
  const calculateRange = createCalculateRange("vertical", overscan, getOffset, getViewCapacity, resources);
  const getDistanceTop = createGetDistance(itemHeight, source);
  const offsetTop = createMemo(() => getDistanceTop(state().start));
  const totalHeight = createComputedTotalSize(itemHeight, source);
  useWatchForSizes(size, list, calculateRange);
  const scrollTo = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef);
  const wrapperProps = createMemo(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight() - offsetTop()}px`,
        "margin-top": `${offsetTop()}px`
      }
    };
  });
  return {
    calculateRange,
    scrollTo,
    containerStyle,
    wrapperProps,
    currentList,
    containerRef,
    setContainerRef
  };
}
const useWakeLock = (options = {}) => {
  const { navigator = defaultNavigator, document: document2 = defaultDocument } = options;
  let wakeLock;
  const isSupported = useSupported(() => navigator && "wakeLock" in navigator);
  const [isActive, setIsActive] = createSignal(false);
  async function onVisibilityChange() {
    if (!isSupported() || !wakeLock)
      return;
    if (document2 && document2.visibilityState === "visible")
      wakeLock = await navigator.wakeLock.request("screen");
    setIsActive(!wakeLock.released);
  }
  if (document2)
    useEventListener(document2, "visibilitychange", onVisibilityChange, { passive: true });
  async function request(type) {
    if (!isSupported())
      return;
    wakeLock = await navigator.wakeLock.request(type);
    setIsActive(!wakeLock.released);
  }
  async function release() {
    if (!isSupported() || !wakeLock)
      return;
    await wakeLock.release();
    setIsActive(!wakeLock.released);
    wakeLock = null;
  }
  return {
    isSupported,
    isActive,
    request,
    release
  };
};
const useWebNotification = (defaultOptions2 = {}) => {
  const { window: window2 = defaultWindow } = defaultOptions2;
  const isSupported = useSupported(() => !!window2 && "Notification" in window2);
  const [notification, setNotification] = createSignal(null);
  const requestPermission = async () => {
    if (!isSupported())
      return;
    if ("permission" in Notification && Notification.permission !== "denied")
      await Notification.requestPermission();
  };
  const onClick = createEventHook();
  const onShow = createEventHook();
  const onError = createEventHook();
  const onClose = createEventHook();
  const show = async (overrides) => {
    if (!isSupported())
      return;
    await requestPermission();
    const options = Object.assign({}, defaultOptions2, overrides);
    const notificationValue = new Notification(options.title ?? "", options);
    setNotification(notificationValue);
    notificationValue.onclick = (event) => onClick.trigger(event);
    notificationValue.onshow = (event) => onShow.trigger(event);
    notificationValue.onerror = (event) => onError.trigger(event);
    notificationValue.onclose = (event) => onClose.trigger(event);
    return notificationValue;
  };
  const close = () => {
    const notificationValue = notification();
    if (notificationValue)
      notificationValue.close();
    setNotification(null);
  };
  tryOnMount(async () => {
    if (isSupported())
      await requestPermission();
  });
  tryOnCleanup(close);
  if (isSupported() && window2) {
    const document2 = window2.document;
    useEventListener(document2, "visibilitychange", (e) => {
      e.preventDefault();
      if (document2.visibilityState === "visible") {
        close();
      }
    });
  }
  return {
    isSupported,
    notification,
    show,
    close,
    onClick,
    onShow,
    onError,
    onClose
  };
};
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options) {
  if (options === true)
    return {};
  return options;
}
function useWebSocket(url, options = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoClose = true,
    protocols = []
  } = options;
  const [data, setData] = createSignal(null);
  const [status, setStatus] = createSignal("CLOSED");
  const [wsAccessor, setWs] = createSignal();
  const urlAccessor = resolveAccessor(url);
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];
  let pongTimeoutWait;
  const close = (code = 1e3, reason) => {
    const wsRefVal = wsAccessor();
    if (!wsRefVal)
      return;
    explicitlyClosed = true;
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRefVal.close(code, reason);
  };
  const _sendBuffer = () => {
    const wsRefVal = wsAccessor();
    if (bufferedData.length && wsRefVal && status() === "OPEN") {
      for (const buffer of bufferedData)
        wsRefVal.send(buffer);
      bufferedData = [];
    }
  };
  const resetHeartbeat = () => {
    clearTimeout(pongTimeoutWait);
    pongTimeoutWait = void 0;
  };
  const send = (data2, useBuffer = true) => {
    const wsRefVal = wsAccessor();
    if (!wsRefVal || status() !== "OPEN") {
      if (useBuffer)
        bufferedData.push(data2);
      return false;
    }
    _sendBuffer();
    wsRefVal.send(data2);
    return true;
  };
  const _init = () => {
    const urlValue = urlAccessor();
    if (explicitlyClosed || typeof urlValue === "undefined")
      return;
    const ws = new WebSocket(urlValue, protocols);
    setWs(ws);
    setStatus("CONNECTING");
    ws.onopen = () => {
      setStatus("OPEN");
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();
      _sendBuffer();
    };
    ws.onclose = (ev) => {
      setStatus("CLOSED");
      setWs(void 0);
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);
      if (!explicitlyClosed && options.autoReconnect) {
        const { retries = -1, delay = 1e3, onFailed } = resolveNestedOptions(options.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    ws.onerror = (e) => {
      onError == null ? void 0 : onError(ws, e);
    };
    ws.onmessage = (e) => {
      if (options.heartbeat) {
        resetHeartbeat();
        const { message = DEFAULT_PING_MESSAGE } = resolveNestedOptions(options.heartbeat);
        if (e.data === message)
          return;
      }
      setData(e.data);
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  };
  if (options.heartbeat) {
    const {
      message = DEFAULT_PING_MESSAGE,
      interval = 1e3,
      pongTimeout = 1e3
    } = resolveNestedOptions(options.heartbeat);
    const { pause, resume } = useIntervalFn(
      () => {
        send(message, false);
        if (pongTimeoutWait != null)
          return;
        pongTimeoutWait = setTimeout(() => {
          close();
        }, pongTimeout);
      },
      interval,
      { immediate: false }
    );
    heartbeatPause = pause;
    heartbeatResume = resume;
  }
  if (autoClose) {
    useEventListener(window, "beforeunload", () => close());
    tryOnCleanup(close);
  }
  const open = () => {
    close();
    explicitlyClosed = false;
    retried = 0;
    _init();
  };
  if (immediate) {
    createEffect(on(urlAccessor, open));
  }
  return {
    data,
    status,
    close,
    send,
    open,
    ws: wsAccessor
  };
}
function useWebWorker(arg0, workerOptions, options) {
  const { window: window2 = defaultWindow } = options ?? {};
  const [data, setData] = createSignal(null);
  const [worker, setWorker] = createSignal();
  const post = function post2(val) {
    const workerValue = worker();
    if (!workerValue)
      return;
    workerValue.postMessage(val);
  };
  const terminate = function terminate2() {
    const workerValue = worker();
    if (!workerValue)
      return;
    workerValue.terminate();
  };
  if (window2) {
    if (isString(arg0))
      setWorker(new Worker(arg0, workerOptions));
    else if (isFunction(arg0))
      setWorker(arg0());
    else
      setWorker(arg0);
    const workValue = worker();
    workValue.onmessage = (e) => {
      setData(e.data);
    };
    tryOnCleanup(() => {
      if (worker())
        worker().terminate();
    });
  }
  return {
    data,
    post,
    terminate,
    worker
  };
}
const jobRunner = (userFunc) => (e) => {
  const userFuncArgs = e.data[0];
  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
    postMessage(["SUCCESS", result]);
  }).catch((error) => {
    postMessage(["ERROR", error]);
  });
};
const depsParser = (deps) => {
  if (deps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  return `importScripts(${depsString})`;
};
const createWorkerBlobUrl = (fn, deps) => {
  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
};
const useWebWorkerFn = (fn, options = {}) => {
  const { dependencies = [], timeout, window: window2 = defaultWindow } = options;
  const [worker, setWorker] = createSignal();
  const [workerStatus, setWorkerStatus] = createSignal("PENDING");
  const [promise, setPromise] = createSignal({});
  const [timeoutId, setTimeoutId] = createSignal();
  const workerTerminate = (status = "PENDING") => {
    const workerVal = worker();
    if ((workerVal == null ? void 0 : workerVal._url) && window2) {
      workerVal.terminate();
      URL.revokeObjectURL(workerVal._url);
      setPromise({});
      setWorker(void 0);
      window2.clearTimeout(timeoutId());
      setWorkerStatus(status);
    }
  };
  workerTerminate();
  tryOnCleanup(workerTerminate);
  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve = () => {
      }, reject = () => {
      } } = promise();
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;
        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject = () => {
      } } = promise();
      reject(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      setTimeoutId(setTimeout(() => workerTerminate("TIMEOUT_EXPIRED"), timeout));
    }
    return newWorker;
  };
  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    var _a;
    setPromise({
      resolve,
      reject
    });
    (_a = worker()) == null ? void 0 : _a.postMessage([[...fnArgs]]);
    setWorkerStatus("RUNNING");
  });
  const workerFn = (...fnArgs) => {
    if (workerStatus() === "RUNNING") {
      console.error("[useWebWorkerFn] You can only run one instance of the worker at a time.");
      return Promise.reject();
    }
    setWorker(generateWorker());
    return callWorker(...fnArgs);
  };
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
};
function useWindowFocus({ window: window2 = defaultWindow } = {}) {
  if (!window2) {
    const [res] = createSignal(false);
    return res;
  }
  const [focused, setFocused] = createSignal(window2.document.hasFocus());
  useEventListener(window2, "blur", () => {
    setFocused(false);
  });
  useEventListener(window2, "focus", () => {
    setFocused(true);
  });
  return focused;
}
function useWindowScroll({ window: window2 = defaultWindow } = {}) {
  if (!window2) {
    const [x2] = createSignal(0);
    const [y2] = createSignal(0);
    return {
      x: x2,
      y: y2
    };
  }
  const [x, setX] = createSignal(window2.scrollX);
  const [y, setY] = createSignal(window2.scrollY);
  useEventListener(
    window2,
    "scroll",
    () => {
      setX(window2.scrollX);
      setY(window2.scrollY);
    },
    {
      capture: false,
      passive: true
    }
  );
  return { x, y };
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Infinity,
    initialHeight = Infinity,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const [width, setWidth] = createSignal(initialWidth);
  const [height, setHeight] = createSignal(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        setWidth(window2.innerWidth);
        setHeight(window2.innerHeight);
      } else {
        setWidth(window2.document.documentElement.clientWidth);
        setHeight(window2.document.documentElement.clientHeight);
      }
    }
  };
  update();
  tryOnMount(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation)
    useEventListener("orientationchange", update, { passive: true });
  return { width, height };
}
export {
  DefaultMagicKeysAliasMap,
  StorageSerializers,
  SwipeDirection,
  TransitionPresets,
  createAsyncMemo as asyncMemo,
  breakpointsAntDesign,
  breakpointsBootstrapV5,
  breakpointsMasterCss,
  breakpointsQuasar,
  breakpointsSematic,
  breakpointsTailwind,
  breakpointsVuetify,
  cloneFnJSON,
  createAsyncMemo,
  createFetch,
  createUnAccessorFn,
  customStorageEventName,
  defaultDocument,
  defaultLocation,
  defaultNavigator,
  defaultWindow,
  formatTimeAgo,
  getSSRHandler,
  getSetCompat,
  mapGamepadToXbox360Controller,
  onClickOutside,
  onKeyDown,
  onKeyPressed,
  onKeyStroke,
  onKeyUp,
  onLongPress,
  onStartTyping,
  setSSRHandler,
  useActiveElement,
  useAsyncState,
  useBase64,
  useBattery,
  useBluetooth,
  useBreakpoints,
  useBroadcastChannel,
  useBrowserLocation,
  useClipboard,
  useCloned,
  useColorMode,
  useConfirmDialog,
  useCssTransition,
  useCssVar,
  useCycleList,
  useDark,
  useDebouncedHistoryTravel,
  useDeviceMotion,
  useDeviceOrientation,
  useDevicePixelRatio,
  useDevicesList,
  useDisplayMedia,
  useDocumentVisibility,
  useDraggable,
  useDropZone,
  useElementBounding,
  useElementByPoint,
  useElementHover,
  useElementSize,
  useElementVisibility,
  useEventBus,
  useEventListener,
  useEventSource,
  useEyeDropper,
  useFavicon,
  useFetch,
  useFileDialog,
  useFileSystemAccess,
  useFocus,
  useFocusWithin,
  useFps,
  useFullscreen,
  useGamepad,
  useGeolocation,
  useHistoryTravel,
  useIdle,
  useImage,
  useInfiniteScroll,
  useIntersectionObserver,
  useKeyModifier,
  useLocalStorage,
  useMagicKeys,
  useManualHistoryTravel,
  useMediaControls,
  useMediaQuery,
  useMemoize,
  useMemory,
  useMounted,
  useMouse,
  useMouseInElement,
  useMousePressed,
  useMutationObserver,
  useNavigatorLanguage,
  useNetwork,
  useNow,
  useObjectUrl,
  useOffsetPagination,
  useOnline,
  usePageLeave,
  useParallax,
  usePermission,
  usePointer,
  usePointerLock,
  usePointerSwipe,
  usePreferredColorScheme,
  usePreferredContrast,
  usePreferredDark,
  usePreferredLanguages,
  usePreferredReducedMotion,
  usePrevious,
  useRafFn,
  useResizeObserver,
  useScreenOrientation,
  useScreenSafeArea,
  useScriptTag,
  useScroll,
  useScrollLock,
  useSessionStorage,
  useShare,
  useSpeechRecognition,
  useSpeechSynthesis,
  useStepper,
  useStorage,
  useStorageAsync,
  useStyleTag,
  useSupported,
  useSwipe,
  useTextDirection,
  useTextSelection,
  useTextareaAutoSize,
  useThrottledHistoryTravel,
  useTimeAgo,
  useTimestamp,
  useTitle,
  useUrlSearchParams,
  useUserMedia,
  useVibrate,
  useVirtualList,
  useWakeLock,
  useWebNotification,
  useWebSocket,
  useWebWorker,
  useWebWorkerFn,
  useWindowFocus,
  useWindowScroll,
  useWindowSize
};
