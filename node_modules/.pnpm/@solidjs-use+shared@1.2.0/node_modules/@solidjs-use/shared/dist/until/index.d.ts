import { MaybeAccessor, ElementOf, EffectOnDeps } from '../utils/types.js';
import { Owner } from 'solid-js';
import 'solid-js/types/reactive/signal';

interface UntilToMatchOptions {
    /**
     * Milliseconds timeout for promise to resolve/reject if the when condition does not meet.
     * 0 for never timed out
     *
     * @default 0
     */
    timeout?: number;
    /**
     * Reject the promise when timeout
     *
     * @default false
     */
    throwOnTimeout?: boolean;
}
interface UntilBaseInstance<T, Not extends boolean = false> {
    toMatch<U extends T = T>(condition: (v: T) => v is U, options?: UntilToMatchOptions): Not extends true ? Promise<Exclude<T, U>> : Promise<U>;
    toMatch(condition: (v: T) => boolean, options?: UntilToMatchOptions): Promise<T>;
    changed: (options?: UntilToMatchOptions) => Promise<T>;
    changedTimes: (n?: number, options?: UntilToMatchOptions) => Promise<T>;
}
type Falsy = false | void | null | undefined | 0 | 0n | '';
interface UntilValueInstance<T, Not extends boolean = false> extends UntilBaseInstance<T, Not> {
    readonly not: UntilValueInstance<T, Not extends true ? false : true>;
    toBe: <P = T>(value: MaybeAccessor<P>, options?: UntilToMatchOptions) => Not extends true ? Promise<T> : Promise<P>;
    toBeTruthy: (options?: UntilToMatchOptions) => Not extends true ? Promise<T & Falsy> : Promise<Exclude<T, Falsy>>;
    toBeNull: (options?: UntilToMatchOptions) => Not extends true ? Promise<Exclude<T, null>> : Promise<null>;
    toBeUndefined: (options?: UntilToMatchOptions) => Not extends true ? Promise<Exclude<T, undefined>> : Promise<undefined>;
    toBeNaN: (options?: UntilToMatchOptions) => Promise<T>;
}
interface UntilArrayInstance<T> extends UntilBaseInstance<T> {
    readonly not: UntilArrayInstance<T>;
    toContains: (value: MaybeAccessor<ElementOf<T>>, options?: UntilToMatchOptions) => Promise<T>;
}
/**
 * Promised one-time watch for changes
 *
 * ```
 * const { count } = useCounter()
 *
 * await until(count).toMatch(v => v > 7)
 *
 * alert('Counter is now larger than 7!')
 * ```
 */
declare function until<T extends unknown[]>(r: EffectOnDeps<T> | MaybeAccessor<T>, owner?: Owner | null): UntilArrayInstance<T>;
declare function until<T>(r: EffectOnDeps<T> | MaybeAccessor<T>, owner?: Owner | null): UntilValueInstance<T>;

export { UntilArrayInstance, UntilBaseInstance, UntilToMatchOptions, UntilValueInstance, until };
