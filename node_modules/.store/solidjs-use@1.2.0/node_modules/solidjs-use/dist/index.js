"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const shared = require("@solidjs-use/shared");
const solidJs = require("solid-js");
const solidToVue = require("@solidjs-use/shared/solid-to-vue");
const store = require("solid-js/store");
function watchEffect(callback) {
  let preCleanupFn = () => {
  };
  const onCleanup = (cleanupFn) => {
    preCleanupFn();
    preCleanupFn = cleanupFn;
  };
  solidJs.createEffect(() => {
    callback(onCleanup);
  });
}
function createAsyncMemo(evaluationCallback, initialState, optionsOrSetter) {
  let options;
  if (shared.isFunction(optionsOrSetter)) {
    options = {
      setEvaluating: optionsOrSetter
    };
  } else {
    options = optionsOrSetter ?? {};
  }
  const { setEvaluating = void 0, onError = shared.noop } = options;
  const [current, setCurrent] = solidJs.createSignal(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (setEvaluating) {
      setEvaluating(true);
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (setEvaluating) {
            setEvaluating(false);
          }
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        setCurrent(() => result);
    } catch (e) {
      onError(e);
    } finally {
      if (setEvaluating && counterAtBeginning === counter)
        setEvaluating(false);
      hasFinished = true;
    }
  });
  return current;
}
const createUnAccessorFn = (fn) => {
  return function(...args) {
    return fn.apply(
      this,
      args.map((i) => shared.unAccessor(i))
    );
  };
};
const defaultWindow = shared.isClient ? window : void 0;
const defaultDocument = shared.isClient ? window.document : void 0;
const defaultNavigator = shared.isClient ? window.navigator : void 0;
const defaultLocation = shared.isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events2;
  let listeners;
  let options;
  if (shared.isString(args[0]) || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events2, listeners, options] = args;
  }
  if (!target)
    return shared.noop;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = shared.watch(
    () => [shared.unAccessor(target), shared.unAccessor(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        })
      );
    }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  shared.tryOnCleanup(stop);
  return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
  if (!window2)
    return;
  if (shared.isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", shared.noop));
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some(
          (el2) => el2 === event.target || event.composedPath().includes(el2)
        );
      }
      const el = shared.unAccessor(target2);
      return el && (event.target === el || event.composedPath().includes(el));
    });
  };
  const listener = (event) => {
    const el = shared.unAccessor(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(
      window2,
      "pointerdown",
      (e) => {
        const el = shared.unAccessor(target);
        if (el)
          shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
      },
      { passive: true }
    ),
    detectIframe && useEventListener(window2, "blur", (event) => {
      var _a;
      const el = shared.unAccessor(target);
      if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
        handler(event);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
const createKeyPredicate = (keyFilter) => {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
};
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const { target = defaultWindow, eventName = "keydown", passive = false } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keydown" });
}
function onKeyPressed(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keypress" });
}
function onKeyUp(key, handler, options = {}) {
  return onKeyStroke(key, handler, { ...options, eventName: "keyup" });
}
const DEFAULT_DELAY = 500;
function onLongPress(target, handler, options) {
  var _a, _b;
  const elementRef = shared.resolveAccessor(target);
  let timeout;
  function clear() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  }
  function onDown(ev) {
    var _a2, _b2, _c;
    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef())
      return;
    clear();
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    timeout = setTimeout(() => handler(ev), (options == null ? void 0 : options.delay) ?? DEFAULT_DELAY);
  }
  const listenerOptions = {
    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once
  };
  useEventListener(elementRef, "pointerdown", onDown, listenerOptions);
  useEventListener(elementRef, "pointerup", clear, listenerOptions);
  useEventListener(elementRef, "pointerleave", clear, listenerOptions);
}
const isFocusedElementEditable = () => {
  const { activeElement, body } = document;
  if (!activeElement)
    return false;
  if (activeElement === body)
    return false;
  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return activeElement.hasAttribute("contenteditable");
};
const isTypedCharValid = ({ keyCode, metaKey, ctrlKey, altKey }) => {
  if (metaKey || ctrlKey || altKey)
    return false;
  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)
    return true;
  if (keyCode >= 65 && keyCode <= 90)
    return true;
  return false;
};
function onStartTyping(callback, options = {}) {
  const { document: document2 = defaultDocument } = options;
  const keydown = (event) => {
    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);
  };
  if (document2)
    useEventListener(document2, "keydown", keydown, { passive: true });
}
function useActiveElement(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const document2 = options.document ?? (window2 == null ? void 0 : window2.document);
  const [activeElement, setActiveElement] = solidJs.createSignal(
    document2 == null ? void 0 : document2.activeElement
  );
  if (window2) {
    useEventListener(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        setActiveElement(() => document2 == null ? void 0 : document2.activeElement);
      },
      true
    );
    useEventListener(
      window2,
      "focus",
      () => {
        setActiveElement(() => document2 == null ? void 0 : document2.activeElement);
      },
      true
    );
  }
  return activeElement;
}
function useAsyncState(promise, initialState, options) {
  const {
    immediate = true,
    delay = 0,
    onError = shared.noop,
    onSuccess = shared.noop,
    resetOnExecute = true,
    throwError
  } = options ?? {};
  const [state, setState] = solidJs.createSignal(initialState);
  const [isReady, setReady] = solidJs.createSignal(false);
  const [isLoading, setLoading] = solidJs.createSignal(false);
  const [error, setError] = solidJs.createSignal(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      setState(() => initialState);
    setError(void 0);
    setReady(false);
    setLoading(true);
    if (delay2 > 0)
      await shared.promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      setState(() => data);
      setReady(true);
      onSuccess(data);
    } catch (e) {
      setError(e);
      onError(e);
      if (throwError)
        throw e;
    } finally {
      setLoading(false);
    }
    return state();
  }
  if (immediate)
    execute(delay);
  return {
    state,
    isReady,
    isLoading,
    error,
    execute
  };
}
const defaults = {
  array: (v) => JSON.stringify(v),
  object: (v) => JSON.stringify(v),
  set: (v) => JSON.stringify(Array.from(v)),
  map: (v) => JSON.stringify(Object.fromEntries(v)),
  null: () => ""
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults.null;
  if (target instanceof Map)
    return defaults.map;
  else if (target instanceof Set)
    return defaults.set;
  else if (Array.isArray(target))
    return defaults.array;
  return defaults.object;
}
function useBase64(target, options) {
  const [base64, setBase64] = solidJs.createSignal("");
  const [promise, setPromise] = solidJs.createSignal();
  function execute() {
    if (!shared.isClient)
      return;
    const promiseVal = new Promise((resolve, reject) => {
      try {
        const _target = shared.unAccessor(target);
        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) ?? getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    setPromise(() => promiseVal);
    promiseVal.then((res) => setBase64(res));
    return promiseVal;
  }
  if (solidToVue.isAccessor(target)) {
    solidJs.createEffect(solidJs.on(target, execute));
  } else {
    execute();
  }
  return {
    base64,
    promise,
    execute
  };
}
function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      resolve(e.target.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function useSupported(callback, sync = false) {
  const [isSupported, setIsSupport] = solidJs.createSignal(Boolean(callback()));
  const update = () => setIsSupport(Boolean(callback()));
  shared.tryOnMount(update, sync);
  return isSupported;
}
function useBattery({ navigator = defaultNavigator } = {}) {
  const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported = useSupported(() => navigator && "getBattery" in navigator);
  const [charging, setCharging] = solidJs.createSignal(false);
  const [chargingTime, setChargingTime] = solidJs.createSignal(0);
  const [dischargingTime, setDischargingTime] = solidJs.createSignal(0);
  const [level, setLevel] = solidJs.createSignal(1);
  let battery;
  function updateBatteryInfo() {
    setCharging(this.charging);
    setChargingTime(this.chargingTime || 0);
    setDischargingTime(this.dischargingTime || 0);
    setLevel(this.level);
  }
  const owner = solidJs.getOwner();
  if (isSupported()) {
    navigator.getBattery().then((_battery) => {
      battery = _battery;
      updateBatteryInfo.call(battery);
      for (const event of events2) {
        solidJs.runWithOwner(owner, () => {
          useEventListener(battery, event, updateBatteryInfo, { passive: true });
        });
      }
    });
  }
  return {
    isSupported,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}
function useBluetooth(options) {
  let { acceptAllDevices = false } = options ?? {};
  const { filters = void 0, optionalServices = void 0, navigator = defaultNavigator } = options ?? {};
  const isSupported = useSupported(() => navigator && "bluetooth" in navigator);
  const [device, setDevice] = solidJs.createSignal(void 0);
  const [error, setError] = solidJs.createSignal(null);
  const [server, setServer] = solidJs.createSignal();
  solidJs.createEffect(
    solidJs.on(
      device,
      () => {
        connectToBluetoothGATTServer();
      },
      { defer: true }
    )
  );
  async function requestDevice() {
    if (!isSupported())
      return;
    setError(null);
    if (filters && filters.length > 0)
      acceptAllDevices = false;
    try {
      const deviceVal = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
      setDevice(deviceVal);
    } catch (err) {
      setError(err);
    }
  }
  const isConnected = solidJs.createMemo(() => {
    var _a;
    return ((_a = server()) == null ? void 0 : _a.connected) ?? false;
  });
  async function connectToBluetoothGATTServer() {
    setError(null);
    const deviceVal = device();
    if (deviceVal == null ? void 0 : deviceVal.gatt) {
      deviceVal == null ? void 0 : deviceVal.addEventListener("gattserverdisconnected", () => {
      });
      try {
        setServer(await deviceVal.gatt.connect());
      } catch (err) {
        setError(err);
      }
    }
  }
  shared.tryOnMount(() => {
    var _a;
    const deviceVal = device();
    if (deviceVal)
      (_a = deviceVal.gatt) == null ? void 0 : _a.connect();
  });
  shared.tryOnCleanup(() => {
    var _a;
    const deviceVal = device();
    if (deviceVal)
      (_a = deviceVal.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported,
    isConnected,
    // Device:
    device,
    requestDevice,
    // Server:
    server,
    // Errors:
    error
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const [matches, setMatches] = solidJs.createSignal(false);
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", update);
    else
      mediaQuery.removeListener(update);
  };
  const update = () => {
    if (!isSupported())
      return;
    cleanup();
    mediaQuery = window2.matchMedia(shared.resolveAccessor(query)());
    setMatches(mediaQuery.matches);
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update);
    else
      mediaQuery.addListener(update);
  };
  solidJs.createEffect(update);
  shared.tryOnCleanup(() => cleanup());
  return matches;
}
const breakpointsTailwind = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetify = {
  xs: 600,
  sm: 960,
  md: 1264,
  lg: 1904
};
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 600,
  sm: 1024,
  md: 1440,
  lg: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
const breakpointsMasterCss = {
  "3xs": 360,
  "2xs": 480,
  xs: 600,
  sm: 768,
  md: 1024,
  lg: 1280,
  xl: 1440,
  "2xl": 1600,
  "3xl": 1920,
  "4xl": 2560
};
function useBreakpoints(breakpoints, options = {}) {
  function getValue2(k, delta) {
    let v = breakpoints[k];
    if (delta != null)
      v = shared.increaseWithUnit(v, delta);
    if (typeof v === "number")
      v = `${v}px`;
    return v;
  }
  const { window: window2 = defaultWindow } = options;
  function match(query) {
    if (!window2)
      return false;
    return window2.matchMedia(query).matches;
  }
  const greaterOrEqual = (k) => {
    return useMediaQuery(`(min-width: ${getValue2(k)})`, options);
  };
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      value: greaterOrEqual(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  return {
    greater(k) {
      return useMediaQuery(`(min-width: ${getValue2(k, 0.1)})`, options);
    },
    greaterOrEqual,
    smaller(k) {
      return useMediaQuery(`(max-width: ${getValue2(k, -0.1)})`, options);
    },
    smallerOrEqual(k) {
      return useMediaQuery(`(max-width: ${getValue2(k)})`, options);
    },
    between(a, b) {
      return useMediaQuery(`(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`, options);
    },
    isGreater(k) {
      return match(`(min-width: ${getValue2(k, 0.1)})`);
    },
    isGreaterOrEqual(k) {
      return match(`(min-width: ${getValue2(k)})`);
    },
    isSmaller(k) {
      return match(`(max-width: ${getValue2(k, -0.1)})`);
    },
    isSmallerOrEqual(k) {
      return match(`(max-width: ${getValue2(k)})`);
    },
    isInBetween(a, b) {
      return match(`(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`);
    },
    ...shortcutMethods
  };
}
const useBroadcastChannel = (options) => {
  const { name, window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "BroadcastChannel" in window2);
  const [isClosed, setClosed] = solidJs.createSignal(false);
  const [channel, setChannel] = solidJs.createSignal();
  const [data, setData] = solidJs.createSignal();
  const [error, setError] = solidJs.createSignal();
  const post = (data2) => {
    const channelVal = channel();
    if (channelVal)
      channelVal.postMessage(data2);
  };
  const close = () => {
    const channelVal = channel();
    if (channelVal)
      channelVal.close();
    setClosed(true);
  };
  if (isSupported()) {
    shared.tryOnMount(() => {
      setError(null);
      const channelVal = new BroadcastChannel(name);
      setChannel(() => channelVal);
      channelVal.addEventListener(
        "message",
        (e) => {
          setData(e.data);
        },
        { passive: true }
      );
      channelVal.addEventListener(
        "messageerror",
        (e) => {
          setError(e);
        },
        { passive: true }
      );
      channelVal.addEventListener("close", () => {
        setClosed(true);
      });
    });
  }
  shared.tryOnCleanup(() => {
    close();
  });
  return {
    isSupported,
    channel,
    data,
    post,
    close,
    error,
    isClosed
  };
};
function useBrowserLocation({ window: window2 = defaultWindow } = {}) {
  const buildState = (trigger) => {
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) ?? {};
    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window2 == null ? void 0 : window2.location) ?? {};
    return {
      trigger,
      state: state2,
      length,
      hash,
      host,
      hostname,
      href,
      origin,
      pathname,
      port,
      protocol,
      search
    };
  };
  const [state, setState] = solidJs.createSignal(buildState("load"));
  if (window2) {
    useEventListener(window2, "popstate", () => setState(buildState("popstate")), { passive: true });
    useEventListener(window2, "hashchange", () => setState(buildState("hashchange")), { passive: true });
  }
  return state;
}
function useClipboard(options = {}) {
  const { navigator = defaultNavigator, read = false, source, copiedDuring = 1500, legacy = false } = options;
  const events2 = ["copy", "cut"];
  const isClipboardApiSupported = useSupported(() => navigator && "clipboard" in navigator);
  const isSupported = solidJs.createMemo(() => isClipboardApiSupported() || legacy);
  const [text, setText] = solidJs.createSignal("");
  const [copied, setCopied] = solidJs.createSignal(false);
  const timeout = shared.useTimeoutFn(() => setCopied(false), copiedDuring);
  function updateText() {
    if (isClipboardApiSupported()) {
      navigator.clipboard.readText().then((value) => {
        setText(value);
      });
    } else {
      setText(legacyRead());
    }
  }
  if (isSupported() && read) {
    for (const event of events2)
      useEventListener(event, updateText);
  }
  async function copy(value = shared.unAccessor(source)) {
    if (isSupported() && value != null) {
      if (isClipboardApiSupported())
        await navigator.clipboard.writeText(value);
      else
        legacyCopy(value);
      setText(value);
      setCopied(true);
      timeout.start();
    }
  }
  function legacyCopy(value) {
    const ta = document.createElement("textarea");
    ta.value = value ?? "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacyRead() {
    var _a, _b;
    return ((_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) ?? "";
  }
  return {
    isSupported,
    text,
    copied,
    copy
  };
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
  const [cloned, setCloned] = solidJs.createSignal({});
  const { manual, clone = cloneFnJSON, defer = false } = options;
  function sync() {
    setCloned(clone(shared.unAccessor(source)));
  }
  if (!manual && solidToVue.isAccessor(source)) {
    solidJs.createEffect(solidJs.on(source, sync, { defer }));
  } else {
    sync();
  }
  return { cloned, setCloned, sync };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__solidjs-use_ssr_handlers__";
_global[globalKey] = _global[globalKey] ?? {};
const handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] ?? fallback;
}
function setSSRHandler(key, fn) {
  handlers[key] = fn;
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  const {
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const [data, setData] = solidToVue.toSignal(defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => defaultWindow == null ? void 0 : defaultWindow.localStorage)();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return solidToVue.isAccessor(defaults2) ? data : [data, setData];
  const rawInit = shared.unAccessor(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = options.serializer ?? StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = shared.pausableWatch(data, () => write(data()), {
    eventFilter,
    defer: false
  });
  if (window2 && listenToStorageChanges) {
    useEventListener(window2, "storage", update);
    useEventListener(window2, customStorageEventName, updateFromCustomEvent);
  }
  update();
  return solidToVue.isAccessor(defaults2) ? data : [data, setData];
  function write(v) {
    try {
      if (v == null) {
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v);
        const oldValue = storage.getItem(key);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          if (window2) {
            window2.dispatchEvent(
              new CustomEvent(customStorageEventName, {
                detail: {
                  key,
                  oldValue,
                  newValue: serialized,
                  storageArea: storage
                }
              })
            );
          }
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit !== null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (solidToVue.isFunction(mergeDefaults))
        return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    }
    return serializer.read(rawValue);
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      setData(() => rawInit);
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      setData(read(event));
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        solidToVue.nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
}
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "solidjs-use-color-scheme",
    listenToStorageChanges = true,
    storageSignal,
    emitAuto
  } = options;
  const modes = {
    auto: "",
    light: "light",
    dark: "dark",
    ...options.modes ?? {}
  };
  const preferredDark = usePreferredDark({ window: window2 });
  const preferredMode = solidJs.createMemo(() => preferredDark() ? "dark" : "light");
  const [store2, setStore] = storageSignal ?? (storageKey == null ? solidJs.createSignal(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const [state, setState] = solidToVue.writableComputed({
    get() {
      return store2() === "auto" && !emitAuto ? preferredMode() : store2();
    },
    set(v) {
      setStore(v);
    }
  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value) => {
    const el = window2 == null ? void 0 : window2.document.querySelector(selector2);
    if (!el)
      return;
    if (attribute2 === "class") {
      const current = value.split(/\s/g);
      Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v) => {
        if (current.includes(v))
          el.classList.add(v);
        else
          el.classList.remove(v);
      });
    } else {
      el.setAttribute(attribute2, value);
    }
  });
  function defaultOnChanged(mode) {
    const resolvedMode = mode === "auto" ? preferredMode() : mode;
    updateHTMLAttrs(selector, attribute, modes[resolvedMode] ?? resolvedMode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  solidJs.createEffect(solidJs.on(state, onChanged));
  if (emitAuto) {
    solidJs.createEffect(solidJs.on(preferredMode, () => onChanged(state())));
  }
  shared.tryOnCleanup(() => onChanged(state()));
  return [state, setState];
}
function useConfirmDialog(setRevealed) {
  const confirmHook = shared.createEventHook();
  const cancelHook = shared.createEventHook();
  const revealHook = shared.createEventHook();
  let revealed;
  if (setRevealed === void 0) {
    [revealed, setRevealed] = solidJs.createSignal(false);
  }
  let _resolve = shared.noop;
  const reveal = (data) => {
    revealHook.trigger(data);
    setRevealed == null ? void 0 : setRevealed(true);
    return new Promise((resolve) => {
      _resolve = resolve;
    });
  };
  const confirm = (data) => {
    setRevealed == null ? void 0 : setRevealed(false);
    confirmHook.trigger(data);
    _resolve({ data, isCanceled: false });
  };
  const cancel = (data) => {
    setRevealed == null ? void 0 : setRevealed(false);
    cancelHook.trigger(data);
    _resolve({ data, isCanceled: true });
  };
  const res = {
    reveal,
    confirm,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
  if (revealed) {
    return {
      isRevealed: reveal,
      ...res
    };
  }
  return res;
}
function useRafFn(fn, options = {}) {
  const { immediate = true, window: window2 = defaultWindow } = options;
  const [isActive, setIsActive] = solidJs.createSignal(false);
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp) {
    if (!isActive() || !window2)
      return;
    const delta = timestamp - previousFrameTimestamp;
    fn({ delta, timestamp });
    previousFrameTimestamp = timestamp;
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive() && window2) {
      setIsActive(true);
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    setIsActive(false);
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  shared.tryOnCleanup(pause);
  return {
    isActive,
    pause,
    resume
  };
}
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
const TransitionPresets = {
  linear: shared.identity,
  ..._TransitionPresets
};
function createEasingFunction([p0, p1, p2, p3]) {
  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
  const b = (a1, a2) => 3 * a2 - 6 * a1;
  const c = (a1) => 3 * a1;
  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
  const getTforX = (x) => {
    let aGuessT = x;
    for (let i = 0; i < 4; ++i) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}
function useCssTransition(source, options = {}) {
  const {
    delay = 0,
    disabled = false,
    duration = 1e3,
    onFinished = shared.noop,
    onStarted = shared.noop,
    transition = shared.identity
  } = options;
  const currentTransition = solidJs.createMemo(() => {
    const t = transition.length ? transition : shared.unAccessor(transition);
    return shared.isFunction(t) ? t : createEasingFunction(t);
  });
  const sourceValue = solidJs.createMemo(() => {
    const s = shared.unAccessor(source);
    return shared.isNumber(s) ? s : s.map(shared.unAccessor);
  });
  const sourceVector = solidJs.createMemo(
    () => shared.isNumber(sourceValue()) ? [sourceValue()] : sourceValue()
  );
  const [outputVector, setOutputVector] = solidJs.createSignal(sourceVector().slice(0));
  let currentDuration;
  let diffVector;
  let endAt;
  let startAt;
  let startVector;
  const { resume, pause } = useRafFn(
    () => {
      const now = Date.now();
      const progress = shared.clamp(1 - (endAt - now) / currentDuration, 0, 1);
      setOutputVector(
        startVector.map((val, i) => {
          return val + (diffVector[i] ?? 0) * currentTransition()(progress);
        })
      );
      if (progress >= 1) {
        pause();
        onFinished();
      }
    },
    { immediate: false }
  );
  const start = () => {
    pause();
    currentDuration = shared.unAccessor(duration);
    diffVector = outputVector().map((n, i) => (sourceVector()[i] ?? 0) - (outputVector()[i] ?? 0));
    startVector = outputVector().slice(0);
    startAt = Date.now();
    endAt = startAt + currentDuration;
    resume();
    onStarted();
  };
  const timeout = shared.useTimeoutFn(start, delay, { immediate: false });
  solidJs.createEffect(
    solidJs.on(
      sourceVector,
      () => {
        if (shared.unAccessor(disabled))
          return;
        if (shared.unAccessor(delay) <= 0)
          start();
        else
          timeout.start();
      },
      { defer: true }
    )
  );
  solidJs.createEffect(
    solidJs.on(
      shared.resolveAccessor(disabled),
      (v) => {
        if (v) {
          setOutputVector(sourceVector().slice(0));
          pause();
        }
      },
      { defer: true }
    )
  );
  return solidJs.createMemo(() => {
    const targetVector = shared.unAccessor(disabled) ? sourceVector : outputVector;
    return shared.isNumber(sourceValue()) ? targetVector()[0] : targetVector();
  });
}
function useCssVar(prop, target, { window: window2 = defaultWindow, initialValue = "" } = {}) {
  const variableSignal = solidJs.createSignal(initialValue);
  const [variable, setVariable] = variableSignal;
  const elAccessor = solidJs.createMemo(() => {
    var _a;
    return shared.unAccessor(target) ?? ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  solidJs.createEffect(
    solidJs.on([elAccessor, shared.resolveAccessor(prop)], ([el, prop2]) => {
      var _a;
      if (el && window2) {
        const value = (_a = window2.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();
        setVariable(value || initialValue);
      }
    })
  );
  solidJs.createEffect(
    solidJs.on(
      variable,
      (val) => {
        var _a, _b;
        if ((_a = elAccessor()) == null ? void 0 : _a.style) {
          (_b = elAccessor()) == null ? void 0 : _b.style.setProperty(shared.unAccessor(prop), val);
        }
      },
      { defer: true }
    )
  );
  return variableSignal;
}
function useCycleList(list, options) {
  const [state, setState] = solidToVue.toSignal((options == null ? void 0 : options.initialValue) ?? list[0]);
  const index = solidJs.createMemo(() => {
    let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state(), list) : list.indexOf(state());
    if (index2 < 0)
      index2 = (options == null ? void 0 : options.fallbackIndex) ?? 0;
    return index2;
  });
  function set(i) {
    const length = list.length;
    const index2 = (i % length + length) % length;
    const value = list[index2];
    setState(() => value);
    return value;
  }
  function shift(delta = 1) {
    return set(index() + delta);
  }
  function next(n = 1) {
    return shift(n);
  }
  function prev(n = 1) {
    return shift(-n);
  }
  return {
    state,
    setState,
    index,
    next,
    prev
  };
}
function useDark(options = {}) {
  const { valueDark = "dark", valueLight = "", window: window2 = defaultWindow } = options;
  const [mode, setMode] = useColorMode({
    ...options,
    onChanged: (mode2, defaultHandler) => {
      var _a;
      if (options.onChanged)
        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === "dark");
      else
        defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  });
  const preferredDark = usePreferredDark({ window: window2 });
  const isDark = solidToVue.writableComputed({
    get() {
      return mode() === "dark";
    },
    set(v) {
      if (v === preferredDark())
        setMode("auto");
      else
        setMode(v ? "dark" : "light");
    }
  });
  return isDark;
}
const fnBypass = (v) => v;
const fnSetSource = (setSource, value) => setSource(value);
function defaultDump(clone) {
  return clone ? shared.isFunction(clone) ? clone : cloneFnJSON : fnBypass;
}
function defaultParse(clone) {
  return clone ? shared.isFunction(clone) ? clone : cloneFnJSON : fnBypass;
}
function useManualHistoryTravel(source, options = {}) {
  const [getSourceVal, setSourceVal] = solidToVue.toSignal(source);
  const {
    clone = false,
    dump = defaultDump(clone),
    parse = defaultParse(clone),
    setSource = fnSetSource
  } = options;
  function _createHistoryRecord() {
    return {
      snapshot: dump(getSourceVal()),
      timestamp: shared.timestamp()
    };
  }
  const [last, setLast] = solidJs.createSignal(_createHistoryRecord());
  const [undoStack, setUndoStack] = solidJs.createSignal([]);
  const [redoStack, setRedoStack] = solidJs.createSignal([]);
  const _setSource = (record) => {
    setSource(setSourceVal, parse(record.snapshot));
    setLast(record);
  };
  const commit = () => {
    setUndoStack((stacks) => {
      return [last(), ...stacks];
    });
    setLast(_createHistoryRecord());
    if (options.capacity && undoStack().length > options.capacity) {
      setUndoStack(([...stacks]) => {
        stacks.splice(options.capacity, Infinity);
        return stacks;
      });
    }
    if (redoStack().length) {
      setRedoStack(([...stacks]) => {
        stacks.splice(0, redoStack().length);
        return stacks;
      });
    }
  };
  const clear = () => {
    setUndoStack([]);
    setRedoStack([]);
  };
  const undo = () => {
    const state = undoStack()[0];
    setUndoStack(([...stacks]) => {
      stacks.shift();
      return stacks;
    });
    if (state) {
      setRedoStack((stacks) => {
        return [last(), ...stacks];
      });
      _setSource(state);
    }
  };
  const redo = () => {
    const state = redoStack()[0];
    setRedoStack(([...stacks]) => {
      stacks.shift();
      return stacks;
    });
    if (state) {
      setUndoStack((stacks) => {
        return [last(), ...stacks];
      });
      _setSource(state);
    }
  };
  const reset = () => {
    _setSource(last());
  };
  const history = solidJs.createMemo(() => [last(), ...undoStack()]);
  const canUndo = solidJs.createMemo(() => undoStack().length > 0);
  const canRedo = solidJs.createMemo(() => redoStack().length > 0);
  if (solidToVue.isSignal(source)) {
    return {
      source: getSourceVal,
      undoStack,
      redoStack,
      last,
      history,
      canUndo,
      canRedo,
      clear,
      commit,
      reset,
      undo,
      redo
    };
  }
  return {
    source: getSourceVal,
    undoStack,
    redoStack,
    last,
    history,
    canUndo,
    canRedo,
    clear,
    commit
  };
}
function useHistoryTravel(source, options = {}) {
  const { eventFilter } = options;
  const [sourceAccessor] = solidToVue.toSignal(source);
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = shared.pausableFilter(eventFilter);
  const { ignoreUpdates, stop } = shared.watchIgnorable(sourceAccessor, commit, { eventFilter: composedFilter, defer: true });
  function setSource(setSource2, value) {
    ignoreUpdates(() => {
      setSource2(value);
    });
  }
  const manualHistory = useManualHistoryTravel(source, { ...options, clone: options.clone, setSource });
  const { clear, commit: manualCommit } = manualHistory;
  function commit() {
    manualCommit();
  }
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  function batch(fn) {
    let canceled = false;
    const cancel = () => canceled = true;
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  function dispose() {
    stop();
    clear();
  }
  return {
    ...manualHistory,
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  };
}
function useDebouncedHistoryTravel(source, options = {}) {
  const filter = options.debounce ? shared.debounceFilter(options.debounce) : void 0;
  const history = useHistoryTravel(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
function useDeviceMotion(options = {}) {
  const { window: window2 = defaultWindow, eventFilter = shared.bypassFilter } = options;
  const [acceleration, setAcceleration] = solidJs.createSignal({ x: null, y: null, z: null });
  const [rotationRate, setRotationRate] = solidJs.createSignal({
    alpha: null,
    beta: null,
    gamma: null
  });
  const [interval, setInterval] = solidJs.createSignal(0);
  const [accelerationIncludingGravity, setAccelerationIncludingGravity] = solidJs.createSignal({
    x: null,
    y: null,
    z: null
  });
  if (window2) {
    const onDeviceMotion = shared.createFilterWrapper(eventFilter, (event) => {
      setAcceleration(event.acceleration);
      setRotationRate(event.rotationRate);
      setInterval(event.interval);
      setAccelerationIncludingGravity(event.accelerationIncludingGravity);
    });
    useEventListener(window2, "devicemotion", onDeviceMotion);
  }
  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval
  };
}
function useDeviceOrientation(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "DeviceOrientationEvent" in window2);
  const [isAbsolute, setIsAbsolute] = solidJs.createSignal(false);
  const [alpha, setAlpha] = solidJs.createSignal(null);
  const [beta, setBeta] = solidJs.createSignal(null);
  const [gamma, setGamma] = solidJs.createSignal(null);
  if (window2 && isSupported()) {
    useEventListener(window2, "deviceorientation", (event) => {
      setIsAbsolute(event.absolute);
      setAlpha(event.alpha);
      setBeta(event.beta);
      setGamma(event.gamma);
    });
  }
  return {
    isSupported,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}
function useDevicePixelRatio({ window: window2 = defaultWindow } = {}) {
  const [pixelRatio, setPixelRatio] = solidJs.createSignal(1);
  const owner = solidJs.getOwner();
  if (window2) {
    let observe = function() {
      setPixelRatio(window2.devicePixelRatio);
      cleanup();
      media = window2.matchMedia(`(resolution: ${pixelRatio()}dppx)`);
      media.addEventListener("change", observe, { once: true });
    }, cleanup = function() {
      media == null ? void 0 : media.removeEventListener("change", observe);
    };
    let media;
    observe();
    solidJs.runWithOwner(owner, () => {
      shared.tryOnCleanup(cleanup);
    });
  }
  return { pixelRatio };
}
function usePermission(permissionDesc, options = {}) {
  const { controls = false, navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => navigator && "permissions" in navigator);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const [state, setState] = solidJs.createSignal();
  const onChange = () => {
    if (permissionStatus)
      setState(permissionStatus.state);
  };
  const owner = solidJs.getOwner();
  const query = shared.createSingletonPromise(async () => {
    if (!isSupported())
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator.permissions.query(desc);
        solidJs.runWithOwner(owner, () => {
          useEventListener(permissionStatus, "change", onChange);
        });
        onChange();
      } catch {
        setState("prompt");
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  }
  return state;
}
function useDevicesList(options = {}) {
  const {
    navigator = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated
  } = options;
  const [devices, setDevices] = solidJs.createSignal([]);
  const [permissionGranted, setPermissionGranted] = solidJs.createSignal(false);
  const videoInputs = solidJs.createMemo(() => devices().filter((i) => i.kind === "videoinput"));
  const audioInputs = solidJs.createMemo(() => devices().filter((i) => i.kind === "audioinput"));
  const audioOutputs = solidJs.createMemo(() => devices().filter((i) => i.kind === "audiooutput"));
  const isSupported = useSupported(() => {
    var _a;
    return (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.enumerateDevices;
  });
  async function update() {
    if (!isSupported())
      return;
    const devicesValue = await navigator.mediaDevices.enumerateDevices();
    setDevices(devicesValue);
    onUpdated == null ? void 0 : onUpdated(devicesValue);
  }
  async function ensurePermissions() {
    if (!isSupported())
      return false;
    if (permissionGranted())
      return true;
    const { state, query } = usePermission("camera", { controls: true });
    await query();
    if (state() !== "granted") {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      stream.getTracks().forEach((t) => t.stop());
      update();
      setPermissionGranted(true);
    } else {
      setPermissionGranted(true);
    }
    return permissionGranted();
  }
  if (isSupported()) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator.mediaDevices, "devicechange", update);
    update();
  }
  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}
function useDisplayMedia(options = {}) {
  const [enabled, setEnabled] = solidToVue.toSignal(options.enabled ?? false);
  const video = options.video;
  const audio = options.audio;
  const { navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a;
    return (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.getDisplayMedia;
  });
  const constraint = { audio, video };
  const [stream, setStream] = solidJs.createSignal();
  async function _start() {
    if (!isSupported() || stream())
      return;
    const streamVal = await navigator.mediaDevices.getDisplayMedia(constraint);
    setStream(streamVal);
    return streamVal;
  }
  async function _stop() {
    var _a;
    (_a = stream()) == null ? void 0 : _a.getTracks().forEach((t) => t.stop());
    setStream(void 0);
  }
  function stop() {
    _stop();
    setEnabled(false);
  }
  async function start() {
    await _start();
    if (stream())
      setEnabled(true);
    return stream();
  }
  solidJs.createEffect(
    solidJs.on(enabled, (v) => {
      if (v)
        _start();
      else
        _stop();
    })
  );
  return {
    isSupported,
    stream,
    start,
    stop,
    enabled,
    setEnabled
  };
}
function useDocumentVisibility({
  document: document2 = defaultDocument
} = {}) {
  if (!document2) {
    const [visibility2] = solidJs.createSignal("visible");
    return visibility2;
  }
  const [visibility, setVisibility] = solidJs.createSignal(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    setVisibility(document2.visibilityState);
  });
  return visibility;
}
function useDraggable(target, options = {}) {
  const draggingElement = options.draggingElement ?? defaultWindow;
  const draggingHandle = options.handle ?? target;
  const position = store.createMutable({ value: shared.unAccessor(options.initialValue) ?? { x: 0, y: 0 } });
  const pressedDelta = store.createMutable({ value: void 0 });
  const filterEvent = (e) => {
    if (options.pointerTypes)
      return options.pointerTypes.includes(e.pointerType);
    return true;
  };
  const handleEvent = (e) => {
    if (shared.unAccessor(options.preventDefault))
      e.preventDefault();
    if (shared.unAccessor(options.stopPropagation))
      e.stopPropagation();
  };
  const start = (e) => {
    var _a;
    if (!filterEvent(e))
      return;
    if (shared.unAccessor(options.exact) && e.target !== shared.unAccessor(target))
      return;
    const rect = shared.unAccessor(target).getBoundingClientRect();
    const pos = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
    if (((_a = options.onStart) == null ? void 0 : _a.call(options, pos, e)) === false)
      return;
    pressedDelta.value = pos;
    handleEvent(e);
  };
  const move = (e) => {
    var _a;
    if (!filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    position.value = {
      x: e.clientX - pressedDelta.value.x,
      y: e.clientY - pressedDelta.value.y
    };
    (_a = options.onMove) == null ? void 0 : _a.call(options, position.value, e);
    handleEvent(e);
  };
  const end = (e) => {
    var _a;
    if (!filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    pressedDelta.value = void 0;
    (_a = options.onEnd) == null ? void 0 : _a.call(options, position.value, e);
    handleEvent(e);
  };
  if (shared.isClient) {
    useEventListener(draggingHandle, "pointerdown", start, true);
    useEventListener(draggingElement, "pointermove", move, true);
    useEventListener(draggingElement, "pointerup", end, true);
  }
  return {
    x: () => position.value.x,
    y: () => position.value.x,
    position,
    isDragging: solidJs.createMemo(() => !!pressedDelta.value),
    style: solidJs.createMemo(() => ({ left: `${position.value.x}px`, top: `${position.value.y}px` }))
  };
}
function useDropZone(target, onDrop) {
  const [isOverDropZone, setOverDropZone] = solidJs.createSignal(false);
  let counter = 0;
  if (shared.isClient) {
    useEventListener(target, "dragenter", (event) => {
      event.preventDefault();
      counter += 1;
      setOverDropZone(true);
    });
    useEventListener(target, "dragover", (event) => {
      event.preventDefault();
    });
    useEventListener(target, "dragleave", (event) => {
      event.preventDefault();
      counter -= 1;
      if (counter === 0)
        setOverDropZone(false);
    });
    useEventListener(target, "drop", (event) => {
      var _a;
      event.preventDefault();
      counter = 0;
      setOverDropZone(false);
      const files = Array.from(((_a = event.dataTransfer) == null ? void 0 : _a.files) ?? []);
      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);
    });
  }
  return {
    isOverDropZone
  };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = shared.watch(shared.resolveAccessor(target), (el) => {
    cleanup();
    if (isSupported() && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  shared.tryOnCleanup(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const { reset = true, windowResize = true, windowScroll = true, immediate = true } = options;
  const [height, setHeight] = solidJs.createSignal(0);
  const [bottom, setBottom] = solidJs.createSignal(0);
  const [left, setLeft] = solidJs.createSignal(0);
  const [right, setRight] = solidJs.createSignal(0);
  const [top, setTop] = solidJs.createSignal(0);
  const [width, setWidth] = solidJs.createSignal(0);
  const [x, setX] = solidJs.createSignal(0);
  const [y, setY] = solidJs.createSignal(0);
  function update() {
    const el = shared.unAccessor(target);
    if (!el) {
      if (reset) {
        setHeight(0);
        setBottom(0);
        setLeft(0);
        setRight(0);
        setTop(0);
        setWidth(0);
        setX(0);
        setY(0);
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    setHeight(rect.height);
    setBottom(rect.bottom);
    setLeft(rect.left);
    setRight(rect.right);
    setTop(rect.top);
    setWidth(rect.width);
    setX(rect.x);
    setY(rect.y);
  }
  useResizeObserver(target, update);
  solidJs.createEffect(
    solidJs.on(
      shared.resolveAccessor(target),
      (ele) => {
        !ele && update();
      },
      { defer: true }
    )
  );
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  shared.tryOnMount(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementByPoint(options) {
  const [element, setElement] = solidJs.createSignal(null);
  const { x, y, document: document2 = defaultDocument } = options;
  const controls = useRafFn(() => {
    setElement(() => (document2 == null ? void 0 : document2.elementFromPoint(shared.unAccessor(x), shared.unAccessor(y))) ?? null);
  });
  return {
    element,
    ...controls
  };
}
function useElementHover(el, options = {}) {
  const delayEnter = options ? options.delayEnter : 0;
  const delayLeave = options ? options.delayLeave : 0;
  const [isHovered, setIsHovered] = solidJs.createSignal(false);
  let timer;
  const toggle = (entering) => {
    const delay = entering ? delayEnter : delayLeave;
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
    if (delay)
      timer = setTimeout(() => setIsHovered(entering), delay);
    else
      setIsHovered(entering);
  };
  if (!window)
    return isHovered;
  useEventListener(el, "mouseenter", () => toggle(true), { passive: true });
  useEventListener(el, "mouseleave", () => toggle(false), { passive: true });
  return isHovered;
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = solidJs.createMemo(() => {
    var _a, _b;
    return (_b = (_a = shared.unAccessor(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const [width, setWidth] = solidJs.createSignal(initialSize.width);
  const [height, setHeight] = solidJs.createSignal(initialSize.height);
  useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG()) {
        const $elem = shared.unAccessor(target);
        if ($elem) {
          const styles = window2.getComputedStyle($elem);
          setWidth(parseFloat(styles.width));
          setHeight(parseFloat(styles.height));
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          setWidth(formatBoxSize.reduce((acc, { inlineSize }) => acc + Number(inlineSize), 0));
          setHeight(formatBoxSize.reduce((acc, { blockSize }) => acc + Number(blockSize), 0));
        } else {
          setWidth(entry.contentRect.width);
          setHeight(entry.contentRect.height);
        }
      }
    },
    options
  );
  solidJs.createEffect(
    solidJs.on(
      shared.resolveAccessor(target),
      (ele) => {
        setWidth(ele ? initialSize.width : 0);
        setHeight(ele ? initialSize.height : 0);
      },
      { defer: true }
    )
  );
  return {
    width,
    height
  };
}
function useElementVisibility(element, { window: window2 = defaultWindow, scrollTarget } = {}) {
  const [elementIsVisible, setElementIsVisible] = solidJs.createSignal(false);
  const testBounding = () => {
    if (!window2)
      return;
    const document2 = window2.document;
    const el = shared.unAccessor(element);
    if (!el) {
      setElementIsVisible(false);
    } else {
      const rect = el.getBoundingClientRect();
      setElementIsVisible(
        rect.top <= (window2.innerHeight || document2.documentElement.clientHeight) && rect.left <= (window2.innerWidth || document2.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0
      );
    }
  };
  solidJs.createEffect(
    solidJs.on(shared.resolveAccessor(element), () => {
      testBounding();
    })
  );
  if (window2) {
    useEventListener(scrollTarget ?? window2, "scroll", testBounding, {
      capture: false,
      passive: true
    });
  }
  return elementIsVisible;
}
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
  const owner = solidJs.getOwner();
  function on(listener) {
    const listeners = events.get(key) ?? [];
    listeners.push(listener);
    events.set(key, listeners);
    const _off = () => off(listener);
    solidJs.runWithOwner(owner, () => {
      solidJs.onCleanup(_off);
    });
    return _off;
  }
  function once(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    return on(_listener);
  }
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners)
      return;
    const index = listeners.indexOf(listener);
    if (index > -1)
      listeners.splice(index, 1);
    if (!listeners.length)
      events.delete(key);
  }
  function reset() {
    events.delete(key);
  }
  function emit(event, payload) {
    var _a;
    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));
  }
  return { on, once, off, emit, reset };
}
function useEventSource(url, events2 = [], options = {}) {
  const [event, setEvent] = solidJs.createSignal(null);
  const [data, setData] = solidJs.createSignal(null);
  const [status, setState] = solidJs.createSignal("CONNECTING");
  const [eventSource, setEventSource] = solidJs.createSignal(null);
  const [error, setError] = solidJs.createSignal(null);
  const { withCredentials = false } = options;
  const close = () => {
    const eventSourceValue = eventSource();
    if (eventSourceValue) {
      eventSourceValue.close();
      setEventSource(null);
      setState("CLOSED");
    }
  };
  const es = new EventSource(url, { withCredentials });
  setEventSource(es);
  es.onopen = () => {
    setState("OPEN");
    setError(null);
  };
  es.onerror = (e) => {
    setState("CLOSED");
    setError(e);
  };
  es.onmessage = (e) => {
    setEvent(null);
    setData(e.data);
  };
  for (const eventName of events2) {
    useEventListener(es, eventName, (e) => {
      setEvent(eventName);
      setData(e.data ?? null);
    });
  }
  shared.tryOnCleanup(() => {
    close();
  });
  return {
    eventSource,
    event,
    data,
    status,
    error,
    close
  };
}
function useEyeDropper(options = {}) {
  const { initialValue = "" } = options;
  const isSupported = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
  const [sRGBHex, setSRGBHex] = solidJs.createSignal(initialValue);
  async function open(openOptions) {
    if (!isSupported())
      return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    setSRGBHex(result.sRGBHex);
    return result;
  }
  return { isSupported, sRGBHex, open };
}
function useFavicon(newIcon = null, options = {}) {
  const { baseUrl = "", rel = "icon", document: document2 = defaultDocument } = options;
  const [favicon, setFavicon] = solidToVue.toSignal(newIcon);
  const applyIcon = (icon) => {
    document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`).forEach((el) => el.href = `${baseUrl}${icon}`);
  };
  solidJs.createEffect(
    solidJs.on(favicon, (i, o) => {
      if (shared.isString(i) && i !== o)
        applyIcon(i);
    })
  );
  if (solidToVue.isAccessor(newIcon)) {
    return favicon;
  }
  return [favicon, setFavicon];
}
const payloadMapping = {
  json: "application/json",
  text: "text/plain",
  formData: "multipart/form-data"
};
function isFetchOptions(obj) {
  return obj && shared.containsProp(
    obj,
    "immediate",
    "refetch",
    "initialData",
    "timeout",
    "beforeFetch",
    "afterFetch",
    "onFetchError",
    "fetch"
  );
}
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers)
    return Object.fromEntries([...headers.entries()]);
  return headers;
}
function combineCallbacks(combination, ...callbacks) {
  if (combination === "overwrite") {
    return async (ctx) => {
      const callback = callbacks[callbacks.length - 1];
      if (callback !== void 0)
        await callback(ctx);
      return ctx;
    };
  }
  return async (ctx) => {
    await callbacks.reduce(
      (prevCallback, callback) => prevCallback.then(async () => {
        if (callback)
          ctx = { ...ctx, ...await callback(ctx) };
      }),
      Promise.resolve()
    );
    return ctx;
  };
}
function createFetch(config = {}) {
  const _combination = config.combination ?? "chain";
  const _options = config.options ?? {};
  const _fetchOptions = config.fetchOptions ?? {};
  function useFactoryFetch(url, ...args) {
    const computedUrl = solidJs.createMemo(() => {
      const baseUrl = shared.unAccessor(config.baseUrl);
      const targetUrl = shared.unAccessor(url);
      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
    });
    let options = _options;
    let fetchOptions = _fetchOptions;
    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options = {
          ...options,
          ...args[0],
          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
        };
      } else {
        fetchOptions = {
          ...fetchOptions,
          ...args[0],
          headers: {
            ...headersToObject(fetchOptions.headers) ?? {},
            ...headersToObject(args[0].headers) ?? {}
          }
        };
      }
    }
    if (args.length > 1 && isFetchOptions(args[1])) {
      options = {
        ...options,
        ...args[1],
        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
      };
    }
    return useFetch(computedUrl, fetchOptions, options);
  }
  return useFactoryFetch;
}
function useFetch(url, ...args) {
  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options = { immediate: true, refetch: false, timeout: 0 };
  const config = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  if (args.length > 0) {
    if (isFetchOptions(args[0]))
      options = { ...options, ...args[0] };
    else
      fetchOptions = args[0];
  }
  if (args.length > 1) {
    if (isFetchOptions(args[1]))
      options = { ...options, ...args[1] };
  }
  const { fetch = defaultWindow == null ? void 0 : defaultWindow.fetch, initialData, timeout } = options;
  const responseEvent = shared.createEventHook();
  const errorEvent = shared.createEventHook();
  const finallyEvent = shared.createEventHook();
  const [isFinished, setIsFinished] = solidJs.createSignal(false);
  const [isFetching, setIsFetching] = solidJs.createSignal(false);
  const [aborted, setAborted] = solidJs.createSignal(false);
  const [statusCode, setStatusCode] = solidJs.createSignal(null);
  const [response, setResponse] = solidJs.createSignal(null);
  const [error, setError] = solidJs.createSignal(null);
  const [data, setData] = solidJs.createSignal(initialData);
  const canAbort = solidJs.createMemo(() => supportsAbort && isFetching());
  let controller;
  let timer;
  const abort = () => {
    if (supportsAbort && controller) {
      controller.abort();
      controller = void 0;
    }
  };
  const loading = (isLoading) => {
    setIsFetching(isLoading);
    setIsFinished(!isLoading);
  };
  if (timeout)
    timer = shared.useTimeoutFn(abort, timeout, { immediate: false });
  const execute = async (throwOnFailed = false) => {
    loading(true);
    setError(null);
    setStatusCode(null);
    setAborted(false);
    controller = void 0;
    if (supportsAbort) {
      controller = new AbortController();
      controller.signal.onabort = () => setAborted(true);
      fetchOptions = {
        ...fetchOptions,
        signal: controller.signal
      };
    }
    const defaultFetchOptions = {
      method: config.method,
      headers: {}
    };
    if (config.payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      if (config.payloadType)
        headers["Content-Type"] = payloadMapping[config.payloadType] ?? config.payloadType;
      const payload = shared.unAccessor(config.payload);
      defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
    }
    let isCanceled = false;
    const context = {
      url: shared.unAccessor(url),
      options: { ...defaultFetchOptions, ...fetchOptions },
      cancel: () => {
        isCanceled = true;
      }
    };
    if (options.beforeFetch)
      Object.assign(context, await options.beforeFetch(context));
    if (isCanceled || !fetch) {
      loading(false);
      return Promise.resolve(null);
    }
    let responseData = null;
    if (timer)
      timer.start();
    return new Promise((resolve, reject) => {
      var _a;
      fetch(context.url, {
        ...defaultFetchOptions,
        ...context.options,
        headers: {
          ...headersToObject(defaultFetchOptions.headers),
          ...headersToObject((_a = context.options) == null ? void 0 : _a.headers)
        }
      }).then(async (fetchResponse) => {
        setResponse(fetchResponse);
        const statusCodeVal = fetchResponse.status;
        setStatusCode(statusCodeVal);
        responseData = await fetchResponse[config.type]();
        if (options.afterFetch && statusCodeVal >= 200 && statusCodeVal < 300)
          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));
        setData(responseData);
        if (!fetchResponse.ok)
          throw new Error(fetchResponse.statusText);
        responseEvent.trigger(fetchResponse);
        return resolve(fetchResponse);
      }).catch(async (fetchError) => {
        let errorData = fetchError.message || fetchError.name;
        if (options.onFetchError)
          ({ data: responseData, error: errorData } = await options.onFetchError({
            data: responseData,
            error: fetchError,
            response: response()
          }));
        setData(responseData);
        setError(errorData);
        errorEvent.trigger(fetchError);
        if (throwOnFailed)
          return reject(fetchError);
        return resolve(null);
      }).finally(() => {
        loading(false);
        if (timer)
          timer.stop();
        finallyEvent.trigger(null);
      });
    });
  };
  const refetch = shared.resolveAccessor(options.refetch);
  solidJs.createEffect(
    solidJs.on(
      [refetch, shared.resolveAccessor(url)],
      ([refetch2]) => {
        refetch2 && execute();
      },
      { defer: true }
    )
  );
  const shell = {
    isFinished,
    statusCode,
    response,
    error,
    data,
    isFetching,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    // method
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    // type
    json: setType("json"),
    text: setType("text"),
    blob: setType("blob"),
    arrayBuffer: setType("arrayBuffer"),
    formData: setType("formData")
  };
  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching()) {
        config.method = method;
        config.payload = payload;
        config.payloadType = payloadType;
        if (solidToVue.isAccessor(config.payload)) {
          solidJs.createEffect(
            solidJs.on(
              [refetch, shared.resolveAccessor(config.payload)],
              ([refetch2]) => {
                refetch2 && execute();
              },
              { defer: true }
            )
          );
        }
        const rawPayload = shared.unAccessor(config.payload);
        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))
          config.payloadType = "json";
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  function waitUntilFinished() {
    return new Promise((resolve, reject) => {
      shared.until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));
    });
  }
  function setType(type) {
    return () => {
      if (!isFetching()) {
        config.type = type;
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  if (options.immediate)
    setTimeout(execute, 0);
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
function joinPaths(start, end) {
  if (!start.endsWith("/") && !end.startsWith("/"))
    return `${start}/${end}`;
  return `${start}${end}`;
}
const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*"
};
function useFileDialog(options = {}) {
  const { document: document2 = defaultDocument } = options;
  const [files, setFiles] = solidJs.createSignal(null);
  let input;
  if (document2) {
    input = document2.createElement("input");
    input.type = "file";
    input.onchange = (event) => {
      const result = event.target;
      setFiles(result.files);
    };
  }
  const open = (localOptions) => {
    if (!input)
      return;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options,
      ...localOptions
    };
    input.multiple = _options.multiple;
    input.accept = _options.accept;
    if (shared.hasOwn(_options, "capture"))
      input.capture = _options.capture;
    input.click();
  };
  const reset = () => {
    setFiles(null);
    if (input)
      input.value = "";
  };
  return {
    files,
    open,
    reset
  };
}
function useFileSystemAccess(options = {}) {
  const { window: _window = defaultWindow, dataType = "Text" } = options;
  const window2 = _window;
  const isSupported = useSupported(() => window2 && "showSaveFilePicker" in window2 && "showOpenFilePicker" in window2);
  const [fileHandle, setFileHandle] = solidJs.createSignal();
  const [data, setData] = solidJs.createSignal();
  const [file, setFile] = solidJs.createSignal();
  const fileName = solidJs.createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.name) ?? "";
  });
  const fileMIME = solidJs.createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.type) ?? "";
  });
  const fileSize = solidJs.createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.size) ?? 0;
  });
  const fileLastModified = solidJs.createMemo(() => {
    var _a;
    return ((_a = file()) == null ? void 0 : _a.lastModified) ?? 0;
  });
  async function open(_options = {}) {
    if (!isSupported())
      return;
    const [handle] = await window2.showOpenFilePicker({ ...shared.unAccessor(options), ..._options });
    setFileHandle(handle);
    await updateFile();
    await updateData();
  }
  async function create(_options = {}) {
    if (!isSupported())
      return;
    const fileHandleValue = await window2.showSaveFilePicker({
      ...shared.unAccessor(options),
      ..._options
    });
    setFileHandle(fileHandleValue);
    setData(void 0);
    await updateFile();
    await updateData();
  }
  async function save(_options = {}) {
    if (!isSupported())
      return;
    const fileHandleValue = fileHandle();
    if (!fileHandleValue)
      return saveAs(_options);
    if (data()) {
      const writableStream = await fileHandleValue.createWritable();
      await writableStream.write(data());
      await writableStream.close();
    }
    await updateFile();
  }
  async function saveAs(_options = {}) {
    if (!isSupported())
      return;
    const fileHandleValue = await window2.showSaveFilePicker({
      ...shared.unAccessor(options),
      ..._options
    });
    setFileHandle(fileHandleValue);
    if (data()) {
      const writableStream = await fileHandleValue.createWritable();
      await writableStream.write(data());
      await writableStream.close();
    }
    await updateFile();
  }
  async function updateFile() {
    var _a;
    const f = await ((_a = fileHandle()) == null ? void 0 : _a.getFile());
    setFile(() => f);
  }
  async function updateData() {
    var _a, _b;
    if (shared.unAccessor(dataType) === "Text")
      setData(await ((_a = file()) == null ? void 0 : _a.text()));
    if (shared.unAccessor(dataType) === "ArrayBuffer")
      setData(await ((_b = file()) == null ? void 0 : _b.arrayBuffer()));
    if (shared.unAccessor(dataType) === "Blob") {
      setData(() => file());
    }
  }
  solidJs.createEffect(solidJs.on(shared.resolveAccessor(dataType), updateData, { defer: true }));
  return {
    isSupported,
    data,
    setData,
    file,
    setFile,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open,
    create,
    save,
    saveAs,
    updateData
  };
}
function useFocus(target, options = {}) {
  const { initialValue = false } = options;
  const [innerFocused, setInnerFocused] = solidJs.createSignal(false);
  const targetElement = shared.resolveAccessor(target);
  useEventListener(targetElement, "focus", () => setInnerFocused(true));
  useEventListener(targetElement, "blur", () => setInnerFocused(false));
  const [focused, setFocused] = solidToVue.writableComputed({
    get() {
      return innerFocused();
    },
    set(value) {
      var _a, _b;
      if (!value && innerFocused())
        (_a = targetElement()) == null ? void 0 : _a.blur();
      if (value && !innerFocused())
        (_b = targetElement()) == null ? void 0 : _b.focus();
    }
  });
  solidJs.createEffect(
    solidJs.on(targetElement, () => {
      setFocused(initialValue);
    })
  );
  return [focused, setFocused];
}
function useFocusWithin(target, options = {}) {
  const activeElement = useActiveElement(options);
  const targetElement = solidJs.createMemo(() => shared.unAccessor(target));
  const focused = solidJs.createMemo(
    () => targetElement() && activeElement() ? targetElement().contains(activeElement()) : false
  );
  return focused;
}
function useFps(options) {
  const [fps, setFps] = solidJs.createSignal(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (options == null ? void 0 : options.every) ?? 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      setFps(Math.round(1e3 / (diff / ticks)));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
const functionsMap = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
function useFullscreen(target, options = {}) {
  const { document: document2 = defaultDocument, autoExit = false } = options;
  const targetRef = target ?? (document2 == null ? void 0 : document2.querySelector("html"));
  const [isFullscreen, setIsFullscreen] = solidJs.createSignal(false);
  let map = functionsMap[0];
  const isSupported = useSupported(() => {
    if (!document2) {
      return false;
    }
    for (const m of functionsMap) {
      if (m[1] in document2) {
        map = m;
        return true;
      }
    }
    return false;
  });
  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;
  async function exit() {
    if (!isSupported())
      return;
    if (document2 == null ? void 0 : document2[ELEMENT])
      await document2[EXIT]();
    setIsFullscreen(false);
  }
  async function enter() {
    if (!isSupported())
      return;
    await exit();
    const target2 = shared.unAccessor(targetRef);
    if (target2) {
      await target2[REQUEST]();
      setIsFullscreen(true);
    }
  }
  async function toggle() {
    if (isFullscreen())
      await exit();
    else
      await enter();
  }
  if (document2) {
    useEventListener(
      document2,
      EVENT,
      () => {
        setIsFullscreen(!!(document2 == null ? void 0 : document2[ELEMENT]));
      },
      false
    );
  }
  if (autoExit)
    shared.tryOnCleanup(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}
function mapGamepadToXbox360Controller(gamepad) {
  return solidJs.createMemo(() => {
    const gamepadVal = gamepad();
    if (gamepadVal) {
      return {
        buttons: {
          a: gamepadVal.buttons[0],
          b: gamepadVal.buttons[1],
          x: gamepadVal.buttons[2],
          y: gamepadVal.buttons[3]
        },
        bumper: {
          left: gamepadVal.buttons[4],
          right: gamepadVal.buttons[5]
        },
        triggers: {
          left: gamepadVal.buttons[6],
          right: gamepadVal.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepadVal.axes[0],
            vertical: gamepadVal.axes[1],
            button: gamepadVal.buttons[10]
          },
          right: {
            horizontal: gamepadVal.axes[2],
            vertical: gamepadVal.axes[3],
            button: gamepadVal.buttons[11]
          }
        },
        dpad: {
          up: gamepadVal.buttons[12],
          down: gamepadVal.buttons[13],
          left: gamepadVal.buttons[14],
          right: gamepadVal.buttons[15]
        },
        back: gamepadVal.buttons[8],
        start: gamepadVal.buttons[9]
      };
    }
    return null;
  });
}
function useGamepad(options = {}) {
  const { navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => navigator && "getGamepads" in navigator);
  const [gamepads, setGamepads] = solidJs.createSignal([]);
  const onConnectedHook = shared.createEventHook();
  const onDisconnectedHook = shared.createEventHook();
  const stateFromGamepad = (gamepad) => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator)
      hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators)
      hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      hapticActuators,
      index: gamepad.index,
      mapping: gamepad.mapping,
      connected: gamepad.connected,
      timestamp: gamepad.timestamp,
      axes: gamepad.axes.map((axes) => axes),
      buttons: gamepad.buttons.map((button) => ({
        pressed: button.pressed,
        touched: button.touched,
        value: button.value
      }))
    };
  };
  const updateGamepadState = () => {
    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) ?? [];
    for (let i = 0; i < _gamepads.length; ++i) {
      const gamepad = _gamepads[i];
      if (gamepad) {
        const index = gamepads().findIndex(({ index: index2 }) => index2 === gamepad.index);
        if (index > -1)
          gamepads()[index] = stateFromGamepad(gamepad);
      }
    }
  };
  const { isActive, pause, resume } = useRafFn(updateGamepadState);
  const onGamepadConnected = (gamepad) => {
    if (!gamepads().some(({ index }) => index === gamepad.index)) {
      setGamepads((gamepads2) => [...gamepads2, stateFromGamepad(gamepad)]);
      onConnectedHook.trigger(gamepad.index);
    }
    resume();
  };
  const onGamepadDisconnected = (gamepad) => {
    setGamepads(gamepads().filter((x) => x.index !== gamepad.index));
    onDisconnectedHook.trigger(gamepad.index);
  };
  useEventListener("gamepadconnected", (e) => onGamepadConnected(e.gamepad));
  useEventListener("gamepaddisconnected", (e) => onGamepadDisconnected(e.gamepad));
  shared.tryOnMount(() => {
    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) ?? [];
    if (_gamepads) {
      for (let i = 0; i < _gamepads.length; ++i) {
        const gamepad = _gamepads[i];
        if (gamepad)
          onGamepadConnected(gamepad);
      }
    }
  });
  pause();
  return {
    isSupported,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}
function useGeolocation(options = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator = defaultNavigator,
    immediate = true
  } = options;
  const isSupported = useSupported(() => navigator && "geolocation" in navigator);
  const [locatedAt, setLocatedAt] = solidJs.createSignal(null);
  const [error, setError] = solidJs.createSignal(null);
  const [coords, setCoords] = solidJs.createSignal({
    accuracy: 0,
    latitude: Infinity,
    longitude: Infinity,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function updatePosition(position) {
    setLocatedAt(position.timestamp);
    setCoords(position.coords);
    setError(null);
  }
  let watcher;
  function resume() {
    if (isSupported()) {
      watcher = navigator.geolocation.watchPosition(updatePosition, (err) => setError(err), {
        enableHighAccuracy,
        maximumAge,
        timeout
      });
    }
  }
  if (immediate)
    resume();
  function pause() {
    if (watcher && navigator)
      navigator.geolocation.clearWatch(watcher);
  }
  shared.tryOnCleanup(() => {
    pause();
  });
  return {
    isSupported,
    coords,
    locatedAt,
    error,
    resume,
    pause
  };
}
const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events: events2 = defaultEvents$1,
    window: window2 = defaultWindow,
    eventFilter = shared.throttleFilter(50)
  } = options;
  const [idle, setIdle] = solidJs.createSignal(initialState);
  const [lastActive, setLastActive] = solidJs.createSignal(shared.timestamp());
  let timer;
  const onEvent = shared.createFilterWrapper(eventFilter, () => {
    setIdle(false);
    setLastActive(shared.timestamp());
    clearTimeout(timer);
    timer = setTimeout(() => setIdle(true), timeout);
  });
  if (window2) {
    const document2 = window2.document;
    for (const event of events2)
      useEventListener(window2, event, onEvent, { passive: true });
    if (listenForVisibilityChange) {
      useEventListener(document2, "visibilitychange", () => {
        if (!document2.hidden)
          onEvent();
      });
    }
  }
  timer = setTimeout(() => setIdle(true), timeout);
  return { idle, lastActive };
}
async function loadImage(options) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const { src, srcset, sizes } = options;
    img.src = src;
    if (srcset)
      img.srcset = srcset;
    if (sizes)
      img.sizes = sizes;
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}
const useImage = (options, asyncStateOptions = {}) => {
  const state = useAsyncState(() => loadImage(shared.unAccessor(options)), void 0, {
    resetOnExecute: true,
    ...asyncStateOptions
  });
  solidJs.createEffect(
    solidJs.on(
      () => shared.unAccessor(options),
      () => {
        state.execute(asyncStateOptions.delay);
      },
      { defer: true }
    )
  );
  return state;
};
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options = {}) {
  const {
    throttle = 0,
    idle = 200,
    onStop = shared.noop,
    onScroll = shared.noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto"
  } = options;
  const [internalX, setInternalX] = solidJs.createSignal(0);
  const [internalY, setInternalY] = solidJs.createSignal(0);
  const [x, setX] = solidToVue.writableComputed({
    get() {
      return internalX();
    },
    set(x2) {
      scrollTo(x2, void 0);
    }
  });
  const [y, setY] = solidToVue.writableComputed({
    get() {
      return internalY();
    },
    set(y2) {
      scrollTo(void 0, y2);
    }
  });
  function scrollTo(_x, _y) {
    var _a;
    const _element = shared.unAccessor(element);
    if (!_element)
      return;
    (_a = _element instanceof Document ? document.body : _element) == null ? void 0 : _a.scrollTo({
      top: shared.unAccessor(_y) ?? y(),
      left: shared.unAccessor(_x) ?? x(),
      behavior: shared.unAccessor(behavior)
    });
  }
  const [isScrolling, setIsScrolling] = solidJs.createSignal(false);
  const arrivedState = store.createMutable({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = store.createMutable({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = (e) => {
    if (!isScrolling())
      return;
    setIsScrolling(false);
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e);
  };
  const onScrollEndDebounced = shared.useDebounceFn(onScrollEnd, throttle + idle);
  const onScrollHandler = (e) => {
    const eventTarget = e.target === document ? e.target.documentElement : e.target;
    const scrollLeft = eventTarget.scrollLeft;
    directions.left = scrollLeft < internalX();
    directions.right = scrollLeft > internalY();
    arrivedState.left = scrollLeft <= 0 + (offset.left ?? 0);
    arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    setInternalX(scrollLeft);
    let scrollTop = eventTarget.scrollTop;
    if (e.target === document && !scrollTop)
      scrollTop = document.body.scrollTop;
    directions.top = scrollTop < internalY();
    directions.bottom = scrollTop > internalY();
    arrivedState.top = scrollTop <= 0 + (offset.top ?? 0);
    arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    setInternalY(scrollTop);
    setIsScrolling(true);
    onScrollEndDebounced(e);
    onScroll(e);
  };
  useEventListener(
    element,
    "scroll",
    throttle ? shared.useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,
    eventListenerOptions
  );
  useEventListener(element, "scrollend", onScrollEnd, eventListenerOptions);
  return {
    x,
    setX,
    y,
    setY,
    isScrolling,
    arrivedState,
    directions
  };
}
function useInfiniteScroll(element, onLoadMore, options = {}) {
  const direction = options.direction ?? "bottom";
  const state = useScroll(element, {
    ...options,
    offset: {
      [direction]: options.distance ?? 0,
      ...options.offset
    }
  });
  solidJs.createEffect(
    solidJs.on(
      () => state.arrivedState[direction],
      async (v) => {
        if (v) {
          const elem = shared.unAccessor(element);
          const previous = {
            height: (elem == null ? void 0 : elem.scrollHeight) ?? 0,
            width: (elem == null ? void 0 : elem.scrollWidth) ?? 0
          };
          await onLoadMore(state);
          if (options.preserveScrollPosition && elem) {
            solidToVue.nextTick(() => {
              elem.scrollTo({
                top: elem.scrollHeight - previous.height,
                left: elem.scrollWidth - previous.width
              });
            });
          }
        }
      }
    )
  );
}
function useIntersectionObserver(target, callback, options = {}) {
  const { root, rootMargin = "0", threshold = 0.1, window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
  let cleanup = shared.noop;
  const stopWatch = isSupported() ? shared.watch(
    () => ({
      el: shared.unAccessor(target),
      root: shared.unAccessor(root)
    }),
    ({ el, root: root2 }) => {
      cleanup();
      if (!el)
        return;
      const observer = new IntersectionObserver(callback, {
        root: root2,
        rootMargin,
        threshold
      });
      observer.observe(el);
      cleanup = () => {
        observer.disconnect();
        cleanup = shared.noop;
      };
    }
  ) : shared.noop;
  const stop = () => {
    cleanup();
    stopWatch();
  };
  shared.tryOnCleanup(stop);
  return {
    isSupported,
    stop
  };
}
const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
function useKeyModifier(modifier, options = {}) {
  const { events: events2 = defaultEvents, document: document2 = defaultDocument, initial = null } = options;
  const [state, setState] = solidJs.createSignal(initial);
  if (document2) {
    events2.forEach((listenerEvent) => {
      useEventListener(document2, listenerEvent, (evt) => {
        if (typeof evt.getModifierState === "function")
          setState(evt.getModifierState(modifier));
      });
    });
  }
  return state;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
const getSetCompat = () => {
  const data = store.createMutable([]);
  return {
    value() {
      return data;
    },
    add: (val) => {
      if (!data.includes(val)) {
        data.push(val);
      }
      return void 0;
    },
    has: (val) => data.includes(val),
    delete: (val) => {
      const index = data.findIndex((item) => item === val);
      if (index > -1) {
        data.splice(index, 1);
      }
      return true;
    },
    clear: () => {
      data.length = 0;
    }
  };
};
function useMagicKeys(options = {}) {
  const { target = defaultWindow, aliasMap = DefaultMagicKeysAliasMap, passive = true, onEventFired = shared.noop } = options;
  const current = getSetCompat();
  const obj = {
    toJSON() {
      return {};
    },
    current
  };
  const refs = obj;
  const metaDeps = /* @__PURE__ */ new Set();
  const usedKeys = /* @__PURE__ */ new Set();
  function setRefs(key, value) {
    if (key in refs) {
      refs[key][1](value);
    }
  }
  function reset() {
    current.clear();
    for (const key of usedKeys)
      setRefs(key, false);
  }
  function updateRefs(e, value) {
    var _a, _b;
    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values = [code, key].filter(Boolean);
    if (key) {
      if (value)
        current.add(key);
      else
        current.delete(key);
    }
    for (const key2 of values) {
      usedKeys.add(key2);
      setRefs(key2, value);
    }
    if (key === "meta" && !value) {
      metaDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value) {
      [...current.value(), ...values].forEach((key2) => metaDeps.add(key2));
    }
  }
  useEventListener(
    target,
    "keydown",
    (e) => {
      updateRefs(e, true);
      return onEventFired(e);
    },
    { passive }
  );
  useEventListener(
    target,
    "keyup",
    (e) => {
      updateRefs(e, false);
      return onEventFired(e);
    },
    { passive }
  );
  useEventListener("blur", reset, { passive: true });
  useEventListener("focus", reset, { passive: true });
  const proxy = new Proxy(refs, {
    get(target2, prop, rec) {
      if (typeof prop !== "string")
        return Reflect.get(target2, prop, rec);
      prop = prop.toLowerCase();
      if (prop in aliasMap)
        prop = aliasMap[prop];
      if (!(prop in refs)) {
        if (/[+_-]/.test(prop)) {
          const keys2 = prop.split(/[+_-]/g).map((i) => i.trim());
          refs[prop] = solidJs.createMemo(() => keys2.every((key) => shared.unAccessor(proxy[key])));
        } else {
          refs[prop] = solidJs.createSignal(false);
        }
      }
      const r = Reflect.get(target2, prop, rec);
      return solidToVue.isSignal(r) ? r[0] : r;
    }
  });
  return proxy;
}
function usingElRef(source, cb) {
  if (shared.unAccessor(source))
    cb(shared.unAccessor(source));
}
function timeRangeToArray(timeRanges) {
  let ranges = [];
  for (let i = 0; i < timeRanges.length; ++i)
    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];
  return ranges;
}
function tracksToArray(tracks) {
  return Array.from(tracks).map(
    ({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({
      id,
      label,
      kind,
      language,
      mode,
      activeCues,
      cues,
      inBandMetadataTrackDispatchType
    })
  );
}
const defaultOptions = {
  src: "",
  tracks: []
};
function useMediaControls(target, options = {}) {
  options = {
    ...defaultOptions,
    ...options
  };
  const { document: document2 = defaultDocument } = options;
  const [currentTime, setCurrentTime] = solidJs.createSignal(0);
  const [duration, setDuration] = solidJs.createSignal(0);
  const [seeking, setSeeking] = solidJs.createSignal(false);
  const [volume, setVolume] = solidJs.createSignal(1);
  const [waiting, setWaiting] = solidJs.createSignal(false);
  const [ended, setEnded] = solidJs.createSignal(false);
  const [playing, setPlaying] = solidJs.createSignal(false);
  const [rate, setRate] = solidJs.createSignal(1);
  const [stalled, setStalled] = solidJs.createSignal(false);
  const [buffered, setBuffered] = solidJs.createSignal([]);
  const [tracks, setTracks] = solidJs.createSignal([]);
  const [selectedTrack, setSelectedTrack] = solidJs.createSignal(-1);
  const [isPictureInPicture, setIsPictureInPicture] = solidJs.createSignal(false);
  const [muted, setMuted] = solidJs.createSignal(false);
  const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
  const sourceErrorEvent = shared.createEventHook();
  const disableTrack = (track) => {
    usingElRef(target, (el) => {
      if (track) {
        const id = shared.isNumber(track) ? track : track.id;
        el.textTracks[id].mode = "disabled";
      } else {
        for (let i = 0; i < el.textTracks.length; ++i)
          el.textTracks[i].mode = "disabled";
      }
      setSelectedTrack(-1);
    });
  };
  const enableTrack = (track, disableTracks = true) => {
    usingElRef(target, (el) => {
      const id = shared.isNumber(track) ? track : track.id;
      if (disableTracks)
        disableTrack();
      el.textTracks[id].mode = "showing";
      setSelectedTrack(id);
    });
  };
  const togglePictureInPicture = () => {
    return new Promise((resolve, reject) => {
      usingElRef(target, async (el) => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture()) {
            el.requestPictureInPicture().then(resolve).catch(reject);
          } else {
            document2.exitPictureInPicture().then(resolve).catch(reject);
          }
        }
      });
    });
  };
  solidJs.createEffect(() => {
    if (!document2)
      return;
    const el = shared.unAccessor(target);
    if (!el)
      return;
    const src = shared.unAccessor(options.src);
    let sources = [];
    if (!src)
      return;
    if (shared.isString(src))
      sources = [{ src }];
    else if (Array.isArray(src))
      sources = src;
    else if (shared.isObject(src))
      sources = [src];
    el.querySelectorAll("source").forEach((e) => {
      e.removeEventListener("error", sourceErrorEvent.trigger);
      e.remove();
    });
    sources.forEach(({ src: src2, type }) => {
      const source = document2.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type ?? "");
      source.addEventListener("error", sourceErrorEvent.trigger);
      el.appendChild(source);
    });
    el.load();
  });
  shared.tryOnCleanup(() => {
    const el = shared.unAccessor(target);
    if (!el)
      return;
    el.querySelectorAll("source").forEach((e) => e.removeEventListener("error", sourceErrorEvent.trigger));
  });
  solidJs.createEffect(
    solidJs.on(
      volume,
      (vol) => {
        const el = shared.unAccessor(target);
        if (!el)
          return;
        el.volume = vol;
      },
      { defer: true }
    )
  );
  solidJs.createEffect(
    solidJs.on(
      muted,
      (mute) => {
        const el = shared.unAccessor(target);
        if (!el)
          return;
        el.muted = mute;
      },
      { defer: true }
    )
  );
  solidJs.createEffect(
    solidJs.on(
      rate,
      (rate2) => {
        const el = shared.unAccessor(target);
        if (!el)
          return;
        el.playbackRate = rate2;
      },
      { defer: true }
    )
  );
  solidJs.createEffect(() => {
    if (!document2)
      return;
    const textTracks = shared.unAccessor(options.tracks);
    const el = shared.unAccessor(target);
    if (!(textTracks == null ? void 0 : textTracks.length) || !el)
      return;
    el.querySelectorAll("track").forEach((e) => e.remove());
    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {
      const track = document2.createElement("track");
      track.default = isDefault ?? false;
      track.kind = kind;
      track.label = label;
      track.src = src;
      track.srclang = srcLang;
      if (track.default)
        setSelectedTrack(i);
      el.appendChild(track);
    });
  });
  const { ignoreUpdates: ignoreCurrentTimeUpdates } = shared.watchIgnorable(currentTime, (time) => {
    const el = shared.unAccessor(target);
    if (!el)
      return;
    el.currentTime = time;
  });
  const { ignoreUpdates: ignorePlayingUpdates } = shared.watchIgnorable(playing, (isPlaying) => {
    const el = shared.unAccessor(target);
    if (!el)
      return;
    isPlaying ? el.play() : el.pause();
  });
  useEventListener(
    target,
    "timeupdate",
    () => ignoreCurrentTimeUpdates(() => setCurrentTime(() => shared.unAccessor(target).currentTime))
  );
  useEventListener(target, "durationchange", () => setDuration(() => shared.unAccessor(target).duration));
  useEventListener(target, "progress", () => setBuffered(() => timeRangeToArray(shared.unAccessor(target).buffered)));
  useEventListener(target, "seeking", () => setSeeking(true));
  useEventListener(target, "seeked", () => setSeeking(false));
  useEventListener(target, "waiting", () => setWaiting(true));
  useEventListener(target, "playing", () => {
    setWaiting(false);
    setEnded(false);
  });
  useEventListener(target, "ratechange", () => setRate(() => shared.unAccessor(target).playbackRate));
  useEventListener(target, "stalled", () => setStalled(true));
  useEventListener(target, "ended", () => setEnded(ended));
  useEventListener(target, "pause", () => ignorePlayingUpdates(() => setPlaying(false)));
  useEventListener(target, "play", () => ignorePlayingUpdates(() => setPlaying(true)));
  useEventListener(target, "enterpictureinpicture", () => setIsPictureInPicture(true));
  useEventListener(target, "leavepictureinpicture", () => setIsPictureInPicture(false));
  useEventListener(target, "volumechange", () => {
    const el = shared.unAccessor(target);
    if (!el)
      return;
    setVolume(el.volume);
    setMuted(el.muted);
  });
  const listeners = [];
  const stop = shared.watch(
    shared.resolveAccessor(target),
    () => {
      const el = shared.unAccessor(target);
      if (!el)
        return;
      stop();
      listeners[0] = useEventListener(el.textTracks, "addtrack", () => setTracks(tracksToArray(el.textTracks)));
      listeners[1] = useEventListener(el.textTracks, "removetrack", () => setTracks(tracksToArray(el.textTracks)));
      listeners[2] = useEventListener(el.textTracks, "change", () => setTracks(tracksToArray(el.textTracks)));
    },
    { defer: false }
  );
  shared.tryOnCleanup(() => listeners.forEach((listener) => listener()));
  return {
    currentTime,
    setCurrentTime,
    duration,
    waiting,
    setWaiting,
    seeking,
    setSeeking,
    ended,
    setEnded,
    stalled,
    setStalled,
    buffered,
    setBuffered,
    playing,
    setPlaying,
    rate,
    setRate,
    // Volume
    volume,
    setVolume,
    muted,
    setMuted,
    // Tracks
    tracks,
    setTracks,
    selectedTrack,
    setSelectedTrack,
    enableTrack,
    disableTrack,
    // Picture in Picture
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    // Events
    onSourceError: sourceErrorEvent.on
  };
}
const getMapCompat = () => {
  const data = store.createMutable({});
  return {
    get: (key) => data[key],
    set: (key, value) => solidToVue.set(data, key, value),
    has: (key) => shared.hasOwn(data, key),
    delete: (key) => solidToVue.del(data, key),
    clear: () => {
      Object.keys(data).forEach((key) => {
        solidToVue.del(data, key);
      });
    }
  };
};
function useMemoize(resolver, options) {
  const initCache = () => {
    if (options == null ? void 0 : options.cache)
      return store.createMutable(options.cache);
    return getMapCompat();
  };
  const cache = initCache();
  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : (
    // Default key: Serialize args
    JSON.stringify(args)
  );
  const _loadData = (key, ...args) => {
    cache.set(key, resolver(...args));
    return cache.get(key);
  };
  const loadData = (...args) => _loadData(generateKey(...args), ...args);
  const deleteData = (...args) => {
    cache.delete(generateKey(...args));
  };
  const clearData = () => {
    cache.clear();
  };
  const memoized = (...args) => {
    const key = generateKey(...args);
    if (cache.has(key))
      return cache.get(key);
    return _loadData(key, ...args);
  };
  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache;
  return memoized;
}
function useMemory(options = {}) {
  const [memory, setMemory] = solidJs.createSignal();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported()) {
    const { interval = 1e3 } = options;
    shared.useIntervalFn(
      () => {
        setMemory(performance.memory);
      },
      interval,
      { immediate: options.immediate, immediateCallback: options.immediateCallback }
    );
  }
  return { isSupported, memory };
}
function useMounted() {
  const [isMounted, setIsMounted] = solidJs.createSignal(false);
  solidJs.onMount(() => {
    setIsMounted(true);
  });
  return isMounted;
}
function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    eventFilter
  } = options;
  const [x, setX] = solidJs.createSignal(initialValue.x);
  const [y, setY] = solidJs.createSignal(initialValue.y);
  const [sourceType, setSourceType] = solidJs.createSignal(null);
  const mouseHandler = (event) => {
    if (type === "page") {
      setX(event.pageX);
      setY(event.pageY);
    } else if (type === "client") {
      setX(event.clientX);
      setY(event.clientY);
    } else if (type === "movement") {
      setX(event.movementX);
      setY(event.movementY);
    }
    setSourceType("mouse");
  };
  const reset = () => {
    setX(initialValue.x);
    setY(initialValue.y);
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];
      if (type === "page") {
        setX(touch2.pageX);
        setY(touch2.pageY);
      } else if (type === "client") {
        setX(touch2.clientX);
        setY(touch2.clientY);
      }
      setSourceType("touch");
    }
  };
  const mouseHandlerWrapper = (event) => {
    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
  };
  const touchHandlerWrapper = (event) => {
    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
  };
  if (window2) {
    useEventListener(window2, "mousemove", mouseHandlerWrapper, { passive: true });
    useEventListener(window2, "dragover", mouseHandlerWrapper, { passive: true });
    if (touch && type !== "movement") {
      useEventListener(window2, "touchstart", touchHandlerWrapper, { passive: true });
      useEventListener(window2, "touchmove", touchHandlerWrapper, { passive: true });
      if (resetOnTouchEnds)
        useEventListener(window2, "touchend", reset, { passive: true });
    }
  }
  return {
    x,
    y,
    setX,
    setY,
    sourceType
  };
}
function useMouseInElement(target, options = {}) {
  const { handleOutside = true, window: window2 = defaultWindow } = options;
  const { x, y, sourceType } = useMouse(options);
  const targetRef = solidToVue.toAccessor(target ?? (window2 == null ? void 0 : window2.document.body));
  const [elementX, setElementX] = solidJs.createSignal(0);
  const [elementY, setElementY] = solidJs.createSignal(0);
  const [elementPositionX, setElementPositionX] = solidJs.createSignal(0);
  const [elementPositionY, setElementPositionY] = solidJs.createSignal(0);
  const [elementHeight, setElementHeight] = solidJs.createSignal(0);
  const [elementWidth, setElementWidth] = solidJs.createSignal(0);
  const [isOutside, setIsOutside] = solidJs.createSignal(true);
  let stop = () => {
  };
  if (window2) {
    stop = shared.watch([targetRef, x, y], () => {
      const el = targetRef();
      if (!el)
        return;
      const { left, top, width, height } = el.getBoundingClientRect();
      setElementPositionX(left + window2.pageXOffset);
      setElementPositionY(top + window2.pageYOffset);
      setElementHeight(height);
      setElementWidth(width);
      const elX = x() - elementPositionX();
      const elY = y() - elementPositionY();
      setIsOutside(width === 0 || height === 0 || elX <= 0 || elY <= 0 || elX > width || elY > height);
      if (handleOutside || !isOutside()) {
        setElementX(elX);
        setElementY(elY);
      }
    });
    useEventListener(document, "mouseleave", () => {
      setIsOutside(true);
    });
  }
  return {
    x,
    y,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options = {}) {
  const { touch = true, drag = true, initialValue = false, window: window2 = defaultWindow } = options;
  const [pressed, setPressed] = solidJs.createSignal(initialValue);
  const [sourceType, setSourceType] = solidJs.createSignal(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => () => {
    setPressed(true);
    setSourceType(srcType);
  };
  const onReleased = () => {
    setPressed(false);
    setSourceType(null);
  };
  const target = solidJs.createMemo(() => shared.unAccessor(options.target) ?? window2);
  useEventListener(target, "mousedown", onPressed("mouse"), { passive: true });
  useEventListener(window2, "mouseleave", onReleased, { passive: true });
  useEventListener(window2, "mouseup", onReleased, { passive: true });
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), { passive: true });
    useEventListener(window2, "drop", onReleased, { passive: true });
    useEventListener(window2, "dragend", onReleased, { passive: true });
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), { passive: true });
    useEventListener(window2, "touchend", onReleased, { passive: true });
    useEventListener(window2, "touchcancel", onReleased, { passive: true });
  }
  return {
    pressed,
    sourceType
  };
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = shared.watch(shared.resolveAccessor(target), (el) => {
    cleanup();
    if (isSupported() && window2 && el) {
      observer = new MutationObserver(callback);
      observer.observe(el, mutationOptions);
    }
  });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  shared.tryOnCleanup(stop);
  return {
    isSupported,
    stop
  };
}
const useNavigatorLanguage = (options = {}) => {
  const { window: window2 = defaultWindow } = options;
  const navigator = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator && "language" in navigator);
  const [language, setLanguage] = solidJs.createSignal(navigator == null ? void 0 : navigator.language);
  useEventListener(window2, "languagechange", () => {
    if (navigator) {
      setLanguage(navigator.language);
    }
  });
  return {
    isSupported,
    language
  };
};
function useNetwork(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator && "connection" in navigator);
  const [isOnline, setIsOnline] = solidJs.createSignal(true);
  const [saveData, setSaveData] = solidJs.createSignal(false);
  const [offlineAt, setOfflineAt] = solidJs.createSignal(void 0);
  const [onlineAt, setOnlineAt] = solidJs.createSignal(void 0);
  const [downlink, setDownlink] = solidJs.createSignal(void 0);
  const [downlinkMax, setDownlinkMax] = solidJs.createSignal(void 0);
  const [rtt, setRtt] = solidJs.createSignal(void 0);
  const [effectiveType, setEffectiveType] = solidJs.createSignal(void 0);
  const [type, setType] = solidJs.createSignal("unknown");
  const connection = isSupported() && navigator.connection;
  function updateNetworkInformation() {
    if (!navigator)
      return;
    setIsOnline(navigator.onLine);
    setOfflineAt(isOnline() ? void 0 : Date.now());
    setOnlineAt(isOnline() ? Date.now() : void 0);
    if (connection) {
      setDownlink(connection.downlink);
      setDownlinkMax(connection.downlinkMax);
      setEffectiveType(connection.effectiveType);
      setRtt(connection.rtt);
      setSaveData(connection.saveData);
      setType(connection.type);
    }
  }
  if (window2) {
    useEventListener(window2, "offline", () => {
      setIsOnline(false);
      setOfflineAt(Date.now());
    });
    useEventListener(window2, "online", () => {
      setIsOnline(true);
      setOnlineAt(Date.now());
    });
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline,
    saveData,
    offlineAt,
    onlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type
  };
}
function useNow(options = {}) {
  const { controls: exposeControls = false, interval = "requestAnimationFrame" } = options;
  const [now, setNow] = solidJs.createSignal(new Date());
  const update = () => setNow(new Date());
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : shared.useIntervalFn(update, interval, { immediate: true });
  if (exposeControls) {
    return {
      now,
      ...controls
    };
  }
  return now;
}
function useObjectUrl(object) {
  const [url, setUrl] = solidJs.createSignal("");
  const release = () => {
    const urlVal = url();
    if (urlVal) {
      URL.revokeObjectURL(urlVal);
    }
    setUrl(void 0);
  };
  solidJs.createEffect(
    solidJs.on(shared.resolveAccessor(object), (newObject) => {
      release();
      if (newObject) {
        setUrl(URL.createObjectURL(newObject));
      }
    })
  );
  return url;
}
function useClamp(value, min, max) {
  if (solidToVue.isAccessor(value)) {
    return solidJs.createMemo(() => shared.clamp(shared.unAccessor(value), shared.unAccessor(min), shared.unAccessor(max)));
  }
  const [_value, _setValue] = solidToVue.toSignal(value);
  const getValue2 = solidJs.createMemo(() => {
    return shared.clamp(_value(), shared.unAccessor(min), shared.unAccessor(max));
  });
  const setValue = (value2) => {
    const res = shared.clamp(solidToVue.getSetterValue(value2, _value()), shared.unAccessor(min), shared.unAccessor(max));
    _setValue(res);
    return res;
  };
  return [getValue2, setValue];
}
function useOffsetPagination(options) {
  const {
    total = Infinity,
    pageSize = 10,
    page = 1,
    setPage,
    setPageSize,
    onPageChange = shared.noop,
    onPageSizeChange = shared.noop,
    onPageCountChange = shared.noop
  } = options;
  const [currentPageSize, setCurrentPageSize] = useClamp(
    setPageSize === void 0 || shared.isNumber(pageSize) ? pageSize : [pageSize, setPageSize],
    1,
    Infinity
  );
  const pageCount = solidJs.createMemo(() => Math.max(1, Math.ceil(shared.unAccessor(total) / shared.unAccessor(currentPageSize))));
  const [currentPage, setCurrentPage] = useClamp(
    setPage === void 0 || shared.isNumber(page) ? page : [page, setPage],
    1,
    pageCount
  );
  const isFirstPage = solidJs.createMemo(() => currentPage() === 1);
  const isLastPage = solidJs.createMemo(() => currentPage() === pageCount());
  if (solidToVue.isAccessor(page))
    shared.syncSignal([page, setPage], [currentPage, setCurrentPage], { defer: true });
  if (solidToVue.isAccessor(pageSize))
    shared.syncSignal([pageSize, setPageSize], [currentPageSize, setCurrentPageSize], { defer: true });
  function prev() {
    setCurrentPage((state) => state - 1);
  }
  function next() {
    setCurrentPage((state) => state + 1);
  }
  const returnValue = {
    currentPage,
    setCurrentPage,
    currentPageSize,
    setCurrentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev,
    next
  };
  solidJs.createEffect(
    solidJs.on(
      currentPage,
      () => {
        onPageChange(solidToVue.reactive(returnValue));
      },
      { defer: true }
    )
  );
  solidJs.createEffect(
    solidJs.on(
      currentPageSize,
      () => {
        onPageSizeChange(solidToVue.reactive(returnValue));
      },
      { defer: true }
    )
  );
  solidJs.createEffect(
    solidJs.on(
      pageCount,
      () => {
        onPageCountChange(solidToVue.reactive(returnValue));
      },
      { defer: true }
    )
  );
  return returnValue;
}
function useOnline(options = {}) {
  const { isOnline } = useNetwork(options);
  return isOnline;
}
function usePageLeave(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const [isLeft, setIsLeft] = solidJs.createSignal(false);
  const handler = (event) => {
    if (!window2)
      return;
    event = event || window2.event;
    const from = event.relatedTarget ?? event.toElement;
    setIsLeft(!from);
  };
  if (window2) {
    useEventListener(window2, "mouseout", handler, { passive: true });
    useEventListener(window2.document, "mouseleave", handler, { passive: true });
    useEventListener(window2.document, "mouseenter", handler, { passive: true });
  }
  return isLeft;
}
function useParallax(target, options = {}) {
  const {
    deviceOrientationTiltAdjust = (i) => i,
    deviceOrientationRollAdjust = (i) => i,
    mouseTiltAdjust = (i) => i,
    mouseRollAdjust = (i) => i,
    window: window2 = defaultWindow
  } = options;
  const orientation = useDeviceOrientation({ window: window2 });
  const {
    elementX: x,
    elementY: y,
    elementWidth: width,
    elementHeight: height
  } = useMouseInElement(target, { handleOutside: false, window: window2 });
  const source = solidJs.createMemo(() => {
    if (orientation.isSupported() && (orientation.alpha() != null && orientation.alpha() !== 0 || orientation.gamma() != null && orientation.gamma() !== 0))
      return "deviceOrientation";
    return "mouse";
  });
  const roll = solidJs.createMemo(() => {
    if (source() === "deviceOrientation") {
      const value2 = -orientation.beta / 90;
      return deviceOrientationRollAdjust(value2);
    }
    const value = -(y() - height() / 2) / height();
    return mouseRollAdjust(value);
  });
  const tilt = solidJs.createMemo(() => {
    if (source() === "deviceOrientation") {
      const value2 = orientation.gamma() / 90;
      return deviceOrientationTiltAdjust(value2);
    }
    const value = (x() - width() / 2) / width();
    return mouseTiltAdjust(value);
  });
  return { roll, tilt, source };
}
const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options = {}) {
  const { target = defaultWindow } = options;
  const [isInside, setInside] = solidJs.createSignal(false);
  const state = store.createMutable(options.initialValue ?? {});
  Object.assign(state, defaultState);
  const handler = (event) => {
    setInside(true);
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    Object.assign(state, shared.objectPick(event, keys, false));
  };
  if (target) {
    useEventListener(target, "pointerdown", handler, { passive: true });
    useEventListener(target, "pointermove", handler, { passive: true });
    useEventListener(target, "pointerleave", () => setInside(false), { passive: true });
  }
  return {
    ...shared.toAccessors(state),
    isInside
  };
}
function usePointerLock(target, options = {}) {
  const { document: document2 = defaultDocument, pointerLockOptions } = options;
  const isSupported = useSupported(() => document2 && "pointerLockElement" in document2);
  const [element, setElement] = solidJs.createSignal();
  const [triggerElement, setTriggerElement] = solidJs.createSignal();
  let targetElement;
  if (isSupported()) {
    useEventListener(document2, "pointerlockchange", () => {
      const currentElement = document2.pointerLockElement ?? element();
      if (targetElement && currentElement === targetElement) {
        const elementValue = document2.pointerLockElement;
        setElement(elementValue);
        if (!elementValue) {
          setTriggerElement(null);
          targetElement = null;
        }
      }
    });
    useEventListener(document2, "pointerlockerror", () => {
      const currentElement = document2.pointerLockElement ?? element();
      if (targetElement && currentElement === targetElement) {
        const action = document2.pointerLockElement ? "release" : "acquire";
        throw new Error(`Failed to ${action} pointer lock.`);
      }
    });
  }
  const owner = solidJs.getOwner();
  function lock(e, options2) {
    if (!isSupported())
      throw new Error("Pointer Lock API is not supported by your browser.");
    const triggerElementValue = e instanceof Event ? e.currentTarget : null;
    setTriggerElement(triggerElementValue);
    targetElement = e instanceof Event ? shared.unAccessor(target) ?? triggerElementValue : shared.unAccessor(e);
    if (!targetElement)
      throw new Error("Target element undefined.");
    targetElement.requestPointerLock(options2 ?? pointerLockOptions);
    return shared.until(element, owner).toBe(targetElement);
  }
  async function unlock() {
    if (!element())
      return false;
    document2.exitPointerLock();
    await shared.until(element, owner).toBeNull();
    return true;
  }
  return {
    isSupported,
    element,
    triggerElement,
    lock,
    unlock
  };
}
var SwipeDirection = /* @__PURE__ */ ((SwipeDirection2) => {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
  return SwipeDirection2;
})(SwipeDirection || {});
function useSwipe(target, options = {}) {
  const { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart, passive = true, window: window2 = defaultWindow } = options;
  const coordsStart = store.createMutable({ x: 0, y: 0 });
  const coordsEnd = store.createMutable({ x: 0, y: 0 });
  const diffX = solidJs.createMemo(() => coordsStart.x - coordsEnd.x);
  const diffY = solidJs.createMemo(() => coordsStart.y - coordsEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = solidJs.createMemo(() => max(abs(diffX()), abs(diffY())) >= threshold);
  const [isSwiping, setIsSwiping] = solidJs.createSignal(false);
  const direction = solidJs.createMemo(() => {
    if (!isThresholdExceeded())
      return "NONE";
    if (abs(diffX()) > abs(diffY())) {
      return diffX() > 0 ? "LEFT" : "RIGHT";
    }
    return diffY() > 0 ? "UP" : "DOWN";
  });
  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };
  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };
  let listenerOptions;
  const isPassiveEventSupported = checkPassiveEventSupport(window2 == null ? void 0 : window2.document);
  if (!passive)
    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };
  else
    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };
  const onTouchEnd = (e) => {
    if (isSwiping())
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction());
    setIsSwiping(false);
  };
  const stops = [
    useEventListener(
      target,
      "touchstart",
      (e) => {
        if (listenerOptions.capture && !listenerOptions.passive)
          e.preventDefault();
        const [x, y] = getTouchEventCoords(e);
        updateCoordsStart(x, y);
        updateCoordsEnd(x, y);
        onSwipeStart == null ? void 0 : onSwipeStart(e);
      },
      listenerOptions
    ),
    useEventListener(
      target,
      "touchmove",
      (e) => {
        const [x, y] = getTouchEventCoords(e);
        updateCoordsEnd(x, y);
        if (!isSwiping() && isThresholdExceeded())
          setIsSwiping(true);
        if (isSwiping())
          onSwipe == null ? void 0 : onSwipe(e);
      },
      listenerOptions
    ),
    useEventListener(target, "touchend", onTouchEnd, listenerOptions),
    useEventListener(target, "touchcancel", onTouchEnd, listenerOptions)
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isPassiveEventSupported,
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop
  };
}
function checkPassiveEventSupport(document2) {
  if (!document2)
    return false;
  let supportsPassive = false;
  const optionsBlock = {
    get passive() {
      supportsPassive = true;
      return false;
    }
  };
  document2.addEventListener("x", shared.noop, optionsBlock);
  document2.removeEventListener("x", shared.noop);
  return supportsPassive;
}
function usePointerSwipe(target, options = {}) {
  const targetRef = shared.resolveAccessor(target);
  const { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart } = options;
  const posStart = store.createMutable({ x: 0, y: 0 });
  const updatePosStart = (x, y) => {
    posStart.x = x;
    posStart.y = y;
  };
  const posEnd = store.createMutable({ x: 0, y: 0 });
  const updatePosEnd = (x, y) => {
    posEnd.x = x;
    posEnd.y = y;
  };
  const distanceX = solidJs.createMemo(() => posStart.x - posEnd.x);
  const distanceY = solidJs.createMemo(() => posStart.y - posEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = solidJs.createMemo(() => max(abs(distanceX()), abs(distanceY())) >= threshold);
  const [isSwiping, setIsSwiping] = solidJs.createSignal(false);
  const [isPointerDown, setIsPointerDown] = solidJs.createSignal(false);
  const direction = solidJs.createMemo(() => {
    if (!isThresholdExceeded())
      return SwipeDirection.NONE;
    if (abs(distanceX()) > abs(distanceY())) {
      return distanceX() > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
    }
    return distanceY() > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
  });
  const eventIsAllowed = (e) => {
    var _a;
    const isReleasingButton = e.buttons === 0;
    const isPrimaryButton = e.buttons === 1;
    return ((_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) ?? (isReleasingButton || isPrimaryButton) ?? true;
  };
  const stops = [
    useEventListener(target, "pointerdown", (e) => {
      var _a, _b;
      if (!eventIsAllowed(e))
        return;
      setIsPointerDown(true);
      (_b = (_a = targetRef()) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "none");
      const eventTarget = e.target;
      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
      const { clientX: x, clientY: y } = e;
      updatePosStart(x, y);
      updatePosEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }),
    useEventListener(target, "pointermove", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (!isPointerDown())
        return;
      const { clientX: x, clientY: y } = e;
      updatePosEnd(x, y);
      if (!isSwiping() && isThresholdExceeded())
        setIsSwiping(true);
      if (isSwiping())
        onSwipe == null ? void 0 : onSwipe(e);
    }),
    useEventListener(target, "pointerup", (e) => {
      var _a, _b;
      if (!eventIsAllowed(e))
        return;
      if (isSwiping())
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction());
      setIsPointerDown(false);
      setIsSwiping(false);
      (_b = (_a = targetRef()) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "initial");
    })
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping,
    direction,
    posStart,
    posEnd,
    distanceX,
    distanceY,
    stop
  };
}
function usePreferredColorScheme(options) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
  return solidJs.createMemo(() => {
    if (isDark())
      return "dark";
    if (isLight())
      return "light";
    return "no-preference";
  });
}
function usePreferredContrast(options) {
  const isMore = useMediaQuery("(prefers-contrast: more)", options);
  const isLess = useMediaQuery("(prefers-contrast: less)", options);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", options);
  return solidJs.createMemo(() => {
    if (isMore())
      return "more";
    if (isLess())
      return "less";
    if (isCustom())
      return "custom";
    return "no-preference";
  });
}
function usePreferredLanguages(options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2) {
    const [en] = solidJs.createSignal(["en"]);
    return en;
  }
  const navigator = window2.navigator;
  const [value, setValue] = solidJs.createSignal(navigator.languages);
  useEventListener(window2, "languagechange", () => {
    setValue(navigator.languages);
  });
  return value;
}
function usePreferredReducedMotion(options) {
  const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options);
  return solidJs.createMemo(() => {
    if (isReduced())
      return "reduce";
    return "no-preference";
  });
}
function usePrevious(value, initialValue) {
  const [previous, setPrevious] = solidJs.createSignal();
  solidJs.createEffect((v) => {
    setPrevious(() => v);
    return shared.resolveAccessor(value)();
  }, initialValue);
  return previous;
}
const useScreenOrientation = (options = {}) => {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "screen" in window2 && "orientation" in window2.screen);
  const screenOrientation = isSupported() ? window2.screen.orientation : {};
  const [orientation, setOrientation] = solidJs.createSignal(screenOrientation.type);
  const [angle, setAngle] = solidJs.createSignal(screenOrientation.angle || 0);
  if (isSupported()) {
    useEventListener(window2, "orientationchange", () => {
      setOrientation(screenOrientation.type);
      setAngle(screenOrientation.angle);
    });
  }
  const lockOrientation = (type) => {
    if (!isSupported())
      return Promise.reject(new Error("Not supported"));
    return screenOrientation.lock(type);
  };
  const unlockOrientation = () => {
    if (isSupported())
      screenOrientation.unlock();
  };
  return {
    isSupported,
    orientation,
    angle,
    lockOrientation,
    unlockOrientation
  };
};
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
  const [top, setTop] = solidJs.createSignal("");
  const [right, setRight] = solidJs.createSignal("");
  const [bottom, setBottom] = solidJs.createSignal("");
  const [left, setLeft] = solidJs.createSignal("");
  if (shared.isClient) {
    const [_topCssVar, setTopCssVar] = useCssVar(topVarName);
    const [_rightCssVar, setRightCssVar] = useCssVar(rightVarName);
    const [_bottomCssVar, setBottomCssVar] = useCssVar(bottomVarName);
    const [_leftCssVar, setLeftCssVar] = useCssVar(leftVarName);
    setTopCssVar("env(safe-area-inset-top, 0)");
    setRightCssVar("env(safe-area-inset-right, 0)");
    setBottomCssVar("env(safe-area-inset-bottom, 0)");
    setLeftCssVar("env(safe-area-inset-left, 0)");
    update();
    useEventListener("resize", shared.useDebounceFn(update));
  }
  function update() {
    setTop(getValue(topVarName));
    setRight(getValue(rightVarName));
    setBottom(getValue(bottomVarName));
    setLeft(getValue(leftVarName));
  }
  return {
    top,
    right,
    bottom,
    left,
    update
  };
}
function getValue(position) {
  return getComputedStyle(document.documentElement).getPropertyValue(position);
}
function useScriptTag(src, onLoaded = shared.noop, options = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs = {}
  } = options;
  const [scriptTag, setScriptTag] = solidJs.createSignal(null);
  let _promise = null;
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      setScriptTag(el2);
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${shared.unAccessor(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type;
      el.async = async;
      el.src = shared.unAccessor(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    el.addEventListener("error", (event) => reject(event));
    el.addEventListener("abort", (event) => reject(event));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  };
  const unload = () => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag())
      setScriptTag(null);
    const el = document2.querySelector(`script[src="${shared.unAccessor(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  };
  if (immediate && !manual)
    shared.tryOnMount(load);
  if (!manual)
    shared.tryOnCleanup(unload);
  return { scriptTag, load, unload };
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientHeight < ele.scrollHeight || style.overflowY === "auto" && ele.clientWidth < ele.scrollWidth) {
    return true;
  }
  const parent = ele.parentNode;
  if (!parent || parent.tagName === "BODY")
    return false;
  return checkOverflowScroll(parent);
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
function useScrollLock(element, initialState = false) {
  const [isLocked, setIsLocked] = solidJs.createSignal(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow;
  solidJs.createEffect(
    solidJs.on(shared.resolveAccessor(element), (el) => {
      if (el) {
        const ele = el;
        initialOverflow = ele.style.overflow;
        if (isLocked())
          ele.style.overflow = "hidden";
      }
    })
  );
  const lock = () => {
    const ele = shared.unAccessor(element);
    if (!ele || isLocked())
      return;
    if (shared.isIOS) {
      stopTouchMoveListener = useEventListener(
        ele,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    ele.style.overflow = "hidden";
    setIsLocked(true);
  };
  const unlock = () => {
    const ele = shared.unAccessor(element);
    if (!ele || !isLocked())
      return;
    shared.isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    ele.style.overflow = initialOverflow;
    setIsLocked(false);
  };
  shared.tryOnCleanup(unlock);
  return [
    isLocked,
    (v) => {
      if (v)
        lock();
      else
        unlock();
    }
  ];
}
function useSessionStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options);
}
function useShare(shareOptions = {}, options = {}) {
  const { navigator = defaultNavigator } = options;
  const _navigator = navigator;
  const isSupported = useSupported(() => _navigator && "canShare" in _navigator);
  const share = async (overrideOptions = {}) => {
    if (isSupported()) {
      const data = {
        ...shared.unAccessor(shareOptions),
        ...shared.unAccessor(overrideOptions)
      };
      let granted = true;
      if (data.files && _navigator.canShare)
        granted = _navigator.canShare({ files: data.files });
      if (granted)
        return _navigator.share(data);
    }
  };
  return {
    isSupported,
    share
  };
}
function useSpeechRecognition(options = {}) {
  const { interimResults = true, continuous = true, window: window2 = defaultWindow } = options;
  const lang = shared.resolveAccessor(options.lang ?? "en-US");
  const [isListening, setIsListening] = solidJs.createSignal(false);
  const [isFinal, setIsFinal] = solidJs.createSignal(false);
  const [result, setResult] = solidJs.createSignal("");
  const [error, setError] = solidJs.createSignal(void 0);
  const toggle = (value = !isListening()) => {
    setIsListening(value);
  };
  const start = () => {
    setIsListening(true);
  };
  const stop = () => {
    setIsListening(false);
  };
  const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
  const isSupported = useSupported(() => SpeechRecognition);
  let recognition;
  if (isSupported()) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = shared.unAccessor(lang);
    recognition.onstart = () => {
      setIsFinal(false);
    };
    solidJs.createEffect(
      solidJs.on(
        lang,
        (lang2) => {
          if (recognition && !isListening())
            recognition.lang = lang2;
        },
        { defer: true }
      )
    );
    recognition.onresult = (event) => {
      const transcript = Array.from(event.results).map((result2) => {
        setIsFinal(result2.isFinal);
        return result2[0];
      }).map((result2) => result2.transcript).join("");
      setResult(transcript);
      setError(void 0);
    };
    recognition.onerror = (event) => {
      setError(event);
    };
    recognition.onend = () => {
      setIsListening(false);
      recognition.lang = shared.unAccessor(lang);
    };
    solidJs.createEffect(
      solidJs.on(
        isListening,
        () => {
          if (isListening())
            recognition.start();
          else
            recognition.stop();
        },
        { defer: true }
      )
    );
  }
  shared.tryOnCleanup(() => {
    setIsListening(false);
  });
  return {
    isSupported,
    isListening,
    isFinal,
    result,
    setResult,
    recognition,
    error,
    toggle,
    start,
    stop
  };
}
function useSpeechSynthesis(text, options = {}) {
  const { pitch = 1, rate = 1, volume = 1, window: window2 = defaultWindow } = options;
  const synth = window2 && window2.speechSynthesis;
  const isSupported = useSupported(() => synth);
  const [isPlaying, setIsPlaying] = solidJs.createSignal(false);
  const [status, setStatus] = solidJs.createSignal("init");
  const spokenText = shared.resolveAccessor(text || "");
  const lang = shared.resolveAccessor(options.lang ?? "en-US");
  const [error, setError] = solidJs.createSignal(void 0);
  const toggle = (value = !isPlaying()) => {
    setIsPlaying(value);
  };
  const bindEventsForUtterance = (utterance2) => {
    utterance2.lang = shared.unAccessor(lang);
    utterance2.voice = shared.unAccessor(options.voice) ?? null;
    utterance2.pitch = pitch;
    utterance2.rate = rate;
    utterance2.volume = volume;
    utterance2.onstart = () => {
      setIsPlaying(true);
      setStatus("play");
    };
    utterance2.onpause = () => {
      setIsPlaying(false);
      setStatus("pause");
    };
    utterance2.onresume = () => {
      setIsPlaying(true);
      setStatus("play");
    };
    utterance2.onend = () => {
      setIsPlaying(false);
      setStatus("end");
    };
    utterance2.onerror = (event) => {
      setError(event);
    };
  };
  const utterance = solidJs.createMemo(() => {
    setIsPlaying(false);
    setStatus("init");
    const newUtterance = new SpeechSynthesisUtterance(spokenText());
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });
  const speak = () => {
    synth.cancel();
    utterance && synth.speak(utterance());
  };
  const stop = () => {
    synth.cancel();
    setIsPlaying(false);
  };
  if (isSupported()) {
    bindEventsForUtterance(utterance());
    solidJs.createEffect(
      solidJs.on(
        lang,
        (lang2) => {
          if (utterance() && !isPlaying())
            utterance().lang = lang2;
        },
        { defer: true }
      )
    );
    if (options.voice) {
      solidJs.createEffect(
        solidJs.on(
          shared.resolveAccessor(options.voice),
          () => {
            synth.cancel();
          },
          { defer: true }
        )
      );
    }
    solidJs.createEffect(
      solidJs.on(
        shared.resolveAccessor(isPlaying),
        () => {
          if (isPlaying())
            synth.resume();
          else
            synth.pause();
        },
        { defer: true }
      )
    );
  }
  shared.tryOnCleanup(() => {
    setIsPlaying(false);
  });
  return {
    isSupported,
    isPlaying,
    status,
    utterance,
    error,
    stop,
    toggle,
    speak
  };
}
function useStepper(steps, initialStep) {
  const stepsRef = shared.resolveAccessor(steps);
  const stepNames = solidJs.createMemo(() => Array.isArray(stepsRef()) ? stepsRef() : Object.keys(stepsRef()));
  const [index, setIndex] = solidJs.createSignal(stepNames().indexOf(initialStep ?? stepNames()[0]));
  const current = solidJs.createMemo(() => at(index()));
  const isFirst = solidJs.createMemo(() => index() === 0);
  const isLast = solidJs.createMemo(() => index() === stepNames().length - 1);
  const next = solidJs.createMemo(() => stepNames()[index() + 1]);
  const previous = solidJs.createMemo(() => stepNames()[index() - 1]);
  function at(index2) {
    if (Array.isArray(stepsRef()))
      return stepsRef()[index2];
    return stepsRef()[stepNames()[index2]];
  }
  function get(step) {
    if (!stepNames().includes(step))
      return;
    return at(stepNames().indexOf(step));
  }
  function goTo(step) {
    if (stepNames().includes(step))
      setIndex(stepNames().indexOf(step));
  }
  function goToNext() {
    if (isLast())
      return;
    setIndex((index2) => index2 + 1);
  }
  function goToPrevious() {
    if (isFirst())
      return;
    setIndex((index2) => index2 - 1);
  }
  function goBackTo(step) {
    if (isAfter(step))
      goTo(step);
  }
  function isNext(step) {
    return stepNames().indexOf(step) === index() + 1;
  }
  function isPrevious(step) {
    return stepNames().indexOf(step) === index() - 1;
  }
  function isCurrent(step) {
    return stepNames().indexOf(step) === index();
  }
  function isBefore(step) {
    return index() < stepNames().indexOf(step);
  }
  function isAfter(step) {
    return index() > stepNames().indexOf(step);
  }
  return {
    steps: stepsRef,
    stepNames,
    index,
    current,
    next,
    previous,
    isFirst,
    isLast,
    at,
    get,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}
function useStorageAsync(key, initialValue, storage, options = {}) {
  const {
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const rawInit = shared.unAccessor(initialValue);
  const type = guessSerializerType(rawInit);
  const [data, setData] = solidToVue.toSignal(initialValue);
  const serializer = options.serializer ?? StorageSerializers[type];
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => defaultWindow == null ? void 0 : defaultWindow.localStorage)();
    } catch (e) {
      onError(e);
    }
  }
  async function read(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : await storage.getItem(key);
      if (rawValue == null) {
        setData(() => rawInit);
        if (writeDefaults && rawInit !== null)
          await storage.setItem(key, await serializer.write(rawInit));
      } else if (mergeDefaults) {
        const value = await serializer.read(rawValue);
        if (shared.isFunction(mergeDefaults)) {
          setData(() => mergeDefaults(value, rawInit));
        } else if (type === "object" && !Array.isArray(value)) {
          setData({ ...rawInit, ...value });
        } else {
          setData(value);
        }
      } else {
        setData(await serializer.read(rawValue));
      }
    } catch (e) {
      onError(e);
    }
  }
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e) => setTimeout(() => read(e), 0));
  if (storage) {
    shared.watchWithFilter(
      data,
      async () => {
        try {
          const dataVal = data();
          if (dataVal == null)
            await storage.removeItem(key);
          else
            await storage.setItem(key, await serializer.write(dataVal));
        } catch (e) {
          onError(e);
        }
      },
      { eventFilter, defer: false }
    );
  }
  return data;
}
let _id = 0;
function useStyleTag(css, options = {}) {
  const [isLoaded, setIsLoaded] = solidJs.createSignal(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `solidjs-use_style_tag_${++_id}`
  } = options;
  const [cssAccessor, setCss] = solidToVue.toSignal(css);
  let stop = () => {
  };
  const load = () => {
    if (!document2)
      return;
    const el = document2.getElementById(id) ?? document2.createElement("style");
    if (!el.isConnected) {
      el.type = "text/css";
      el.id = id;
      if (options.media)
        el.media = options.media;
      document2.head.appendChild(el);
    }
    if (isLoaded())
      return;
    stop = shared.watch(cssAccessor, (value) => {
      el.innerText = value;
    });
    setIsLoaded(true);
  };
  const unload = () => {
    if (!document2 || !isLoaded())
      return;
    stop();
    document2.head.removeChild(document2.getElementById(id));
    setIsLoaded(false);
  };
  if (immediate && !manual)
    shared.tryOnMount(load);
  if (!manual)
    shared.tryOnCleanup(unload);
  return {
    id,
    css: cssAccessor,
    setCss,
    unload,
    load,
    isLoaded
  };
}
function useTextDirection(options = {}) {
  const { document: document2 = defaultDocument, selector = "html", observe = false, initialValue = "ltr" } = options;
  function getValue2() {
    var _a;
    return ((_a = document2 == null ? void 0 : document2.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) ?? initialValue;
  }
  const [dir, setDir] = solidJs.createSignal(getValue2());
  shared.tryOnMount(() => setDir(getValue2()));
  if (observe && document2) {
    useMutationObserver(document2.querySelector(selector), () => setDir(getValue2()), {
      attributes: true
    });
  }
  return {
    dir,
    setDir: (v) => {
      var _a, _b;
      setDir(v);
      if (!document2)
        return;
      if (dir())
        (_a = document2.querySelector(selector)) == null ? void 0 : _a.setAttribute("dir", dir());
      else
        (_b = document2.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
  };
}
function getRangesFromSelection(selection) {
  const rangeCount = selection.rangeCount ?? 0;
  const ranges = new Array(rangeCount);
  for (let i = 0; i < rangeCount; i++) {
    const range = selection.getRangeAt(i);
    ranges[i] = range;
  }
  return ranges;
}
function useTextSelection(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const [selection, setSelection] = solidJs.createSignal(null);
  const text = solidJs.createMemo(() => {
    var _a;
    return ((_a = selection()) == null ? void 0 : _a.toString()) ?? "";
  });
  const ranges = solidJs.createMemo(() => selection() ? getRangesFromSelection(selection()) : []);
  const rects = solidJs.createMemo(() => ranges().map((range) => range.getBoundingClientRect()));
  function onSelectionChange() {
    setSelection(null);
    if (window2)
      setSelection(window2.getSelection());
  }
  if (window2)
    useEventListener(window2.document, "selectionchange", onSelectionChange);
  return {
    text,
    rects,
    ranges,
    selection
  };
}
function useTextareaAutoSize(options) {
  const [textareaRef, setTextareaRef] = solidJs.createSignal(options == null ? void 0 : options.element);
  const [value, setValue] = solidJs.createSignal(options == null ? void 0 : options.input);
  function triggerResize() {
    var _a, _b;
    if (!textareaRef())
      return;
    textareaRef().style.height = "1px";
    textareaRef().style.height = `${(_a = textareaRef()) == null ? void 0 : _a.scrollHeight}px`;
    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);
  }
  solidJs.createEffect(solidJs.on([value, textareaRef], triggerResize));
  useResizeObserver(textareaRef, () => triggerResize());
  if (options == null ? void 0 : options.deps)
    solidJs.createEffect(solidJs.on(options.deps, triggerResize));
  const onChange = (event) => {
    setValue(event.currentTarget.value);
  };
  return {
    setTextareaRef,
    value,
    onChange,
    triggerResize
  };
}
function useThrottledHistoryTravel(source, options = {}) {
  const { throttle = 200, trailing = true } = options;
  const filter = shared.throttleFilter(throttle, trailing);
  const history = useHistoryTravel(source, { ...options, eventFilter: filter });
  return {
    ...history
  };
}
const DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Infinity, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: (n) => /\d/.exec(n) ? `${n} ago` : n,
  future: (n) => /\d/.exec(n) ? `in ${n}` : n,
  month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
  year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
  day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
  week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
  hour: (n) => `${n} hour${n > 1 ? "s" : ""}`,
  minute: (n) => `${n} minute${n > 1 ? "s" : ""}`,
  second: (n) => `${n} second${n > 1 ? "s" : ""}`,
  invalid: ""
};
const DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);
function useTimeAgo(time, options = {}) {
  const { controls: exposeControls = false, updateInterval = 3e4 } = options;
  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });
  const timeAgo = solidJs.createMemo(() => formatTimeAgo(new Date(shared.unAccessor(time)), options, shared.unAccessor(now())));
  if (exposeControls) {
    return {
      timeAgo,
      ...controls
    };
  }
  return timeAgo;
}
function formatTimeAgo(from, options = {}, now = Date.now()) {
  var _a;
  const {
    max,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER,
    units = DEFAULT_UNITS,
    showSecond = false,
    rounding = "round"
  } = options;
  const roundFn = typeof rounding === "number" ? (n) => +n.toFixed(rounding) : Math[rounding];
  const diff = +now - +from;
  const absDiff = Math.abs(diff);
  function getValue2(diff2, unit) {
    return roundFn(Math.abs(diff2) / unit.value);
  }
  function format(diff2, unit) {
    const val = getValue2(diff2, unit);
    const past = diff2 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  function applyFormat(name, val, isPast) {
    const formatter = messages[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  if (absDiff < 6e4 && !showSecond)
    return messages.justNow;
  if (typeof max === "number" && absDiff > max)
    return fullDateFormatter(new Date(from));
  if (typeof max === "string") {
    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;
    if (unitMax && absDiff > unitMax)
      return fullDateFormatter(new Date(from));
  }
  for (const [idx, unit] of units.entries()) {
    const val = getValue2(diff, unit);
    if (val <= 0 && units[idx - 1])
      return format(diff, units[idx - 1]);
    if (absDiff < unit.max)
      return format(diff, unit);
  }
  return messages.invalid;
}
function useTimestamp(options = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame",
    callback
  } = options;
  const tsSignal = solidJs.createSignal(shared.timestamp() + offset);
  const [ts, setTs] = tsSignal;
  const update = () => setTs(shared.timestamp() + offset);
  const cb = callback ? () => {
    update();
    callback(ts());
  } : update;
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : shared.useIntervalFn(cb, interval, { immediate });
  if (exposeControls) {
    return {
      timestamp: ts,
      ...controls
    };
  }
  return tsSignal;
}
function useTitle(newTitle = null, options = {}) {
  var _a;
  const { document: document2 = defaultDocument } = options;
  const title = solidToVue.toSignal(newTitle ?? (document2 == null ? void 0 : document2.title) ?? null);
  const isReadonly = !!(newTitle && solidToVue.isAccessor(newTitle));
  function format(t) {
    if (!("titleTemplate" in options))
      return t;
    const template = options.titleTemplate ?? "%s";
    return shared.isFunction(template) ? template(t) : shared.unAccessor(template).replace(/%s/g, t);
  }
  solidJs.createEffect(
    solidJs.on(title[0], (t, o) => {
      if (t !== o && document2)
        document2.title = format(shared.isString(t) ? t : "");
    })
  );
  if (options.observe && !options.titleTemplate && document2 && !isReadonly) {
    useMutationObserver(
      (_a = document2.head) == null ? void 0 : _a.querySelector("title"),
      () => {
        if (document2 && document2.title !== title[0]())
          title[1](format(document2.title));
      },
      { childList: true }
    );
  }
  if (isReadonly)
    return title[0];
  return title;
}
function useUrlSearchParams(mode = "history", options = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    write: enableWrite = true,
    window: window2 = defaultWindow
  } = options;
  if (!window2)
    return store.createMutable(initialValue);
  const state = store.createMutable({});
  function getRawParams() {
    if (mode === "history") {
      return window2.location.search || "";
    } else if (mode === "hash") {
      const hash = window2.location.hash || "";
      const index = hash.indexOf("?");
      return index > 0 ? hash.slice(index) : "";
    }
    return (window2.location.hash || "").replace(/^#/, "");
  }
  function constructQuery(params) {
    const stringified = params.toString();
    if (mode === "history")
      return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
    if (mode === "hash-params")
      return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window2.location.hash || "#";
    const index = hash.indexOf("?");
    if (index > 0)
      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
    return `${hash}${stringified ? `?${stringified}` : ""}`;
  }
  function read() {
    return new URLSearchParams(getRawParams());
  }
  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));
    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) ?? "";
      unusedKeys.delete(key);
    }
    Array.from(unusedKeys).forEach((key) => delete state[key]);
  }
  const { pause, resume } = shared.pausableWatch(
    state,
    () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key) => {
        const mapEntry = state[key];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value) => params.append(key, value));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key);
        else
          params.set(key, mapEntry);
      });
      write(params);
    },
    { defer: false }
  );
  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate)
      updateState(params);
    window2.history.replaceState(
      window2.history.state,
      window2.document.title,
      window2.location.pathname + constructQuery(params)
    );
    resume();
  }
  function onChanged() {
    if (!enableWrite)
      return;
    write(read(), true);
  }
  useEventListener(window2, "popstate", onChanged, false);
  if (mode !== "history")
    useEventListener(window2, "hashchange", onChanged, false);
  const initial = read();
  if (initial.keys().next().value)
    updateState(initial);
  else
    Object.assign(state, initialValue);
  return state;
}
function useUserMedia(options = {}) {
  const [enabled, setEnabled] = solidJs.createSignal(options.enabled ?? false);
  const [autoSwitch, setAutoSwitch] = solidJs.createSignal(options.autoSwitch ?? true);
  const videoDeviceId = shared.resolveAccessor(options.videoDeviceId);
  const audioDeviceId = shared.resolveAccessor(options.audioDeviceId);
  const { navigator = defaultNavigator } = options;
  const isSupported = useSupported(() => {
    var _a;
    return (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.getUserMedia;
  });
  const [stream, setStream] = solidJs.createSignal();
  function getDeviceOptions(device) {
    if (device === "none" || device === false)
      return false;
    if (device == null)
      return true;
    return {
      deviceId: device
    };
  }
  async function _start() {
    if (!isSupported() || stream())
      return;
    const streamValue = await navigator.mediaDevices.getUserMedia({
      video: getDeviceOptions(videoDeviceId()),
      audio: getDeviceOptions(audioDeviceId())
    });
    setStream(streamValue);
    return streamValue;
  }
  async function _stop() {
    var _a;
    (_a = stream()) == null ? void 0 : _a.getTracks().forEach((t) => t.stop());
    setStream(void 0);
  }
  function stop() {
    _stop();
    setEnabled(false);
  }
  async function start() {
    await _start();
    if (stream())
      setEnabled(true);
    return stream();
  }
  async function restart() {
    _stop();
    return start();
  }
  solidJs.createEffect(
    solidJs.on(enabled, (v) => {
      if (v)
        _start();
      else
        _stop();
    })
  );
  solidJs.createEffect(
    solidJs.on([videoDeviceId, audioDeviceId], () => {
      if (autoSwitch() && stream())
        restart();
    })
  );
  return {
    isSupported,
    stream,
    start,
    stop,
    restart,
    videoDeviceId,
    audioDeviceId,
    enabled,
    setEnabled,
    autoSwitch,
    setAutoSwitch
  };
}
function useVibrate(options) {
  const { pattern = [], interval = 0, navigator = defaultNavigator } = options ?? {};
  const isSupported = useSupported(() => typeof navigator !== "undefined" && "vibrate" in navigator);
  const patternAccessor = shared.resolveAccessor(pattern);
  let intervalControls;
  const vibrate = (pattern2 = patternAccessor()) => {
    if (isSupported())
      navigator.vibrate(pattern2);
  };
  const stop = () => {
    if (isSupported())
      navigator.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  };
  if (interval > 0) {
    intervalControls = shared.useIntervalFn(vibrate, interval, {
      immediate: false,
      immediateCallback: false
    });
  }
  return {
    isSupported,
    pattern,
    intervalControls,
    vibrate,
    stop
  };
}
function useVirtualList(list, options) {
  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, setContainerRef } = "itemHeight" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);
  return {
    list: currentList,
    scrollTo,
    containerProps: {
      ref: (el) => setContainerRef(el),
      onScroll: () => {
        calculateRange();
      },
      style: containerStyle
    },
    wrapperProps
  };
}
function useVirtualListResourses(list) {
  const [containerRef, setContainerRef] = solidJs.createSignal(null);
  const size = useElementSize(containerRef);
  const [currentList, setCurrentList] = solidJs.createSignal([]);
  const [source, setSource] = solidToVue.toSignal(list);
  const [state, setState] = solidJs.createSignal({ start: 0, end: 10 });
  return { state, setState, currentList, setCurrentList, source, setSource, setContainerRef, containerRef, size };
}
function createGetViewCapacity(state, source, itemSize) {
  return (containerSize) => {
    if (typeof itemSize === "number")
      return Math.ceil(containerSize / itemSize);
    const { start = 0 } = state();
    let sum = 0;
    let capacity = 0;
    for (let i = start; i < source().length; i++) {
      const size = itemSize(i);
      sum += size;
      capacity = i;
      if (sum > containerSize) {
        capacity = i;
        break;
      }
    }
    return capacity - start;
  };
}
function createGetOffset(source, itemSize) {
  return (scrollDirection) => {
    if (typeof itemSize === "number")
      return Math.floor(scrollDirection / itemSize) + 1;
    let sum = 0;
    let offset = 0;
    for (let i = 0; i < source().length; i++) {
      const size = itemSize(i);
      sum += size;
      if (sum >= scrollDirection) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
}
function createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, setState, source, setCurrentList }) {
  return () => {
    const element = containerRef();
    if (element) {
      const offset = getOffset(type === "vertical" ? element.scrollTop : element.scrollLeft);
      const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      setState({
        start: from < 0 ? 0 : from,
        end: to > source().length ? source().length : to
      });
      setCurrentList(
        source().slice(state().start, state().end).map((ele, index) => ({
          data: ele,
          index: index + state().start
        }))
      );
    }
  };
}
function createGetDistance(itemSize, source) {
  return (index) => {
    if (typeof itemSize === "number") {
      const size2 = index * itemSize;
      return size2;
    }
    const size = source().slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);
    return size;
  };
}
function useWatchForSizes(size, list, calculateRange) {
  shared.watch(
    [size.width, size.height, shared.resolveAccessor(list)],
    () => {
      calculateRange();
    },
    { defer: true }
  );
}
function createComputedTotalSize(itemSize, source) {
  return solidJs.createMemo(() => {
    if (typeof itemSize === "number")
      return source().length * itemSize;
    return source().reduce((sum, _, index) => sum + itemSize(index), 0);
  });
}
const scrollToDictionaryForElementScrollKey = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef) {
  return (index) => {
    const el = containerRef();
    if (el) {
      el[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);
      calculateRange();
    }
  };
}
function useHorizontalVirtualList(options, list) {
  const resources = useVirtualListResourses(list);
  const { state, source, currentList, size, containerRef, setContainerRef } = resources;
  const containerStyle = { "overflow-x": "auto" };
  const { itemWidth, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
  const getOffset = createGetOffset(source, itemWidth);
  const calculateRange = createCalculateRange("horizontal", overscan, getOffset, getViewCapacity, resources);
  const getDistanceLeft = createGetDistance(itemWidth, source);
  const offsetLeft = solidJs.createMemo(() => getDistanceLeft(state().start));
  const totalWidth = createComputedTotalSize(itemWidth, source);
  useWatchForSizes(size, list, calculateRange);
  const scrollTo = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef);
  const wrapperProps = solidJs.createMemo(() => {
    return {
      style: {
        height: "100%",
        width: `${totalWidth() - offsetLeft()}px`,
        "margin-left": `${offsetLeft()}px`,
        display: "flex"
      }
    };
  });
  return {
    scrollTo,
    calculateRange,
    wrapperProps,
    containerStyle,
    setContainerRef,
    currentList,
    containerRef
  };
}
function useVerticalVirtualList(options, list) {
  const resources = useVirtualListResourses(list);
  const { state, source, currentList, size, containerRef, setContainerRef } = resources;
  const containerStyle = { "overflow-y": "auto" };
  const { itemHeight, overscan = 5 } = options;
  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
  const getOffset = createGetOffset(source, itemHeight);
  const calculateRange = createCalculateRange("vertical", overscan, getOffset, getViewCapacity, resources);
  const getDistanceTop = createGetDistance(itemHeight, source);
  const offsetTop = solidJs.createMemo(() => getDistanceTop(state().start));
  const totalHeight = createComputedTotalSize(itemHeight, source);
  useWatchForSizes(size, list, calculateRange);
  const scrollTo = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef);
  const wrapperProps = solidJs.createMemo(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight() - offsetTop()}px`,
        "margin-top": `${offsetTop()}px`
      }
    };
  });
  return {
    calculateRange,
    scrollTo,
    containerStyle,
    wrapperProps,
    currentList,
    containerRef,
    setContainerRef
  };
}
const useWakeLock = (options = {}) => {
  const { navigator = defaultNavigator, document: document2 = defaultDocument } = options;
  let wakeLock;
  const isSupported = useSupported(() => navigator && "wakeLock" in navigator);
  const [isActive, setIsActive] = solidJs.createSignal(false);
  async function onVisibilityChange() {
    if (!isSupported() || !wakeLock)
      return;
    if (document2 && document2.visibilityState === "visible")
      wakeLock = await navigator.wakeLock.request("screen");
    setIsActive(!wakeLock.released);
  }
  if (document2)
    useEventListener(document2, "visibilitychange", onVisibilityChange, { passive: true });
  async function request(type) {
    if (!isSupported())
      return;
    wakeLock = await navigator.wakeLock.request(type);
    setIsActive(!wakeLock.released);
  }
  async function release() {
    if (!isSupported() || !wakeLock)
      return;
    await wakeLock.release();
    setIsActive(!wakeLock.released);
    wakeLock = null;
  }
  return {
    isSupported,
    isActive,
    request,
    release
  };
};
const useWebNotification = (defaultOptions2 = {}) => {
  const { window: window2 = defaultWindow } = defaultOptions2;
  const isSupported = useSupported(() => !!window2 && "Notification" in window2);
  const [notification, setNotification] = solidJs.createSignal(null);
  const requestPermission = async () => {
    if (!isSupported())
      return;
    if ("permission" in Notification && Notification.permission !== "denied")
      await Notification.requestPermission();
  };
  const onClick = shared.createEventHook();
  const onShow = shared.createEventHook();
  const onError = shared.createEventHook();
  const onClose = shared.createEventHook();
  const show = async (overrides) => {
    if (!isSupported())
      return;
    await requestPermission();
    const options = Object.assign({}, defaultOptions2, overrides);
    const notificationValue = new Notification(options.title ?? "", options);
    setNotification(notificationValue);
    notificationValue.onclick = (event) => onClick.trigger(event);
    notificationValue.onshow = (event) => onShow.trigger(event);
    notificationValue.onerror = (event) => onError.trigger(event);
    notificationValue.onclose = (event) => onClose.trigger(event);
    return notificationValue;
  };
  const close = () => {
    const notificationValue = notification();
    if (notificationValue)
      notificationValue.close();
    setNotification(null);
  };
  shared.tryOnMount(async () => {
    if (isSupported())
      await requestPermission();
  });
  shared.tryOnCleanup(close);
  if (isSupported() && window2) {
    const document2 = window2.document;
    useEventListener(document2, "visibilitychange", (e) => {
      e.preventDefault();
      if (document2.visibilityState === "visible") {
        close();
      }
    });
  }
  return {
    isSupported,
    notification,
    show,
    close,
    onClick,
    onShow,
    onError,
    onClose
  };
};
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options) {
  if (options === true)
    return {};
  return options;
}
function useWebSocket(url, options = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoClose = true,
    protocols = []
  } = options;
  const [data, setData] = solidJs.createSignal(null);
  const [status, setStatus] = solidJs.createSignal("CLOSED");
  const [wsAccessor, setWs] = solidJs.createSignal();
  const urlAccessor = shared.resolveAccessor(url);
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];
  let pongTimeoutWait;
  const close = (code = 1e3, reason) => {
    const wsRefVal = wsAccessor();
    if (!wsRefVal)
      return;
    explicitlyClosed = true;
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRefVal.close(code, reason);
  };
  const _sendBuffer = () => {
    const wsRefVal = wsAccessor();
    if (bufferedData.length && wsRefVal && status() === "OPEN") {
      for (const buffer of bufferedData)
        wsRefVal.send(buffer);
      bufferedData = [];
    }
  };
  const resetHeartbeat = () => {
    clearTimeout(pongTimeoutWait);
    pongTimeoutWait = void 0;
  };
  const send = (data2, useBuffer = true) => {
    const wsRefVal = wsAccessor();
    if (!wsRefVal || status() !== "OPEN") {
      if (useBuffer)
        bufferedData.push(data2);
      return false;
    }
    _sendBuffer();
    wsRefVal.send(data2);
    return true;
  };
  const _init = () => {
    const urlValue = urlAccessor();
    if (explicitlyClosed || typeof urlValue === "undefined")
      return;
    const ws = new WebSocket(urlValue, protocols);
    setWs(ws);
    setStatus("CONNECTING");
    ws.onopen = () => {
      setStatus("OPEN");
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();
      _sendBuffer();
    };
    ws.onclose = (ev) => {
      setStatus("CLOSED");
      setWs(void 0);
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);
      if (!explicitlyClosed && options.autoReconnect) {
        const { retries = -1, delay = 1e3, onFailed } = resolveNestedOptions(options.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    ws.onerror = (e) => {
      onError == null ? void 0 : onError(ws, e);
    };
    ws.onmessage = (e) => {
      if (options.heartbeat) {
        resetHeartbeat();
        const { message = DEFAULT_PING_MESSAGE } = resolveNestedOptions(options.heartbeat);
        if (e.data === message)
          return;
      }
      setData(e.data);
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  };
  if (options.heartbeat) {
    const {
      message = DEFAULT_PING_MESSAGE,
      interval = 1e3,
      pongTimeout = 1e3
    } = resolveNestedOptions(options.heartbeat);
    const { pause, resume } = shared.useIntervalFn(
      () => {
        send(message, false);
        if (pongTimeoutWait != null)
          return;
        pongTimeoutWait = setTimeout(() => {
          close();
        }, pongTimeout);
      },
      interval,
      { immediate: false }
    );
    heartbeatPause = pause;
    heartbeatResume = resume;
  }
  if (autoClose) {
    useEventListener(window, "beforeunload", () => close());
    shared.tryOnCleanup(close);
  }
  const open = () => {
    close();
    explicitlyClosed = false;
    retried = 0;
    _init();
  };
  if (immediate) {
    solidJs.createEffect(solidJs.on(urlAccessor, open));
  }
  return {
    data,
    status,
    close,
    send,
    open,
    ws: wsAccessor
  };
}
function useWebWorker(arg0, workerOptions, options) {
  const { window: window2 = defaultWindow } = options ?? {};
  const [data, setData] = solidJs.createSignal(null);
  const [worker, setWorker] = solidJs.createSignal();
  const post = function post2(val) {
    const workerValue = worker();
    if (!workerValue)
      return;
    workerValue.postMessage(val);
  };
  const terminate = function terminate2() {
    const workerValue = worker();
    if (!workerValue)
      return;
    workerValue.terminate();
  };
  if (window2) {
    if (shared.isString(arg0))
      setWorker(new Worker(arg0, workerOptions));
    else if (shared.isFunction(arg0))
      setWorker(arg0());
    else
      setWorker(arg0);
    const workValue = worker();
    workValue.onmessage = (e) => {
      setData(e.data);
    };
    shared.tryOnCleanup(() => {
      if (worker())
        worker().terminate();
    });
  }
  return {
    data,
    post,
    terminate,
    worker
  };
}
const jobRunner = (userFunc) => (e) => {
  const userFuncArgs = e.data[0];
  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
    postMessage(["SUCCESS", result]);
  }).catch((error) => {
    postMessage(["ERROR", error]);
  });
};
const depsParser = (deps) => {
  if (deps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  return `importScripts(${depsString})`;
};
const createWorkerBlobUrl = (fn, deps) => {
  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
};
const useWebWorkerFn = (fn, options = {}) => {
  const { dependencies = [], timeout, window: window2 = defaultWindow } = options;
  const [worker, setWorker] = solidJs.createSignal();
  const [workerStatus, setWorkerStatus] = solidJs.createSignal("PENDING");
  const [promise, setPromise] = solidJs.createSignal({});
  const [timeoutId, setTimeoutId] = solidJs.createSignal();
  const workerTerminate = (status = "PENDING") => {
    const workerVal = worker();
    if ((workerVal == null ? void 0 : workerVal._url) && window2) {
      workerVal.terminate();
      URL.revokeObjectURL(workerVal._url);
      setPromise({});
      setWorker(void 0);
      window2.clearTimeout(timeoutId());
      setWorkerStatus(status);
    }
  };
  workerTerminate();
  shared.tryOnCleanup(workerTerminate);
  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve = () => {
      }, reject = () => {
      } } = promise();
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;
        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject = () => {
      } } = promise();
      reject(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      setTimeoutId(setTimeout(() => workerTerminate("TIMEOUT_EXPIRED"), timeout));
    }
    return newWorker;
  };
  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    var _a;
    setPromise({
      resolve,
      reject
    });
    (_a = worker()) == null ? void 0 : _a.postMessage([[...fnArgs]]);
    setWorkerStatus("RUNNING");
  });
  const workerFn = (...fnArgs) => {
    if (workerStatus() === "RUNNING") {
      console.error("[useWebWorkerFn] You can only run one instance of the worker at a time.");
      return Promise.reject();
    }
    setWorker(generateWorker());
    return callWorker(...fnArgs);
  };
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
};
function useWindowFocus({ window: window2 = defaultWindow } = {}) {
  if (!window2) {
    const [res] = solidJs.createSignal(false);
    return res;
  }
  const [focused, setFocused] = solidJs.createSignal(window2.document.hasFocus());
  useEventListener(window2, "blur", () => {
    setFocused(false);
  });
  useEventListener(window2, "focus", () => {
    setFocused(true);
  });
  return focused;
}
function useWindowScroll({ window: window2 = defaultWindow } = {}) {
  if (!window2) {
    const [x2] = solidJs.createSignal(0);
    const [y2] = solidJs.createSignal(0);
    return {
      x: x2,
      y: y2
    };
  }
  const [x, setX] = solidJs.createSignal(window2.scrollX);
  const [y, setY] = solidJs.createSignal(window2.scrollY);
  useEventListener(
    window2,
    "scroll",
    () => {
      setX(window2.scrollX);
      setY(window2.scrollY);
    },
    {
      capture: false,
      passive: true
    }
  );
  return { x, y };
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Infinity,
    initialHeight = Infinity,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const [width, setWidth] = solidJs.createSignal(initialWidth);
  const [height, setHeight] = solidJs.createSignal(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        setWidth(window2.innerWidth);
        setHeight(window2.innerHeight);
      } else {
        setWidth(window2.document.documentElement.clientWidth);
        setHeight(window2.document.documentElement.clientHeight);
      }
    }
  };
  update();
  shared.tryOnMount(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation)
    useEventListener("orientationchange", update, { passive: true });
  return { width, height };
}
exports.DefaultMagicKeysAliasMap = DefaultMagicKeysAliasMap;
exports.StorageSerializers = StorageSerializers;
exports.SwipeDirection = SwipeDirection;
exports.TransitionPresets = TransitionPresets;
exports.asyncMemo = createAsyncMemo;
exports.breakpointsAntDesign = breakpointsAntDesign;
exports.breakpointsBootstrapV5 = breakpointsBootstrapV5;
exports.breakpointsMasterCss = breakpointsMasterCss;
exports.breakpointsQuasar = breakpointsQuasar;
exports.breakpointsSematic = breakpointsSematic;
exports.breakpointsTailwind = breakpointsTailwind;
exports.breakpointsVuetify = breakpointsVuetify;
exports.cloneFnJSON = cloneFnJSON;
exports.createAsyncMemo = createAsyncMemo;
exports.createFetch = createFetch;
exports.createUnAccessorFn = createUnAccessorFn;
exports.customStorageEventName = customStorageEventName;
exports.defaultDocument = defaultDocument;
exports.defaultLocation = defaultLocation;
exports.defaultNavigator = defaultNavigator;
exports.defaultWindow = defaultWindow;
exports.formatTimeAgo = formatTimeAgo;
exports.getSSRHandler = getSSRHandler;
exports.getSetCompat = getSetCompat;
exports.mapGamepadToXbox360Controller = mapGamepadToXbox360Controller;
exports.onClickOutside = onClickOutside;
exports.onKeyDown = onKeyDown;
exports.onKeyPressed = onKeyPressed;
exports.onKeyStroke = onKeyStroke;
exports.onKeyUp = onKeyUp;
exports.onLongPress = onLongPress;
exports.onStartTyping = onStartTyping;
exports.setSSRHandler = setSSRHandler;
exports.useActiveElement = useActiveElement;
exports.useAsyncState = useAsyncState;
exports.useBase64 = useBase64;
exports.useBattery = useBattery;
exports.useBluetooth = useBluetooth;
exports.useBreakpoints = useBreakpoints;
exports.useBroadcastChannel = useBroadcastChannel;
exports.useBrowserLocation = useBrowserLocation;
exports.useClipboard = useClipboard;
exports.useCloned = useCloned;
exports.useColorMode = useColorMode;
exports.useConfirmDialog = useConfirmDialog;
exports.useCssTransition = useCssTransition;
exports.useCssVar = useCssVar;
exports.useCycleList = useCycleList;
exports.useDark = useDark;
exports.useDebouncedHistoryTravel = useDebouncedHistoryTravel;
exports.useDeviceMotion = useDeviceMotion;
exports.useDeviceOrientation = useDeviceOrientation;
exports.useDevicePixelRatio = useDevicePixelRatio;
exports.useDevicesList = useDevicesList;
exports.useDisplayMedia = useDisplayMedia;
exports.useDocumentVisibility = useDocumentVisibility;
exports.useDraggable = useDraggable;
exports.useDropZone = useDropZone;
exports.useElementBounding = useElementBounding;
exports.useElementByPoint = useElementByPoint;
exports.useElementHover = useElementHover;
exports.useElementSize = useElementSize;
exports.useElementVisibility = useElementVisibility;
exports.useEventBus = useEventBus;
exports.useEventListener = useEventListener;
exports.useEventSource = useEventSource;
exports.useEyeDropper = useEyeDropper;
exports.useFavicon = useFavicon;
exports.useFetch = useFetch;
exports.useFileDialog = useFileDialog;
exports.useFileSystemAccess = useFileSystemAccess;
exports.useFocus = useFocus;
exports.useFocusWithin = useFocusWithin;
exports.useFps = useFps;
exports.useFullscreen = useFullscreen;
exports.useGamepad = useGamepad;
exports.useGeolocation = useGeolocation;
exports.useHistoryTravel = useHistoryTravel;
exports.useIdle = useIdle;
exports.useImage = useImage;
exports.useInfiniteScroll = useInfiniteScroll;
exports.useIntersectionObserver = useIntersectionObserver;
exports.useKeyModifier = useKeyModifier;
exports.useLocalStorage = useLocalStorage;
exports.useMagicKeys = useMagicKeys;
exports.useManualHistoryTravel = useManualHistoryTravel;
exports.useMediaControls = useMediaControls;
exports.useMediaQuery = useMediaQuery;
exports.useMemoize = useMemoize;
exports.useMemory = useMemory;
exports.useMounted = useMounted;
exports.useMouse = useMouse;
exports.useMouseInElement = useMouseInElement;
exports.useMousePressed = useMousePressed;
exports.useMutationObserver = useMutationObserver;
exports.useNavigatorLanguage = useNavigatorLanguage;
exports.useNetwork = useNetwork;
exports.useNow = useNow;
exports.useObjectUrl = useObjectUrl;
exports.useOffsetPagination = useOffsetPagination;
exports.useOnline = useOnline;
exports.usePageLeave = usePageLeave;
exports.useParallax = useParallax;
exports.usePermission = usePermission;
exports.usePointer = usePointer;
exports.usePointerLock = usePointerLock;
exports.usePointerSwipe = usePointerSwipe;
exports.usePreferredColorScheme = usePreferredColorScheme;
exports.usePreferredContrast = usePreferredContrast;
exports.usePreferredDark = usePreferredDark;
exports.usePreferredLanguages = usePreferredLanguages;
exports.usePreferredReducedMotion = usePreferredReducedMotion;
exports.usePrevious = usePrevious;
exports.useRafFn = useRafFn;
exports.useResizeObserver = useResizeObserver;
exports.useScreenOrientation = useScreenOrientation;
exports.useScreenSafeArea = useScreenSafeArea;
exports.useScriptTag = useScriptTag;
exports.useScroll = useScroll;
exports.useScrollLock = useScrollLock;
exports.useSessionStorage = useSessionStorage;
exports.useShare = useShare;
exports.useSpeechRecognition = useSpeechRecognition;
exports.useSpeechSynthesis = useSpeechSynthesis;
exports.useStepper = useStepper;
exports.useStorage = useStorage;
exports.useStorageAsync = useStorageAsync;
exports.useStyleTag = useStyleTag;
exports.useSupported = useSupported;
exports.useSwipe = useSwipe;
exports.useTextDirection = useTextDirection;
exports.useTextSelection = useTextSelection;
exports.useTextareaAutoSize = useTextareaAutoSize;
exports.useThrottledHistoryTravel = useThrottledHistoryTravel;
exports.useTimeAgo = useTimeAgo;
exports.useTimestamp = useTimestamp;
exports.useTitle = useTitle;
exports.useUrlSearchParams = useUrlSearchParams;
exports.useUserMedia = useUserMedia;
exports.useVibrate = useVibrate;
exports.useVirtualList = useVirtualList;
exports.useWakeLock = useWakeLock;
exports.useWebNotification = useWebNotification;
exports.useWebSocket = useWebSocket;
exports.useWebWorker = useWebWorker;
exports.useWebWorkerFn = useWebWorkerFn;
exports.useWindowFocus = useWindowFocus;
exports.useWindowScroll = useWindowScroll;
exports.useWindowSize = useWindowSize;
Object.keys(shared).forEach((k) => {
  if (k !== "default" && !exports.hasOwnProperty(k))
    Object.defineProperty(exports, k, {
      enumerable: true,
      get: () => shared[k]
    });
});
