var _a;
import { getOwner, createSignal, runWithOwner, createEffect, on, createMemo, onCleanup, createRoot, onMount } from "solid-js";
import { isAccessor, nextTick, reactive, toSignal, isSignal } from "@solidjs-use/solid-to-vue";
import { nextTick as nextTick2 } from "@solidjs-use/solid-to-vue";
import { createMutable } from "solid-js/store";
function unAccessor(r) {
  return typeof r === "function" ? r() : r;
}
const isClient = typeof window !== "undefined";
const isDef = (val) => typeof val !== "undefined";
const assert = (condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
};
const toString = Object.prototype.toString;
const isBoolean = (val) => typeof val === "boolean";
const isFunction = (val) => typeof val === "function";
const isNumber = (val) => typeof val === "number";
const isString = (val) => typeof val === "string";
const isObject = (val) => toString.call(val) === "[object Object]";
const isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
const now = () => Date.now();
const timestamp = () => +Date.now();
const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
const noop = () => {
};
const rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const owner = getOwner();
  const filter = (invoke2) => {
    const duration = unAccessor(ms);
    const maxDuration = unAccessor(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return new Promise((resolve) => {
        runWithOwner(owner, () => {
          resolve(invoke2());
        });
      });
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke2());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke2());
      }, duration);
    });
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop;
  let lastValue;
  const owner = getOwner();
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop;
    }
  };
  const filter = (_invoke) => {
    const duration = unAccessor(ms);
    const elapsed = Date.now() - lastExec;
    const invoke2 = () => {
      return lastValue = _invoke();
    };
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      runWithOwner(owner, () => {
        invoke2();
      });
      return;
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      runWithOwner(owner, () => {
        invoke2();
      });
    } else if (trailing) {
      lastValue = new Promise((resolve, reject) => {
        lastRejector = rejectOnCancel ? reject : resolve;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          runWithOwner(owner, () => {
            resolve(invoke2());
          });
          clear();
        }, Math.max(0, duration - elapsed));
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const [isActive, setIsActive] = createSignal(true);
  function pause() {
    setIsActive(false);
  }
  function resume() {
    setIsActive(true);
  }
  const eventFilter = (...args) => {
    if (isActive())
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve, ms);
  });
}
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function invoke(fn) {
  return fn();
}
function containsProp(obj, ...props) {
  return props.some((k) => k in obj);
}
function increaseWithUnit(target, delta) {
  var _a2;
  if (typeof target === "number")
    return target + delta;
  const value = ((_a2 = /^-?[0-9]+\.?[0-9]*/.exec(target)) == null ? void 0 : _a2[0]) ?? "";
  const unit = target.slice(value.length);
  const result = parseFloat(value) + delta;
  if (Number.isNaN(result))
    return target;
  return `${result}${unit}`;
}
function objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}
function accessorDebounced(value, ms = 200, options = {}) {
  const [debounced, setDebounced] = createSignal(value());
  const updater = useDebounceFn(
    () => {
      setDebounced(() => value());
    },
    ms,
    options
  );
  createEffect(
    on(
      value,
      () => {
        updater();
      },
      { defer: true }
    )
  );
  return debounced;
}
function accessorDefault(source, defaultValue) {
  return createMemo(() => source() ?? defaultValue);
}
function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);
}
function accessorThrottled(value, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value;
  const [throttled, setThrottled] = createSignal(value());
  const updater = useThrottleFn(
    () => {
      setThrottled(() => value());
    },
    delay,
    trailing,
    leading
  );
  createEffect(
    on(
      value,
      () => {
        updater();
      },
      { defer: true }
    )
  );
  return throttled;
}
function tryOnCleanup(fn) {
  if (getOwner()) {
    onCleanup(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = [];
  const off = (fn) => {
    const index = fns.indexOf(fn);
    if (index !== -1)
      fns.splice(index, 1);
  };
  const on2 = (fn) => {
    fns.push(fn);
    const offFn = () => off(fn);
    tryOnCleanup(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (param) => {
    fns.forEach((fn) => fn(param));
  };
  return {
    on: on2,
    off,
    trigger
  };
}
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let disposer;
  const dispose = () => {
    subscribers -= 1;
    if (disposer && subscribers <= 0) {
      disposer();
      state = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      createRoot((_disposer) => {
        disposer = _disposer;
        state = composable(...args);
      });
    }
    tryOnCleanup(dispose);
    return state;
  };
}
function get(obj, key) {
  if (key == null)
    return unAccessor(obj);
  return unAccessor(obj)[key];
}
function isDefined(v) {
  return unAccessor(v) != null;
}
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = { ...obj };
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index = 0;
        return {
          next: () => ({
            value: arr[index++],
            done: index > arr.length
          })
        };
      }
    });
    return clone;
  }
  return Object.assign([...arr], obj);
}
function toReactive(objectAccessor) {
  if (!isAccessor(objectAccessor))
    return createMutable(objectAccessor);
  const proxy = new Proxy(
    {},
    {
      get(_, p, receiver) {
        return unAccessor(Reflect.get(objectAccessor(), p, receiver));
      },
      has(_, p) {
        return Reflect.has(objectAccessor(), p);
      },
      ownKeys() {
        return Object.keys(objectAccessor());
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    }
  );
  return proxy;
}
function mutableMemo(fn) {
  return toReactive(createMemo(fn));
}
function omitMutable(obj, ...keys) {
  const res = createMutable({});
  const validKeys = createMemo(() => {
    const flatKeys = keys.flat();
    const allKeys = Object.keys(obj);
    const validKeys2 = allKeys.filter((key) => !flatKeys.includes(key));
    return validKeys2;
  });
  return new Proxy({}, {
    get(_, p, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.get(obj, p, receiver);
      }
      return Reflect.get(res, p, receiver);
    },
    set(_, p, newValue, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.set(obj, p, newValue, receiver);
      }
      return Reflect.set(res, p, newValue, receiver);
    },
    ownKeys() {
      return [...validKeys(), ...Object.keys(res)];
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
}
function pickMutable(obj, ...keys) {
  const res = createMutable({});
  const validKeys = createMemo(() => {
    const flatKeys = keys.flat();
    const allKeys = Object.keys(obj);
    const validKeys2 = allKeys.filter((key) => flatKeys.includes(key));
    return validKeys2;
  });
  return new Proxy({}, {
    get(_, p, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.get(obj, p, receiver);
      }
      return Reflect.get(res, p, receiver);
    },
    set(_, p, newValue, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.set(obj, p, newValue, receiver);
      }
      return Reflect.set(res, p, newValue, receiver);
    },
    ownKeys() {
      return [...validKeys(), ...Object.keys(res)];
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
}
function reactify(fn) {
  return function(...args) {
    return createMemo(
      () => fn.apply(
        this,
        args.map((i) => unAccessor(i))
      )
    );
  };
}
function reactifyObject(obj, optionsOrKeys = {}) {
  let keys = [];
  if (Array.isArray(optionsOrKeys)) {
    keys = optionsOrKeys;
  } else {
    const { includeOwnProperties = true } = optionsOrKeys;
    keys.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(
    keys.map((key) => {
      const value = obj[key];
      return [key, typeof value === "function" ? reactify(value.bind(obj)) : value];
    })
  );
}
function resolveAccessor(r) {
  return isAccessor(r) ? r : () => r;
}
function signalAutoReset(defaultValue, afterMs = 1e4) {
  const [value, setVal] = createSignal(defaultValue);
  let timer;
  const resetAfter = () => setTimeout(() => {
    setVal(() => defaultValue);
  }, unAccessor(afterMs));
  tryOnCleanup(() => {
    clearTimeout(timer);
  });
  const setNewVal = (newValue) => {
    setVal(newValue);
    clearTimeout(timer);
    timer = resetAfter();
  };
  return [value, setNewVal];
}
function toAccessors(props, defaultProps) {
  const obj = {};
  Object.keys(props).forEach((key) => {
    obj[key] = createMemo(() => props[key] ?? (defaultProps == null ? void 0 : defaultProps[key]));
  });
  return obj;
}
function watch(deps, fn, options) {
  const [isWatch, setIsWatch] = createSignal(true);
  createEffect(
    on(
      getAccessors(deps),
      (input, prevInput, prev) => {
        if (isWatch()) {
          fn(input, prevInput, prev);
        }
      },
      options
    )
  );
  const stop = () => {
    setIsWatch(false);
  };
  return stop;
}
function getAccessors(deps) {
  if (Array.isArray(deps))
    return deps;
  if (isObject(deps)) {
    return Object.values(toAccessors(deps));
  }
  if (isAccessor(deps))
    return deps;
  return () => deps;
}
function syncSignal([left, setLeft], [right, setRight], options = {}) {
  const { defer, direction = "both", transform = {} } = options;
  let watchLeft;
  let watchRight;
  const transformLTR = transform.ltr ?? ((v) => v);
  const transformRTL = transform.rtl ?? ((v) => v);
  if (direction === "both" || direction === "ltr") {
    watchLeft = watch(
      left,
      (newValue) => {
        setRight(() => transformLTR(newValue));
      },
      { defer }
    );
  }
  if (direction === "both" || direction === "rtl") {
    watchRight = watch(
      right,
      (newValue) => {
        setLeft(() => transformRTL(newValue));
      },
      { defer }
    );
  }
  return () => {
    watchLeft == null ? void 0 : watchLeft();
    watchRight == null ? void 0 : watchRight();
  };
}
function syncSignals(source, targets, options = {}) {
  if (!Array.isArray(targets))
    targets = [targets];
  return watch(
    source,
    (newValue) => {
      targets.forEach((setTarget) => setTarget(() => newValue));
    },
    options
  );
}
function tryOnMount(fn, sync = true) {
  if (getOwner())
    onMount(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function createUntil(r, isNot = false, selfOwner) {
  const owner = selfOwner ?? getOwner();
  function toMatch(condition, { timeout, throwOnTimeout } = {}) {
    let stop = null;
    const watcher = new Promise((resolve) => {
      runWithOwner(owner, () => {
        stop = watch(r, (v) => {
          if (condition(v) !== isNot) {
            stop == null ? void 0 : stop();
            resolve(v);
          }
        });
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => unAccessor(r)).finally(() => stop == null ? void 0 : stop())
      );
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!isAccessor(value))
      return toMatch((v) => v === value, options);
    const { timeout, throwOnTimeout } = options ?? {};
    let stop = null;
    const watcher = new Promise((resolve) => {
      runWithOwner(owner, () => {
        stop = watch([r, value], ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            stop == null ? void 0 : stop();
            resolve(v1);
          }
        });
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => unAccessor(r)).finally(() => {
          stop == null ? void 0 : stop();
          return unAccessor(r);
        })
      );
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(unAccessor(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(unAccessor(r))) {
    const instance2 = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot, owner);
      }
    };
    return instance2;
  }
  const instance = {
    toMatch,
    toBe,
    toBeTruthy,
    toBeNull,
    toBeNaN,
    toBeUndefined,
    changed,
    changedTimes,
    get not() {
      return createUntil(r, !isNot, owner);
    }
  };
  return instance;
}
function until(r, owner) {
  return createUntil(r, false, owner);
}
function useArrayEvery(list, fn) {
  return createMemo(() => unAccessor(list).every((element, index, array) => fn(unAccessor(element), index, array)));
}
function useArrayFilter(list, fn) {
  return createMemo(
    () => unAccessor(list).map((i) => unAccessor(i)).filter(fn)
  );
}
function useArrayFind(list, fn) {
  return createMemo(
    () => unAccessor(unAccessor(list).find((element, index, array) => fn(unAccessor(element), index, array)))
  );
}
function useArrayFindIndex(list, fn) {
  return createMemo(() => unAccessor(list).findIndex((element, index, array) => fn(unAccessor(element), index, array)));
}
function findLast(arr, cb) {
  let index = arr.length;
  while (index-- > 0) {
    if (cb(arr[index], index, arr))
      return arr[index];
  }
  return void 0;
}
function useArrayFindLast(list, fn) {
  return createMemo(
    () => unAccessor(
      // @ts-expect-error - missing in types
      // https://github.com/microsoft/TypeScript/issues/48829
      !Array.prototype.findLast ? findLast(unAccessor(list), (element, index, array) => fn(unAccessor(element), index, array)) : unAccessor(list).findLast((element, index, array) => fn(unAccessor(element), index, array))
    )
  );
}
function useArrayJoin(list, separator) {
  return createMemo(
    () => unAccessor(list).map((i) => unAccessor(i)).join(unAccessor(separator))
  );
}
function useArrayMap(list, fn) {
  return createMemo(
    () => unAccessor(list).map((i) => unAccessor(i)).map(fn)
  );
}
function useArrayReduce(list, reducer, ...args) {
  const reduceCallback = (sum, value, index) => reducer(unAccessor(sum), unAccessor(value), index);
  return createMemo(() => {
    const resolved = unAccessor(list);
    return args.length ? resolved.reduce(reduceCallback, unAccessor(args[0])) : resolved.reduce(reduceCallback);
  });
}
function useArraySome(list, fn) {
  return createMemo(() => unAccessor(list).some((element, index, array) => fn(unAccessor(element), index, array)));
}
function useArrayUnique(list) {
  return createMemo(() => [...new Set(unAccessor(list).map((element) => unAccessor(element)))]);
}
function useAsyncQueue(tasks, options = {}) {
  const { interrupt = true, onError = noop, onFinished = noop } = options;
  const promiseState = {
    pending: "pending",
    rejected: "rejected",
    fulfilled: "fulfilled"
  };
  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));
  const result = reactive(initialResult);
  const [activeIndex, setActiveIndex] = createSignal(-1);
  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex,
      result
    };
  }
  function updateResult(state, res) {
    setActiveIndex((val) => val + 1);
    result[activeIndex()].data = res;
    result[activeIndex()].state = state;
  }
  tasks.reduce((prev, curr) => {
    return prev.then((prevRes) => {
      var _a2;
      if (((_a2 = result[activeIndex()]) == null ? void 0 : _a2.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }
      return curr(prevRes).then((currentRes) => {
        updateResult(promiseState.fulfilled, currentRes);
        activeIndex() === tasks.length - 1 && onFinished();
        return currentRes;
      });
    }).catch((e) => {
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex,
    result
  };
}
function useCounter(initialValue = 0, options = {}) {
  const [count, setCount] = createSignal(initialValue);
  const { max = Infinity, min = -Infinity } = options;
  const inc = (delta = 1) => setCount(Math.min(max, count() + delta));
  const dec = (delta = 1) => setCount(Math.max(min, count() - delta));
  const set = (val) => setCount(Math.max(min, Math.min(max, val)));
  const reset = (val = initialValue) => {
    initialValue = val;
    return set(val);
  };
  return { count, inc, dec, set, reset };
}
const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
const REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
const defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {
  let m = hours < 12 ? "AM" : "PM";
  if (hasPeriod)
    m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
  return isLowercase ? m.toLowerCase() : m;
};
const formatDate = (date, formatStr, options = {}) => {
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const meridiem = options.customMeridiem ?? defaultMeridiem;
  const matches = {
    YY: () => String(years).slice(-2),
    YYYY: () => years,
    M: () => month + 1,
    MM: () => `${month + 1}`.padStart(2, "0"),
    MMM: () => date.toLocaleDateString(options.locales, { month: "short" }),
    MMMM: () => date.toLocaleDateString(options.locales, { month: "long" }),
    D: () => String(days),
    DD: () => `${days}`.padStart(2, "0"),
    H: () => String(hours),
    HH: () => `${hours}`.padStart(2, "0"),
    h: () => `${hours % 12 || 12}`.padStart(1, "0"),
    hh: () => `${hours % 12 || 12}`.padStart(2, "0"),
    m: () => String(minutes),
    mm: () => `${minutes}`.padStart(2, "0"),
    s: () => String(seconds),
    ss: () => `${seconds}`.padStart(2, "0"),
    SSS: () => `${milliseconds}`.padStart(3, "0"),
    d: () => day,
    dd: () => date.toLocaleDateString(options.locales, { weekday: "narrow" }),
    ddd: () => date.toLocaleDateString(options.locales, { weekday: "short" }),
    dddd: () => date.toLocaleDateString(options.locales, { weekday: "long" }),
    A: () => meridiem(hours, minutes),
    AA: () => meridiem(hours, minutes, false, true),
    a: () => meridiem(hours, minutes, true),
    aa: () => meridiem(hours, minutes, true, true)
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());
};
const normalizeDate = (date) => {
  if (date === null)
    return new Date(NaN);
  if (date === void 0)
    return new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = REGEX_PARSE.exec(date);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
function useDateFormat(date, formatStr = "HH:mm:ss", options = {}) {
  return createMemo(() => formatDate(normalizeDate(unAccessor(date)), unAccessor(formatStr), options));
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const { immediate = true, immediateCallback = false } = options;
  let timer = null;
  const [isActive, setIsActive] = createSignal(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    setIsActive(false);
    clean();
  }
  function resume() {
    const intervalValue = unAccessor(interval);
    if (intervalValue <= 0)
      return;
    setIsActive(true);
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isAccessor(interval)) {
    const stopWatch = watch(
      interval,
      () => {
        if (isActive() && isClient)
          resume();
      },
      { defer: true }
    );
    tryOnCleanup(stopWatch);
  }
  tryOnCleanup(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useInterval(interval = 1e3, options = {}) {
  const { controls: exposeControls = false, immediate = true, callback } = options;
  const [counter, setCounter] = createSignal(0);
  const update = () => setCounter((count) => count + 1);
  const reset = () => {
    setCounter(0);
  };
  const controls = useIntervalFn(
    callback ? () => {
      update();
      callback(counter());
    } : update,
    interval,
    { immediate }
  );
  if (exposeControls) {
    return {
      counter,
      reset,
      ...controls
    };
  }
  return counter;
}
function useLastChanged(deps, options = {}) {
  const [ms, setMs] = createSignal(options.initialValue ?? null);
  createEffect(
    on(
      deps,
      () => {
        setMs(timestamp());
      },
      { defer: options.defer }
    )
  );
  return ms;
}
const defaultSortFn = (source, compareFn) => source.sort(compareFn);
const defaultCompare = (a, b) => a - b;
function useSorted(...args) {
  const [source, setSource] = toSignal(args[0]);
  let compareFn = defaultCompare;
  let options = {};
  if (args.length === 2) {
    if (typeof args[1] === "object") {
      options = args[1];
      compareFn = options.compareFn ?? defaultCompare;
    } else {
      compareFn = args[1] ?? defaultCompare;
    }
  } else if (args.length > 2) {
    compareFn = args[1] ?? defaultCompare;
    options = args[2] ?? {};
  }
  const { dirty = false, sortFn = defaultSortFn } = options;
  if (!dirty)
    return createMemo(() => sortFn([...unAccessor(source)], compareFn));
  createEffect(() => {
    const result = sortFn(unAccessor(source), compareFn);
    if (isSignal(args[0]))
      setSource(result);
    else
      source().splice(0, source().length, ...result);
  });
  return source;
}
function useTimeoutFn(cb, interval, options = {}) {
  const { immediate = true } = options;
  const [isPending, setIsPending] = createSignal(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    setIsPending(false);
    clear();
  }
  function start(...args) {
    clear();
    setIsPending(true);
    timer = setTimeout(() => {
      setIsPending(false);
      timer = null;
      cb(...args);
    }, unAccessor(interval));
  }
  if (immediate) {
    setIsPending(true);
    if (isClient)
      start();
  }
  tryOnCleanup(stop);
  return {
    isPending,
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const { controls: exposeControls = false, callback } = options;
  const controls = useTimeoutFn(callback ?? noop, interval, options);
  const ready = createMemo(() => !controls.isPending());
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  }
  return ready;
}
function useTimeoutPoll(fn, interval, timeoutPollOptions) {
  const { start } = useTimeoutFn(loop, interval);
  const [isActive, setIsActive] = createSignal(false);
  async function loop() {
    if (!isActive())
      return;
    await fn();
    start();
  }
  function resume() {
    if (!isActive()) {
      setIsActive(true);
      loop();
    }
  }
  function pause() {
    setIsActive(false);
  }
  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)
    resume();
  tryOnCleanup(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useToNumber(value, options = {}) {
  const { method = "parseFloat", radix, nanToZero } = options;
  return createMemo(() => {
    let resolved = unAccessor(value);
    if (typeof resolved === "string")
      resolved = Number[method](resolved, radix);
    if (nanToZero && isNaN(resolved))
      resolved = 0;
    return resolved;
  });
}
function useToString(value) {
  return createMemo(() => `${unAccessor(value)}`);
}
function useToggle(initialValue = false, options = {}) {
  const { truthyValue = true, falsyValue = false } = options;
  const [_value, setValue] = createSignal(isAccessor(initialValue) ? initialValue() : initialValue);
  function toggle(value) {
    if (arguments.length) {
      setValue(value);
      return _value();
    }
    const truthy = unAccessor(truthyValue);
    setValue(_value() === truthy ? unAccessor(falsyValue) : truthy);
    return _value();
  }
  if (isAccessor(initialValue))
    return toggle;
  return [_value, toggle];
}
function watchArray(source, cb, options) {
  let oldList = (options == null ? void 0 : options.defer) === true ? source() : [];
  return watch(
    source,
    (newList) => {
      const oldListRemains = new Array(oldList.length);
      const added = [];
      for (const obj of newList) {
        let found = false;
        for (let i = 0; i < oldList.length; i++) {
          if (!oldListRemains[i] && obj === oldList[i]) {
            oldListRemains[i] = true;
            found = true;
            break;
          }
        }
        if (!found)
          added.push(obj);
      }
      const removed = oldList.filter((_, i) => !oldListRemains[i]);
      cb(newList, oldList, added, removed);
      oldList = [...newList];
    },
    options
  );
}
function watchWithFilter(source, cb, options = {}) {
  const { eventFilter = bypassFilter, ...watchOptions } = options;
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function watchAtMost(source, cb, options) {
  const { count, ...watchOptions } = options;
  const [current, setCurrent] = createSignal(0);
  const stop = watchWithFilter(
    source,
    (...args) => {
      setCurrent((current2) => current2 + 1);
      if (current() >= unAccessor(count))
        nextTick(() => stop());
      cb(...args);
    },
    watchOptions
  );
  return { count: current, stop };
}
function watchDebounced(source, cb, options = {}) {
  const { debounce = 0, maxWait = void 0, defer = true } = options;
  return watchWithFilter(source, cb, {
    defer,
    eventFilter: debounceFilter(debounce, { maxWait })
  });
}
function watchIgnorable(source, cb, options = {}) {
  const { defer = true, eventFilter = bypassFilter } = options;
  const filteredCb = createFilterWrapper(eventFilter, cb);
  const [ignore, setIgnore] = createSignal(false);
  const ignoreUpdates = (updater) => {
    setIgnore(true);
    updater();
    setIgnore(false);
  };
  const stop = watch(
    source,
    (input, prevInput, prev) => {
      if (!ignore()) {
        filteredCb(input, prevInput, prev);
      }
    },
    { defer }
  );
  return { stop, ignoreUpdates };
}
function watchOnce(source, cb, options = { defer: true }) {
  const stop = watch(
    source,
    (...args) => {
      nextTick(() => stop());
      return cb(...args);
    },
    options
  );
}
function watchPausable(source, cb, options = {}) {
  const { eventFilter: filter, defer = true } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(source, cb, {
    defer,
    eventFilter
  });
  return { stop, pause, resume, isActive };
}
function watchThrottled(source, cb, options = {}) {
  const { throttle = 0, trailing = true, leading = true, defer = true } = options;
  return watchWithFilter(source, cb, {
    defer,
    eventFilter: throttleFilter(throttle, trailing, leading)
  });
}
function watchTriggerable(source, cb, options = {}) {
  const _cb = (value, oldValue) => {
    return cb(value, oldValue);
  };
  const res = watchIgnorable(source, _cb, options);
  const { ignoreUpdates } = res;
  const trigger = () => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  };
  return {
    ...res,
    trigger
  };
}
function getWatchSources(sources) {
  if (Array.isArray(sources))
    return sources.map((item) => unAccessor(item));
  return unAccessor(sources);
}
function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}
function whenever(source, cb, onOptions) {
  return watch(
    source,
    (v, ov, onInvalidate) => {
      if (v)
        cb(v, ov, onInvalidate);
    },
    onOptions
  );
}
export {
  accessorDebounced,
  accessorDefault,
  accessorThrottled,
  assert,
  signalAutoReset as autoResetSignal,
  bypassFilter,
  clamp,
  containsProp,
  createEventHook,
  createFilterWrapper,
  reactify as createReactiveFn,
  createSharedComposable,
  createSingletonPromise,
  debounceFilter,
  accessorDebounced as debouncedAccessor,
  watchDebounced as debouncedWatch,
  formatDate,
  get,
  hasOwn,
  identity,
  watchIgnorable as ignorableEffect,
  increaseWithUnit,
  invoke,
  isBoolean,
  isClient,
  isDef,
  isDefined,
  isFunction,
  isIOS,
  isNumber,
  isObject,
  isString,
  isWindow,
  makeDestructurable,
  mutableMemo,
  nextTick2 as nextTick,
  noop,
  normalizeDate,
  now,
  objectPick,
  omitMutable,
  pausableFilter,
  watchPausable as pausableWatch,
  pickMutable,
  promiseTimeout,
  rand,
  reactify,
  reactifyObject,
  resolveAccessor,
  signalAutoReset,
  syncSignal,
  syncSignals,
  throttleFilter,
  accessorThrottled as throttledAccessor,
  watchThrottled as throttledWatch,
  timestamp,
  toAccessors,
  toReactive,
  tryOnCleanup,
  tryOnMount,
  unAccessor,
  until,
  useArrayEvery,
  useArrayFilter,
  useArrayFind,
  useArrayFindIndex,
  useArrayFindLast,
  useArrayJoin,
  useArrayMap,
  useArrayReduce,
  useArraySome,
  useArrayUnique,
  useAsyncQueue,
  useCounter,
  useDateFormat,
  accessorDebounced as useDebounce,
  useDebounceFn,
  useInterval,
  useIntervalFn,
  useLastChanged,
  useSorted,
  accessorThrottled as useThrottle,
  useThrottleFn,
  useTimeout,
  useTimeoutFn,
  useTimeoutPoll,
  useToNumber,
  useToString,
  useToggle,
  watch,
  watchArray,
  watchAtMost,
  watchDebounced,
  watchIgnorable,
  watchOnce,
  watchPausable,
  watchThrottled,
  watchTriggerable,
  watchWithFilter,
  whenever
};
