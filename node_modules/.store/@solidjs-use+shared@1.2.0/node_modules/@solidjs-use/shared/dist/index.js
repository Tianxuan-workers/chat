"use strict";
var _a;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const solidJs = require("solid-js");
const solidToVue = require("@solidjs-use/solid-to-vue");
const store = require("solid-js/store");
function unAccessor(r) {
  return typeof r === "function" ? r() : r;
}
const isClient = typeof window !== "undefined";
const isDef = (val) => typeof val !== "undefined";
const assert = (condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
};
const toString = Object.prototype.toString;
const isBoolean = (val) => typeof val === "boolean";
const isFunction = (val) => typeof val === "function";
const isNumber = (val) => typeof val === "number";
const isString = (val) => typeof val === "string";
const isObject = (val) => toString.call(val) === "[object Object]";
const isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
const now = () => Date.now();
const timestamp = () => +Date.now();
const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
const noop = () => {
};
const rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const owner = solidJs.getOwner();
  const filter = (invoke2) => {
    const duration = unAccessor(ms);
    const maxDuration = unAccessor(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return new Promise((resolve) => {
        solidJs.runWithOwner(owner, () => {
          resolve(invoke2());
        });
      });
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke2());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke2());
      }, duration);
    });
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop;
  let lastValue;
  const owner = solidJs.getOwner();
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop;
    }
  };
  const filter = (_invoke) => {
    const duration = unAccessor(ms);
    const elapsed = Date.now() - lastExec;
    const invoke2 = () => {
      return lastValue = _invoke();
    };
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      solidJs.runWithOwner(owner, () => {
        invoke2();
      });
      return;
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      solidJs.runWithOwner(owner, () => {
        invoke2();
      });
    } else if (trailing) {
      lastValue = new Promise((resolve, reject) => {
        lastRejector = rejectOnCancel ? reject : resolve;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          solidJs.runWithOwner(owner, () => {
            resolve(invoke2());
          });
          clear();
        }, Math.max(0, duration - elapsed));
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const [isActive, setIsActive] = solidJs.createSignal(true);
  function pause() {
    setIsActive(false);
  }
  function resume() {
    setIsActive(true);
  }
  const eventFilter = (...args) => {
    if (isActive())
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve, ms);
  });
}
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function invoke(fn) {
  return fn();
}
function containsProp(obj, ...props) {
  return props.some((k) => k in obj);
}
function increaseWithUnit(target, delta) {
  var _a2;
  if (typeof target === "number")
    return target + delta;
  const value = ((_a2 = /^-?[0-9]+\.?[0-9]*/.exec(target)) == null ? void 0 : _a2[0]) ?? "";
  const unit = target.slice(value.length);
  const result = parseFloat(value) + delta;
  if (Number.isNaN(result))
    return target;
  return `${result}${unit}`;
}
function objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}
function accessorDebounced(value, ms = 200, options = {}) {
  const [debounced, setDebounced] = solidJs.createSignal(value());
  const updater = useDebounceFn(
    () => {
      setDebounced(() => value());
    },
    ms,
    options
  );
  solidJs.createEffect(
    solidJs.on(
      value,
      () => {
        updater();
      },
      { defer: true }
    )
  );
  return debounced;
}
function accessorDefault(source, defaultValue) {
  return solidJs.createMemo(() => source() ?? defaultValue);
}
function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);
}
function accessorThrottled(value, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value;
  const [throttled, setThrottled] = solidJs.createSignal(value());
  const updater = useThrottleFn(
    () => {
      setThrottled(() => value());
    },
    delay,
    trailing,
    leading
  );
  solidJs.createEffect(
    solidJs.on(
      value,
      () => {
        updater();
      },
      { defer: true }
    )
  );
  return throttled;
}
function tryOnCleanup(fn) {
  if (solidJs.getOwner()) {
    solidJs.onCleanup(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = [];
  const off = (fn) => {
    const index = fns.indexOf(fn);
    if (index !== -1)
      fns.splice(index, 1);
  };
  const on = (fn) => {
    fns.push(fn);
    const offFn = () => off(fn);
    tryOnCleanup(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (param) => {
    fns.forEach((fn) => fn(param));
  };
  return {
    on,
    off,
    trigger
  };
}
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let disposer;
  const dispose = () => {
    subscribers -= 1;
    if (disposer && subscribers <= 0) {
      disposer();
      state = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      solidJs.createRoot((_disposer) => {
        disposer = _disposer;
        state = composable(...args);
      });
    }
    tryOnCleanup(dispose);
    return state;
  };
}
function get(obj, key) {
  if (key == null)
    return unAccessor(obj);
  return unAccessor(obj)[key];
}
function isDefined(v) {
  return unAccessor(v) != null;
}
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = { ...obj };
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index = 0;
        return {
          next: () => ({
            value: arr[index++],
            done: index > arr.length
          })
        };
      }
    });
    return clone;
  }
  return Object.assign([...arr], obj);
}
function toReactive(objectAccessor) {
  if (!solidToVue.isAccessor(objectAccessor))
    return store.createMutable(objectAccessor);
  const proxy = new Proxy(
    {},
    {
      get(_, p, receiver) {
        return unAccessor(Reflect.get(objectAccessor(), p, receiver));
      },
      has(_, p) {
        return Reflect.has(objectAccessor(), p);
      },
      ownKeys() {
        return Object.keys(objectAccessor());
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    }
  );
  return proxy;
}
function mutableMemo(fn) {
  return toReactive(solidJs.createMemo(fn));
}
function omitMutable(obj, ...keys) {
  const res = store.createMutable({});
  const validKeys = solidJs.createMemo(() => {
    const flatKeys = keys.flat();
    const allKeys = Object.keys(obj);
    const validKeys2 = allKeys.filter((key) => !flatKeys.includes(key));
    return validKeys2;
  });
  return new Proxy({}, {
    get(_, p, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.get(obj, p, receiver);
      }
      return Reflect.get(res, p, receiver);
    },
    set(_, p, newValue, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.set(obj, p, newValue, receiver);
      }
      return Reflect.set(res, p, newValue, receiver);
    },
    ownKeys() {
      return [...validKeys(), ...Object.keys(res)];
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
}
function pickMutable(obj, ...keys) {
  const res = store.createMutable({});
  const validKeys = solidJs.createMemo(() => {
    const flatKeys = keys.flat();
    const allKeys = Object.keys(obj);
    const validKeys2 = allKeys.filter((key) => flatKeys.includes(key));
    return validKeys2;
  });
  return new Proxy({}, {
    get(_, p, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.get(obj, p, receiver);
      }
      return Reflect.get(res, p, receiver);
    },
    set(_, p, newValue, receiver) {
      if (validKeys().includes(p)) {
        return Reflect.set(obj, p, newValue, receiver);
      }
      return Reflect.set(res, p, newValue, receiver);
    },
    ownKeys() {
      return [...validKeys(), ...Object.keys(res)];
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
}
function reactify(fn) {
  return function(...args) {
    return solidJs.createMemo(
      () => fn.apply(
        this,
        args.map((i) => unAccessor(i))
      )
    );
  };
}
function reactifyObject(obj, optionsOrKeys = {}) {
  let keys = [];
  if (Array.isArray(optionsOrKeys)) {
    keys = optionsOrKeys;
  } else {
    const { includeOwnProperties = true } = optionsOrKeys;
    keys.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(
    keys.map((key) => {
      const value = obj[key];
      return [key, typeof value === "function" ? reactify(value.bind(obj)) : value];
    })
  );
}
function resolveAccessor(r) {
  return solidToVue.isAccessor(r) ? r : () => r;
}
function signalAutoReset(defaultValue, afterMs = 1e4) {
  const [value, setVal] = solidJs.createSignal(defaultValue);
  let timer;
  const resetAfter = () => setTimeout(() => {
    setVal(() => defaultValue);
  }, unAccessor(afterMs));
  tryOnCleanup(() => {
    clearTimeout(timer);
  });
  const setNewVal = (newValue) => {
    setVal(newValue);
    clearTimeout(timer);
    timer = resetAfter();
  };
  return [value, setNewVal];
}
function toAccessors(props, defaultProps) {
  const obj = {};
  Object.keys(props).forEach((key) => {
    obj[key] = solidJs.createMemo(() => props[key] ?? (defaultProps == null ? void 0 : defaultProps[key]));
  });
  return obj;
}
function watch(deps, fn, options) {
  const [isWatch, setIsWatch] = solidJs.createSignal(true);
  solidJs.createEffect(
    solidJs.on(
      getAccessors(deps),
      (input, prevInput, prev) => {
        if (isWatch()) {
          fn(input, prevInput, prev);
        }
      },
      options
    )
  );
  const stop = () => {
    setIsWatch(false);
  };
  return stop;
}
function getAccessors(deps) {
  if (Array.isArray(deps))
    return deps;
  if (isObject(deps)) {
    return Object.values(toAccessors(deps));
  }
  if (solidToVue.isAccessor(deps))
    return deps;
  return () => deps;
}
function syncSignal([left, setLeft], [right, setRight], options = {}) {
  const { defer, direction = "both", transform = {} } = options;
  let watchLeft;
  let watchRight;
  const transformLTR = transform.ltr ?? ((v) => v);
  const transformRTL = transform.rtl ?? ((v) => v);
  if (direction === "both" || direction === "ltr") {
    watchLeft = watch(
      left,
      (newValue) => {
        setRight(() => transformLTR(newValue));
      },
      { defer }
    );
  }
  if (direction === "both" || direction === "rtl") {
    watchRight = watch(
      right,
      (newValue) => {
        setLeft(() => transformRTL(newValue));
      },
      { defer }
    );
  }
  return () => {
    watchLeft == null ? void 0 : watchLeft();
    watchRight == null ? void 0 : watchRight();
  };
}
function syncSignals(source, targets, options = {}) {
  if (!Array.isArray(targets))
    targets = [targets];
  return watch(
    source,
    (newValue) => {
      targets.forEach((setTarget) => setTarget(() => newValue));
    },
    options
  );
}
function tryOnMount(fn, sync = true) {
  if (solidJs.getOwner())
    solidJs.onMount(fn);
  else if (sync)
    fn();
  else
    solidToVue.nextTick(fn);
}
function createUntil(r, isNot = false, selfOwner) {
  const owner = selfOwner ?? solidJs.getOwner();
  function toMatch(condition, { timeout, throwOnTimeout } = {}) {
    let stop = null;
    const watcher = new Promise((resolve) => {
      solidJs.runWithOwner(owner, () => {
        stop = watch(r, (v) => {
          if (condition(v) !== isNot) {
            stop == null ? void 0 : stop();
            resolve(v);
          }
        });
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => unAccessor(r)).finally(() => stop == null ? void 0 : stop())
      );
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!solidToVue.isAccessor(value))
      return toMatch((v) => v === value, options);
    const { timeout, throwOnTimeout } = options ?? {};
    let stop = null;
    const watcher = new Promise((resolve) => {
      solidJs.runWithOwner(owner, () => {
        stop = watch([r, value], ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            stop == null ? void 0 : stop();
            resolve(v1);
          }
        });
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => unAccessor(r)).finally(() => {
          stop == null ? void 0 : stop();
          return unAccessor(r);
        })
      );
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(unAccessor(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(unAccessor(r))) {
    const instance2 = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot, owner);
      }
    };
    return instance2;
  }
  const instance = {
    toMatch,
    toBe,
    toBeTruthy,
    toBeNull,
    toBeNaN,
    toBeUndefined,
    changed,
    changedTimes,
    get not() {
      return createUntil(r, !isNot, owner);
    }
  };
  return instance;
}
function until(r, owner) {
  return createUntil(r, false, owner);
}
function useArrayEvery(list, fn) {
  return solidJs.createMemo(() => unAccessor(list).every((element, index, array) => fn(unAccessor(element), index, array)));
}
function useArrayFilter(list, fn) {
  return solidJs.createMemo(
    () => unAccessor(list).map((i) => unAccessor(i)).filter(fn)
  );
}
function useArrayFind(list, fn) {
  return solidJs.createMemo(
    () => unAccessor(unAccessor(list).find((element, index, array) => fn(unAccessor(element), index, array)))
  );
}
function useArrayFindIndex(list, fn) {
  return solidJs.createMemo(() => unAccessor(list).findIndex((element, index, array) => fn(unAccessor(element), index, array)));
}
function findLast(arr, cb) {
  let index = arr.length;
  while (index-- > 0) {
    if (cb(arr[index], index, arr))
      return arr[index];
  }
  return void 0;
}
function useArrayFindLast(list, fn) {
  return solidJs.createMemo(
    () => unAccessor(
      // @ts-expect-error - missing in types
      // https://github.com/microsoft/TypeScript/issues/48829
      !Array.prototype.findLast ? findLast(unAccessor(list), (element, index, array) => fn(unAccessor(element), index, array)) : unAccessor(list).findLast((element, index, array) => fn(unAccessor(element), index, array))
    )
  );
}
function useArrayJoin(list, separator) {
  return solidJs.createMemo(
    () => unAccessor(list).map((i) => unAccessor(i)).join(unAccessor(separator))
  );
}
function useArrayMap(list, fn) {
  return solidJs.createMemo(
    () => unAccessor(list).map((i) => unAccessor(i)).map(fn)
  );
}
function useArrayReduce(list, reducer, ...args) {
  const reduceCallback = (sum, value, index) => reducer(unAccessor(sum), unAccessor(value), index);
  return solidJs.createMemo(() => {
    const resolved = unAccessor(list);
    return args.length ? resolved.reduce(reduceCallback, unAccessor(args[0])) : resolved.reduce(reduceCallback);
  });
}
function useArraySome(list, fn) {
  return solidJs.createMemo(() => unAccessor(list).some((element, index, array) => fn(unAccessor(element), index, array)));
}
function useArrayUnique(list) {
  return solidJs.createMemo(() => [...new Set(unAccessor(list).map((element) => unAccessor(element)))]);
}
function useAsyncQueue(tasks, options = {}) {
  const { interrupt = true, onError = noop, onFinished = noop } = options;
  const promiseState = {
    pending: "pending",
    rejected: "rejected",
    fulfilled: "fulfilled"
  };
  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));
  const result = solidToVue.reactive(initialResult);
  const [activeIndex, setActiveIndex] = solidJs.createSignal(-1);
  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex,
      result
    };
  }
  function updateResult(state, res) {
    setActiveIndex((val) => val + 1);
    result[activeIndex()].data = res;
    result[activeIndex()].state = state;
  }
  tasks.reduce((prev, curr) => {
    return prev.then((prevRes) => {
      var _a2;
      if (((_a2 = result[activeIndex()]) == null ? void 0 : _a2.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }
      return curr(prevRes).then((currentRes) => {
        updateResult(promiseState.fulfilled, currentRes);
        activeIndex() === tasks.length - 1 && onFinished();
        return currentRes;
      });
    }).catch((e) => {
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex,
    result
  };
}
function useCounter(initialValue = 0, options = {}) {
  const [count, setCount] = solidJs.createSignal(initialValue);
  const { max = Infinity, min = -Infinity } = options;
  const inc = (delta = 1) => setCount(Math.min(max, count() + delta));
  const dec = (delta = 1) => setCount(Math.max(min, count() - delta));
  const set = (val) => setCount(Math.max(min, Math.min(max, val)));
  const reset = (val = initialValue) => {
    initialValue = val;
    return set(val);
  };
  return { count, inc, dec, set, reset };
}
const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
const REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
const defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {
  let m = hours < 12 ? "AM" : "PM";
  if (hasPeriod)
    m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
  return isLowercase ? m.toLowerCase() : m;
};
const formatDate = (date, formatStr, options = {}) => {
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const meridiem = options.customMeridiem ?? defaultMeridiem;
  const matches = {
    YY: () => String(years).slice(-2),
    YYYY: () => years,
    M: () => month + 1,
    MM: () => `${month + 1}`.padStart(2, "0"),
    MMM: () => date.toLocaleDateString(options.locales, { month: "short" }),
    MMMM: () => date.toLocaleDateString(options.locales, { month: "long" }),
    D: () => String(days),
    DD: () => `${days}`.padStart(2, "0"),
    H: () => String(hours),
    HH: () => `${hours}`.padStart(2, "0"),
    h: () => `${hours % 12 || 12}`.padStart(1, "0"),
    hh: () => `${hours % 12 || 12}`.padStart(2, "0"),
    m: () => String(minutes),
    mm: () => `${minutes}`.padStart(2, "0"),
    s: () => String(seconds),
    ss: () => `${seconds}`.padStart(2, "0"),
    SSS: () => `${milliseconds}`.padStart(3, "0"),
    d: () => day,
    dd: () => date.toLocaleDateString(options.locales, { weekday: "narrow" }),
    ddd: () => date.toLocaleDateString(options.locales, { weekday: "short" }),
    dddd: () => date.toLocaleDateString(options.locales, { weekday: "long" }),
    A: () => meridiem(hours, minutes),
    AA: () => meridiem(hours, minutes, false, true),
    a: () => meridiem(hours, minutes, true),
    aa: () => meridiem(hours, minutes, true, true)
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());
};
const normalizeDate = (date) => {
  if (date === null)
    return new Date(NaN);
  if (date === void 0)
    return new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = REGEX_PARSE.exec(date);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
function useDateFormat(date, formatStr = "HH:mm:ss", options = {}) {
  return solidJs.createMemo(() => formatDate(normalizeDate(unAccessor(date)), unAccessor(formatStr), options));
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const { immediate = true, immediateCallback = false } = options;
  let timer = null;
  const [isActive, setIsActive] = solidJs.createSignal(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    setIsActive(false);
    clean();
  }
  function resume() {
    const intervalValue = unAccessor(interval);
    if (intervalValue <= 0)
      return;
    setIsActive(true);
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (solidToVue.isAccessor(interval)) {
    const stopWatch = watch(
      interval,
      () => {
        if (isActive() && isClient)
          resume();
      },
      { defer: true }
    );
    tryOnCleanup(stopWatch);
  }
  tryOnCleanup(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useInterval(interval = 1e3, options = {}) {
  const { controls: exposeControls = false, immediate = true, callback } = options;
  const [counter, setCounter] = solidJs.createSignal(0);
  const update = () => setCounter((count) => count + 1);
  const reset = () => {
    setCounter(0);
  };
  const controls = useIntervalFn(
    callback ? () => {
      update();
      callback(counter());
    } : update,
    interval,
    { immediate }
  );
  if (exposeControls) {
    return {
      counter,
      reset,
      ...controls
    };
  }
  return counter;
}
function useLastChanged(deps, options = {}) {
  const [ms, setMs] = solidJs.createSignal(options.initialValue ?? null);
  solidJs.createEffect(
    solidJs.on(
      deps,
      () => {
        setMs(timestamp());
      },
      { defer: options.defer }
    )
  );
  return ms;
}
const defaultSortFn = (source, compareFn) => source.sort(compareFn);
const defaultCompare = (a, b) => a - b;
function useSorted(...args) {
  const [source, setSource] = solidToVue.toSignal(args[0]);
  let compareFn = defaultCompare;
  let options = {};
  if (args.length === 2) {
    if (typeof args[1] === "object") {
      options = args[1];
      compareFn = options.compareFn ?? defaultCompare;
    } else {
      compareFn = args[1] ?? defaultCompare;
    }
  } else if (args.length > 2) {
    compareFn = args[1] ?? defaultCompare;
    options = args[2] ?? {};
  }
  const { dirty = false, sortFn = defaultSortFn } = options;
  if (!dirty)
    return solidJs.createMemo(() => sortFn([...unAccessor(source)], compareFn));
  solidJs.createEffect(() => {
    const result = sortFn(unAccessor(source), compareFn);
    if (solidToVue.isSignal(args[0]))
      setSource(result);
    else
      source().splice(0, source().length, ...result);
  });
  return source;
}
function useTimeoutFn(cb, interval, options = {}) {
  const { immediate = true } = options;
  const [isPending, setIsPending] = solidJs.createSignal(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    setIsPending(false);
    clear();
  }
  function start(...args) {
    clear();
    setIsPending(true);
    timer = setTimeout(() => {
      setIsPending(false);
      timer = null;
      cb(...args);
    }, unAccessor(interval));
  }
  if (immediate) {
    setIsPending(true);
    if (isClient)
      start();
  }
  tryOnCleanup(stop);
  return {
    isPending,
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const { controls: exposeControls = false, callback } = options;
  const controls = useTimeoutFn(callback ?? noop, interval, options);
  const ready = solidJs.createMemo(() => !controls.isPending());
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  }
  return ready;
}
function useTimeoutPoll(fn, interval, timeoutPollOptions) {
  const { start } = useTimeoutFn(loop, interval);
  const [isActive, setIsActive] = solidJs.createSignal(false);
  async function loop() {
    if (!isActive())
      return;
    await fn();
    start();
  }
  function resume() {
    if (!isActive()) {
      setIsActive(true);
      loop();
    }
  }
  function pause() {
    setIsActive(false);
  }
  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)
    resume();
  tryOnCleanup(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useToNumber(value, options = {}) {
  const { method = "parseFloat", radix, nanToZero } = options;
  return solidJs.createMemo(() => {
    let resolved = unAccessor(value);
    if (typeof resolved === "string")
      resolved = Number[method](resolved, radix);
    if (nanToZero && isNaN(resolved))
      resolved = 0;
    return resolved;
  });
}
function useToString(value) {
  return solidJs.createMemo(() => `${unAccessor(value)}`);
}
function useToggle(initialValue = false, options = {}) {
  const { truthyValue = true, falsyValue = false } = options;
  const [_value, setValue] = solidJs.createSignal(solidToVue.isAccessor(initialValue) ? initialValue() : initialValue);
  function toggle(value) {
    if (arguments.length) {
      setValue(value);
      return _value();
    }
    const truthy = unAccessor(truthyValue);
    setValue(_value() === truthy ? unAccessor(falsyValue) : truthy);
    return _value();
  }
  if (solidToVue.isAccessor(initialValue))
    return toggle;
  return [_value, toggle];
}
function watchArray(source, cb, options) {
  let oldList = (options == null ? void 0 : options.defer) === true ? source() : [];
  return watch(
    source,
    (newList) => {
      const oldListRemains = new Array(oldList.length);
      const added = [];
      for (const obj of newList) {
        let found = false;
        for (let i = 0; i < oldList.length; i++) {
          if (!oldListRemains[i] && obj === oldList[i]) {
            oldListRemains[i] = true;
            found = true;
            break;
          }
        }
        if (!found)
          added.push(obj);
      }
      const removed = oldList.filter((_, i) => !oldListRemains[i]);
      cb(newList, oldList, added, removed);
      oldList = [...newList];
    },
    options
  );
}
function watchWithFilter(source, cb, options = {}) {
  const { eventFilter = bypassFilter, ...watchOptions } = options;
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function watchAtMost(source, cb, options) {
  const { count, ...watchOptions } = options;
  const [current, setCurrent] = solidJs.createSignal(0);
  const stop = watchWithFilter(
    source,
    (...args) => {
      setCurrent((current2) => current2 + 1);
      if (current() >= unAccessor(count))
        solidToVue.nextTick(() => stop());
      cb(...args);
    },
    watchOptions
  );
  return { count: current, stop };
}
function watchDebounced(source, cb, options = {}) {
  const { debounce = 0, maxWait = void 0, defer = true } = options;
  return watchWithFilter(source, cb, {
    defer,
    eventFilter: debounceFilter(debounce, { maxWait })
  });
}
function watchIgnorable(source, cb, options = {}) {
  const { defer = true, eventFilter = bypassFilter } = options;
  const filteredCb = createFilterWrapper(eventFilter, cb);
  const [ignore, setIgnore] = solidJs.createSignal(false);
  const ignoreUpdates = (updater) => {
    setIgnore(true);
    updater();
    setIgnore(false);
  };
  const stop = watch(
    source,
    (input, prevInput, prev) => {
      if (!ignore()) {
        filteredCb(input, prevInput, prev);
      }
    },
    { defer }
  );
  return { stop, ignoreUpdates };
}
function watchOnce(source, cb, options = { defer: true }) {
  const stop = watch(
    source,
    (...args) => {
      solidToVue.nextTick(() => stop());
      return cb(...args);
    },
    options
  );
}
function watchPausable(source, cb, options = {}) {
  const { eventFilter: filter, defer = true } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(source, cb, {
    defer,
    eventFilter
  });
  return { stop, pause, resume, isActive };
}
function watchThrottled(source, cb, options = {}) {
  const { throttle = 0, trailing = true, leading = true, defer = true } = options;
  return watchWithFilter(source, cb, {
    defer,
    eventFilter: throttleFilter(throttle, trailing, leading)
  });
}
function watchTriggerable(source, cb, options = {}) {
  const _cb = (value, oldValue) => {
    return cb(value, oldValue);
  };
  const res = watchIgnorable(source, _cb, options);
  const { ignoreUpdates } = res;
  const trigger = () => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  };
  return {
    ...res,
    trigger
  };
}
function getWatchSources(sources) {
  if (Array.isArray(sources))
    return sources.map((item) => unAccessor(item));
  return unAccessor(sources);
}
function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}
function whenever(source, cb, onOptions) {
  return watch(
    source,
    (v, ov, onInvalidate) => {
      if (v)
        cb(v, ov, onInvalidate);
    },
    onOptions
  );
}
Object.defineProperty(exports, "nextTick", {
  enumerable: true,
  get: () => solidToVue.nextTick
});
exports.accessorDebounced = accessorDebounced;
exports.accessorDefault = accessorDefault;
exports.accessorThrottled = accessorThrottled;
exports.assert = assert;
exports.autoResetSignal = signalAutoReset;
exports.bypassFilter = bypassFilter;
exports.clamp = clamp;
exports.containsProp = containsProp;
exports.createEventHook = createEventHook;
exports.createFilterWrapper = createFilterWrapper;
exports.createReactiveFn = reactify;
exports.createSharedComposable = createSharedComposable;
exports.createSingletonPromise = createSingletonPromise;
exports.debounceFilter = debounceFilter;
exports.debouncedAccessor = accessorDebounced;
exports.debouncedWatch = watchDebounced;
exports.formatDate = formatDate;
exports.get = get;
exports.hasOwn = hasOwn;
exports.identity = identity;
exports.ignorableEffect = watchIgnorable;
exports.increaseWithUnit = increaseWithUnit;
exports.invoke = invoke;
exports.isBoolean = isBoolean;
exports.isClient = isClient;
exports.isDef = isDef;
exports.isDefined = isDefined;
exports.isFunction = isFunction;
exports.isIOS = isIOS;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;
exports.isWindow = isWindow;
exports.makeDestructurable = makeDestructurable;
exports.mutableMemo = mutableMemo;
exports.noop = noop;
exports.normalizeDate = normalizeDate;
exports.now = now;
exports.objectPick = objectPick;
exports.omitMutable = omitMutable;
exports.pausableFilter = pausableFilter;
exports.pausableWatch = watchPausable;
exports.pickMutable = pickMutable;
exports.promiseTimeout = promiseTimeout;
exports.rand = rand;
exports.reactify = reactify;
exports.reactifyObject = reactifyObject;
exports.resolveAccessor = resolveAccessor;
exports.signalAutoReset = signalAutoReset;
exports.syncSignal = syncSignal;
exports.syncSignals = syncSignals;
exports.throttleFilter = throttleFilter;
exports.throttledAccessor = accessorThrottled;
exports.throttledWatch = watchThrottled;
exports.timestamp = timestamp;
exports.toAccessors = toAccessors;
exports.toReactive = toReactive;
exports.tryOnCleanup = tryOnCleanup;
exports.tryOnMount = tryOnMount;
exports.unAccessor = unAccessor;
exports.until = until;
exports.useArrayEvery = useArrayEvery;
exports.useArrayFilter = useArrayFilter;
exports.useArrayFind = useArrayFind;
exports.useArrayFindIndex = useArrayFindIndex;
exports.useArrayFindLast = useArrayFindLast;
exports.useArrayJoin = useArrayJoin;
exports.useArrayMap = useArrayMap;
exports.useArrayReduce = useArrayReduce;
exports.useArraySome = useArraySome;
exports.useArrayUnique = useArrayUnique;
exports.useAsyncQueue = useAsyncQueue;
exports.useCounter = useCounter;
exports.useDateFormat = useDateFormat;
exports.useDebounce = accessorDebounced;
exports.useDebounceFn = useDebounceFn;
exports.useInterval = useInterval;
exports.useIntervalFn = useIntervalFn;
exports.useLastChanged = useLastChanged;
exports.useSorted = useSorted;
exports.useThrottle = accessorThrottled;
exports.useThrottleFn = useThrottleFn;
exports.useTimeout = useTimeout;
exports.useTimeoutFn = useTimeoutFn;
exports.useTimeoutPoll = useTimeoutPoll;
exports.useToNumber = useToNumber;
exports.useToString = useToString;
exports.useToggle = useToggle;
exports.watch = watch;
exports.watchArray = watchArray;
exports.watchAtMost = watchAtMost;
exports.watchDebounced = watchDebounced;
exports.watchIgnorable = watchIgnorable;
exports.watchOnce = watchOnce;
exports.watchPausable = watchPausable;
exports.watchThrottled = watchThrottled;
exports.watchTriggerable = watchTriggerable;
exports.watchWithFilter = watchWithFilter;
exports.whenever = whenever;
